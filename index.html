<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Skullory</title>
<style>
  :root{
    --bg-1:#141724; --bg-2:#232a46; --bg-3:#2b335c; --bg-4:#28315a;
    --panel:#0f1322; --panel-1:#12162a; --panel-2:#0d1120; --panel-border:#2b3357;
    --grid-1:#101429; --grid-2:#0c1020; --grid-border:#2b3357;
    --card-back:#2a3157; --card-front:#171b2d; --card-border:#394275; --card-pattern:#3b4479;
    --accent:#7484ff; --ok:#52ce89; --bad:#f4606c; --text:#f5f5f8; --muted:#c8cde0;
    --gap:12px; --radius:16px; --shadow:0 10px 30px rgba(0,0,0,.35);
    --flip-ms:380ms; --cols:4;
  }
  /* THEME CLASSES (override variables) */
  body.theme-1{ --card-pattern:#3b4479;  --bg-1:#141724; --bg-2:#232a46; --bg-3:#2b335c; --bg-4:#28315a; --panel:#0f1322; --panel-1:#12162a; --panel-2:#0d1120; --panel-border:#2b3357; --grid-1:#101429; --grid-2:#0c1020; --grid-border:#2b3357; --card-back:#2a3157; --card-front:#171b2d; --card-border:#394275; --card-pattern:#3b4479; --accent:#7484ff; --ok:#52ce89; --bad:#f4606c; --text:#f5f5f8; --muted:#c8cde0; }
  body.theme-2{ --card-pattern:#5d3a78;  --bg-1:#2b1838; --bg-2:#401b3f; --bg-3:#52234f; --bg-4:#5a2558; --panel:#1a0f24; --panel-1:#2a1536; --panel-2:#0c1b29; --panel-border:#4e2b6b; --grid-1:#261433; --grid-2:#0c1020; --grid-border:#4e2b6b; --card-back:#3b2648; --card-front:#23142e; --card-border:#5d3a78; --accent:#ff7a59; --ok:#56df9a; --bad:#ff5c7a; --text:#fff3f5; --muted:#e0c9d6; }
  body.theme-3{ --card-pattern:#2c6a4c;  --bg-1:#0f1a14; --bg-2:#163024; --bg-3:#1c3d2c; --bg-4:#214736; --panel:#0b1913; --panel-1:#0f221a; --panel-2:#0c1b14; --panel-border:#2a5a43; --grid-1:#13261e; --grid-2:#0e1f18; --grid-border:#2a5a43; --card-back:#183b2b; --card-front:#0f221a; --card-border:#2c6a4c; --accent:#9be564; --ok:#4fe39c; --bad:#ff6b6b; --text:#eaf7ef; --muted:#b4d7c7; }
  body.theme-4{ --card-pattern:#7a5f44;  --bg-1:#2a241d; --bg-2:#3a2f23; --bg-3:#4a3b2b; --bg-4:#5a4a35; --panel:#1c1712; --panel-1:#251e17; --panel-2:#19140f; --panel-border:#6c553d; --grid-1:#211b15; --grid-2:#1a150f; --grid-border:#6c553d; --card-back:#4b3b2b; --card-front:#2a2119; --card-border:#7a5f44; --accent:#ffb84d; --ok:#7adf8a; --bad:#ff7f66; --text:#fff6e9; --muted:#e6d2b8; }
  body.theme-5{ --card-pattern:#2f5f80;  --bg-1:#0f1e2a; --bg-2:#123346; --bg-3:#17425a; --bg-4:#1a4b66; --panel:#0a1722; --panel-1:#0d2130; --panel-2:#0a1a26; --panel-border:#2b5574; --grid-1:#0f2736; --grid-2:#0b1f2a; --grid-border:#2b5574; --card-back:#163b52; --card-front:#0d2330; --card-border:#2f5f80; --accent:#4fd1ff; --ok:#6ae6b5; --bad:#ff6a7a; --text:#e6f7ff; --muted:#bdd8e7; }
  body.theme-6{ --card-pattern:#7a3535;  --bg-1:#1b1212; --bg-2:#2a1717; --bg-3:#3a1e1e; --bg-4:#4a2525; --panel:#140d0d; --panel-1:#1c1212; --panel-2:#110a0a; --panel-border:#6b2f2b; --grid-1:#1f1414; --grid-2:#170f0f; --grid-border:#6b2f2b; --card-back:#3a1e1e; --card-front:#241212; --card-border:#7a3535; --accent:#ff5e3a; --ok:#50e3a4; --bad:#ff4d4d; --text:#ffeceb; --muted:#e0b3b3; }
  body.theme-7{ --card-pattern:#415082;  --bg-1:#0f1116; --bg-2:#191d2b; --bg-3:#1f2640; --bg-4:#232b48; --panel:#0a0c12; --panel-1:#111521; --panel-2:#0d1019; --panel-border:#384064; --grid-1:#131827; --grid-2:#0f1320; --grid-border:#384064; --card-back:#1d2336; --card-front:#0f1522; --card-border:#415082; --accent:#ff3fb4; --ok:#50e3c2; --bad:#ff6b8b; --text:#f7f7ff; --muted:#c8cbe6; }
  body.theme-8{ --card-pattern:#2e6a73;  --bg-1:#0e1a1c; --bg-2:#14333a; --bg-3:#184249; --bg-4:#1d4e57; --panel:#0a1618; --panel-1:#0d2023; --panel-2:#0a1a1d; --panel-border:#2b5861; --grid-1:#10282d; --grid-2:#0c2024; --grid-border:#2b5861; --card-back:#15454d; --card-front:#0e262c; --card-border:#2e6a73; --accent:#42d6c5; --ok:#60e8a8; --bad:#ff6f7c; --text:#e8fffb; --muted:#bfe2de; }
  body.theme-9{ --card-pattern:#44684a;  --bg-1:#111a12; --bg-2:#1b2a1c; --bg-3:#223826; --bg-4:#284330; --panel:#0c140d; --panel-1:#111c13; --panel-2:#0d160f; --panel-border:#3b5f41; --grid-1:#162418; --grid-2:#111d13; --grid-border:#3b5f41; --card-back:#223b25; --card-front:#142018; --card-border:#44684a; --accent:#7bd88f; --ok:#6ee7b7; --bad:#ef6464; --text:#eaf6ee; --muted:#c7dccb; }
  body.theme-10{ --card-pattern:#57459a;  --bg-1:#1e1630; --bg-2:#2a1e46; --bg-3:#34285a; --bg-4:#3f306d; --panel:#150f22; --panel-1:#1e1733; --panel-2:#17102a; --panel-border:#4b3a7a; --grid-1:#221a3a; --grid-2:#1a1430; --grid-border:#4b3a7a; --card-back:#2f2759; --card-front:#1b1533; --card-border:#57459a; --accent:#00e0ff; --ok:#66f0a6; --bad:#ff7aa2; --text:#f4f2ff; --muted:#cdc6ff; }

  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; color:var(--text); font:16px/1.45 system-ui,Segoe UI,Roboto,Helvetica,Arial;
    background:
      radial-gradient(1200px 800px at 20% -10%, var(--bg-3), transparent),
      radial-gradient(900px 600px at 110% 20%, var(--bg-4), transparent),
      linear-gradient(180deg, var(--bg-1), var(--bg-2));
    display:flex; 
    align-items:flex-start;
    justify-content:center; 
    padding:10px 18px 18px;
    -webkit-font-smoothing: antialiased; 
    min-height:100dvh;
  }
  .wrap{ width:min(1100px, 98vw); margin: 30px auto 0; }
  .top{
    display:block;
    padding: 0;
  }

  .brand{ width:100%; }

  .brand img{
    display:block;
    width:100%;
    height:auto;
    max-height: 70px;
  }

  .controls { display: flex; gap: 6px; }
  .controls-bottom{
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 8px;
    width: 100%;
    margin-top: 14px;
  }
  .controls-left, .controls-right{
    display: flex;
    align-items: center;
    gap: 8px;
  }

  /* Riduci la larghezza SOLO dei tre bottoni in alto a destra */
  .controls-bottom .outline-btn{
    padding: 8px 8px;
    min-width: 40px;
  }

  /* Stato visivo disabilitato, ma cliccabile per mostrare l’help */
  .controls-right .power-btn[aria-disabled="true"]{
    filter: grayscale(100%);
    opacity: .35;
    cursor: not-allowed;
    box-shadow: none;
    border-color: #3a4168;
  }
  .controls-right .power-btn[aria-disabled="true"]:hover{
    transform: none;
    box-shadow: none;
  }

  button.primary{background:var(--accent); color:#0b0f1e; border:none; padding:10px 16px; border-radius:12px; font-weight:700; cursor:pointer}
  button.primary:active{transform:translateY(1px)}
  .stats-container{ display:flex; justify-content:center; margin:12px 0 8px; gap:12px; flex-wrap:wrap }
  .stats{ display:flex; align-items:center; gap:12px; flex-wrap:wrap; justify-content:center }
  .chip{ padding:8px 12px; border-radius:999px; background:#1a1f37; border:1px solid var(--panel-border); color:#c8cde0; white-space:nowrap }
  .level-chip{ padding:6px 10px; border-radius:999px; background:#1a1f37; border:1px solid var(--panel-border); color:#c8cde0; font-size:14px; white-space:nowrap }
  .timer{ font-size:26px; font-weight:700 }
  .grid{
    margin-top:18px; display:grid; grid-template-columns:repeat(var(--cols), minmax(0,1fr));
    gap:var(--gap); padding:18px; background:linear-gradient(180deg,var(--grid-1),var(--grid-2));
    border:1px solid var(--grid-border); border-radius:24px; box-shadow:var(--shadow);
  }
  .card{
    position:relative; aspect-ratio:1/1; perspective:900px;
    cursor:pointer; border-radius:var(--radius); -webkit-tap-highlight-color:transparent; touch-action:manipulation;
    container-type: inline-size;
  }
  .face{
    position:absolute; inset:0; display:grid; place-items:center; border-radius:var(--radius); border:1px solid var(--card-border);
    backface-visibility:hidden;
    pointer-events:none; /* unita qui */
  }
  .front{ background:var(--card-front); transform:rotateY(180deg) }
  .back{ background:var(--card-back) }
  .back::before{
    content:""; position:absolute; inset:10px; border-radius:12px;
    background:
      linear-gradient(45deg,
        var(--card-pattern) 0 12%,
        transparent 12% 25%,
        var(--card-pattern) 25% 37%,
        transparent 37% 50%,
        var(--card-pattern) 50% 62%,
        transparent 62% 75%,
        var(--card-pattern) 75% 87%,
        transparent 87% 100%
      );
    opacity:.35;
  }
  .inner{
    position:absolute; inset:0; border-radius:var(--radius);
    transform-style:preserve-3d; transition: transform var(--flip-ms) cubic-bezier(.2,.7,.1,1);
    box-shadow: 0 12px 24px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.03);
  }
  .card[data-state="revealed"] .inner,
  .card[data-state="matched"] .inner{ transform:rotateY(180deg) }
  .symbol{
    font-size: clamp(28px, 50cqi, 86px);
    line-height: 1;
    filter: drop-shadow(0 4px 10px rgba(0,0,0,.45));
  }
  .card[data-state="matched"] .front{ outline:3px solid var(--ok); box-shadow:0 0 18px rgba(82,206,137,.45) inset }
  .card[data-state="locked"]{ pointer-events:none }

  /* Placeholder per slot vuoto nei livelli senza angoli */
  .card.placeholder{
    background:transparent;
    border:none;
    box-shadow:none;
    pointer-events:none;
  }

  /* Special effects for 💀 e ⚡ */
  .card[data-symbol="💀"] .front .symbol{ text-shadow: 0 0 10px rgba(244,96,108,.6) }
  .card[data-symbol="💀"][data-state="revealed"] .front{ outline:3px solid var(--bad); box-shadow:0 0 22px rgba(244,96,108,.45) inset }
  .card[data-symbol="⚡"] .front .symbol{ text-shadow: 0 0 10px rgba(255,213,79,.6) }
  .card[data-symbol="⚡"][data-state="revealed"] .front{ outline:3px solid #ffd54f; box-shadow:0 0 22px rgba(255,213,79,.4) inset }

  .flash-msg{
    position:fixed;
    top:20%;
    left:50%;
    transform:translateX(-50%);
    background:rgba(0,0,0,.8);
    color:#fff;
    padding:12px 20px;
    border-radius:12px;
    font-weight:700;
    font-size:1.3em;
    z-index:9999;
    pointer-events:none;
    animation:flashUp 1.5s ease forwards;
  }
  /* Stelline match */
  .match-stars { 
    position: absolute; inset: 0; pointer-events: none; 
    display: grid; place-items: center; 
  }
  .match-stars .star {
    position: absolute;
    font-size: 18px;
    opacity: 0;
    animation: starPop 600ms ease-out forwards;
    will-change: transform, opacity;
    filter: drop-shadow(0 6px 10px rgba(0,0,0,.35));
  }
  @keyframes starPop {
    0%   { transform: translate(0,0) scale(.4) rotate(0deg);   opacity: 0; }
    20%  { opacity: 1; }
    100% { transform: translate(var(--dx), var(--dy)) scale(1.2) rotate(35deg); opacity: 0; }
  }
  /* Anellino “pulse” sulla carta matched */
  .card[data-state="matched"] .front { animation: ringPulse 420ms ease-out; }
  @keyframes ringPulse {
    0%   { box-shadow: 0 0 0 0 rgba(82,206,137,.45) inset; }
    100% { box-shadow: 0 0 18px rgba(82,206,137,.45) inset; }
  }

  /* Accessibilità: niente animazioni se l’utente le riduce */
  @media (prefers-reduced-motion: reduce){
    .match-stars .star, .card[data-state="matched"] .front { animation: none !important; }
  }

  @keyframes flashUp{
    0%{opacity:0; transform:translate(-50%, 8px)}
    15%{opacity:1; transform:translate(-50%, 0)}
    100%{opacity:0; transform:translate(-50%, -8px)}
  }

  /* Overlay unificato */
  .overlay{
    position:fixed;
    inset:0;
    display:none;
    place-items:center;
    background: rgba(10,12,22,.45);
    -webkit-backdrop-filter: blur(10px) saturate(110%);
    backdrop-filter: blur(10px) saturate(110%);
    z-index:1000;
  }
  .overlay.show{ display:grid }

  .dialog{ width:min(640px, 92vw); background:linear-gradient(180deg,var(--panel-1),var(--panel-2)); border:1px solid var(--panel-border);
    border-radius:20px; padding:24px; text-align:center; box-shadow:var(--shadow) }
  .dialog h2{ margin:6px 0 8px; font-size:28px }
  .dialog p{ margin:0 0 14px; color:var(--muted) }

  @media (max-width: 600px){
    .wrap{ width:min(520px, 96vw) }
    .top, .grid{ width:100% }
  }

  /* Disabilita il flip animato quando vogliamo richiudere le carte di colpo */
  .no-flip .inner { transition: none !important; }
  .simon-ghost { z-index: 30; }

  /* Quando è attivo il Simon, impedisci ogni flip e nascondi la faccia front */
  body.mode-simon .card .inner{ transform: none !important; transition: none !important; }
  body.mode-simon .card .front{ visibility: hidden !important; }

  /* Pulsanti Pausa, Salva, Ricomincia in versione outline */
  .outline-btn { background: transparent !important; color: var(--accent) !important; border: 2px solid var(--accent) !important; }
  .outline-btn:hover { background: rgba(255, 255, 255, 0.05); }
  .outline-btn:active { background: rgba(255, 255, 255, 0.12); }

  /* Splash pre-tutorial */
  .splash{
    position: fixed;
    inset: 0;
    z-index: 2000;
    display: grid;
    place-items: center;
    background: linear-gradient(180deg, var(--bg-1), var(--bg-2));
    transition: opacity 280ms ease, visibility 280ms ease;
    opacity: 1;
    visibility: visible;
    cursor: pointer;
  }
  .splash.hide{ opacity: 0; visibility: hidden; pointer-events: none; }
  .splash .splash-art{
    width: min(70vmin, 900px);
    max-width: 92vw;
    height: auto;
    filter: drop-shadow(0 24px 50px rgba(0,0,0,.45));
  }
  .splash .splash-skip{
    position: absolute;
    bottom: 28px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0,0,0,.35);
    border: 1px solid var(--panel-border);
    color: var(--muted);
    padding: 8px 12px;
    border-radius: 999px;
    font-size: 14px;
    user-select: none;
  }

  /* Tutorial a slide */
  .tutorial-dialog{ position:relative; overflow:hidden; }
  .tutorial-carousel{ position:relative; min-height: 140px; }
  .tutorial-slide[hidden]{ display:none !important; }

  .tutorial-arrow{
    position:absolute;
    bottom: 20px;
    width:38px; height:38px;
    display:grid; place-items:center;
    border-radius:999px;
    border:1px solid var(--panel-border);
    background:linear-gradient(180deg, var(--panel-1), var(--panel-2));
    color:var(--text);
    cursor:pointer;
    box-shadow: var(--shadow);
    user-select:none;
  }
  .tutorial-arrow.prev{ left:10px; }
  .tutorial-arrow.next{ right:10px; }
  .tutorial-arrow:disabled{ opacity:.5; cursor:default; }

  .tutorial-dots{
    display:flex; gap:8px; justify-content:center; align-items:center;
    margin-top:12px;
  }
  .tutorial-dots button{
    width:8px; height:8px; border-radius:999px; border:none;
    background:#3a4168; cursor:pointer;
  }
  .tutorial-dots button[aria-current="true"]{
    width:22px; height:8px; border-radius:999px; background:var(--accent);
  }

  .big-symbol{
    font-size: clamp(42px, 10vw, 72px);
    line-height: 1;
    filter: drop-shadow(0 6px 16px rgba(0,0,0,.35));
  }

  /* X in alto a destra */
  .tutorial-close{
    position:absolute; top:10px; right:10px;
    width:34px; height:34px; display:grid; place-items:center;
    border-radius:10px;
    border:1px solid var(--panel-border);
    background:linear-gradient(180deg, var(--panel-1), var(--panel-2));
    color:var(--muted);
    cursor:pointer;
  }

  /* --- Testo centrato e niente pallini nelle slide del tutorial --- */
  #intro .tutorial-slide { text-align: center; }
  #intro .tutorial-slide ul { list-style: none; padding: 0; margin: 10px 0 0; }
  #intro .tutorial-slide li { margin: 8px 0; }
  #intro .tutorial-slide h3{ margin: 6px 0 10px; font-size: 22px; }

  /* Close del popup Salvataggi (stile coerente col tutorial) */
  .save-close{
    position:absolute; top:10px; right:10px;
    width:34px; height:34px; display:grid; place-items:center;
    border-radius:10px;
    border:1px solid var(--panel-border);
    background:linear-gradient(180deg,var(--panel-1),var(--panel-2));
    color:var(--muted);
    cursor:pointer;
  }

  /* Bottoni icona (Upload, Cestino) */
  .icon-btn{
    width:36px; height:36px;
    display:grid; place-items:center;
    border-radius:10px;
    border:1px solid var(--panel-border);
    background:linear-gradient(180deg,var(--panel-1),var(--panel-2));
    color:var(--text);
    cursor:pointer;
    box-shadow:var(--shadow);
    font-size:18px; line-height:1;
  }
  .icon-btn:hover{ filter:brightness(1.05) }
  .icon-btn:active{ transform:translateY(1px) }

  /* --- SIMON (flash del fantasmino) --- */
  .simon-ghost{
    position:absolute; inset:0;
    display:grid; place-items:center;
    font-size: clamp(36px, 50cqi, 90px);
    border:2px solid var(--accent);
    border-radius: var(--radius);
    background: rgba(255,255,255,.05);
    animation: simonFlash .55s ease-out;
    filter: drop-shadow(0 10px 24px rgba(0,0,0,.35));
    pointer-events: none;
    backface-visibility: hidden;
    transform: translateZ(0);
    will-change: transform, opacity;
  }
  @keyframes simonFlash{
    0%{ opacity:.15; transform:scale(.92) }
    50%{ opacity:1; transform:scale(1.02) }
    100%{ opacity:0; transform:scale(1) }
  }
  .no-flip .card[data-state="hidden"] .front { visibility: hidden; }

  /* --- Poteri: stile dedicato --- */
  .controls-right .power-btn{
    width: 46px; height: 46px;
    padding: 0;
    border-radius: 999px;
    display: grid; place-items: center;
    border: 2px solid var(--accent);
    background: linear-gradient(180deg, var(--panel-1), var(--panel-2));
    box-shadow: var(--shadow);
    font-size: 20px;
    transition:
      filter .18s ease, opacity .18s ease,
      transform .12s ease, box-shadow .18s ease, border-color .18s ease;
  }
  .controls-right .power-btn:not(:disabled):hover{
    transform: translateY(-1px);
    box-shadow: 0 14px 28px rgba(0,0,0,.45);
  }
  .controls-right .power-btn:not(:disabled):active{ transform: translateY(0); }

  /* Stato “pronto” (abilitato): leggero bagliore/pulse */
  @keyframes powerPulse {
    0%   { box-shadow: 0 0 0 0 rgba(116,132,255,.25); }
    70%  { box-shadow: 0 0 0 8px rgba(116,132,255,0); }
    100% { box-shadow: 0 0 0 0 rgba(116,132,255,0); }
  }
  .controls-right .power-btn.ready{ animation: powerPulse 1.2s ease-out infinite; }
  #powerReveal.ready { border-color: #ffd54f; }
  #powerPlus10.ready { border-color: #60e8a8; }
  #powerShift.ready  { border-color: #ff7aa2; }
</style>
</head>
<body class="theme-1">
<!-- ⬇️ AGGIUNGI QUESTA RIGA PRIMA DEL TUO <script> PRINCIPALE -->
<script src="sfx.js?v=6"></script>
<div class="wrap">
  <div class="top">
    <div class="brand">
      <img src="skullory-logo.svg" alt="Skullory">
    </div>
    <div class="stats-container">
      <div class="stats">
        <span class="level-chip" id="levelChip">Livello: —</span>
        <span class="level-chip" id="statusChip">Stato: —</span>
        <span class="level-chip" id="moves" aria-live="polite">Mosse: 0</span>
        <span class="chip timer" id="timer" aria-live="polite">0:30</span>
        <span class="chip" id="score" aria-live="polite" style="color:#FFF44F">Punti: 0</span>
      </div>
    </div>

    <div class="grid" id="grid" aria-label="Griglia Skullory"></div>

    <div class="controls controls-bottom">
      <div class="controls-left">
        <button class="primary outline-btn" id="pause">⏸️</button>
        <button class="primary outline-btn" id="save">💾</button>
        <button class="primary outline-btn" id="restart">🔄</button>
        <button class="primary outline-btn" id="audioCycle" title="Audio">🎵</button>
      </div>

      <div class="controls-right">
        <button class="primary outline-btn power-btn" id="powerReveal"
          title="👁️ Svela per 1s (−20% tempo, min −4s, non sotto 3s) · 1×">👁️</button>
        <button class="primary outline-btn power-btn" id="powerPlus10"
          title="🦇 +10s (sacrifica 1 coppia a caso, rilocalizzata) · 1×">🦇</button>
        <button class="primary outline-btn power-btn" id="powerShift"
          title="🌀 Sposta 💀 e ⚡, rimescola (come ⚡), +15s · 1×">🌀</button>
      </div>
    </div>

    <!-- Intro / Tutorial (carousel a 3 slide) -->
    <div class="overlay hide" id="intro">
      <div class="dialog tutorial-dialog">
        <button class="tutorial-close" id="intro-close" aria-label="Chiudi tutorial">✕</button>
        <h2 id="intro-title" style="margin-bottom:8px">Come si gioca</h2>

        <div class="tutorial-carousel" aria-live="polite">
          <!-- Slide 0 (scelta modalità) -->
          <div class="tutorial-slide" data-mode="root">
            <h3 style="color:#FFF44F">Scegli modalità</h3>
            <div style="display:flex; gap:12px; justify-content:center; margin-top:12px; flex-wrap:wrap">
              <button class="primary" id="intro-arcade">🎮 Gioca (Arcade)</button>
              <button class="primary outline-btn" id="intro-zen">🧘 Allenati (Zen 5×5)</button>
            </div>
            <p style="color:var(--muted); margin-top:10px">
              Arcade: tempo, bonus, carte speciali e poteri.<br/>
              Zen: nessun timer, solo te e la memoria. Riepilogo finale.
            </p>
          </div>

          <!-- Slide 1 -->
          <div class="tutorial-slide" data-mode="arcade">
            <h3 style="color:#FFF44F">Obiettivo</h3>
            <ul>
              <li>Trova tutte le <b>coppie</b> ribaltando le carte, ma <b>occhio al tempo!</b></li>
              <li><b>Sblocco livello</b>: completa lo stesso livello <b>3 volte di fila</b>!</li>
              <li>Dopo lo sblocco resti sul livello <b>per fare punti</b>.</li>
              <li><b>Al primo errore</b>, sali al livello successivo.</li>
            </ul>
          </div>

          <!-- Slide 2 -->
          <div class="tutorial-slide" data-mode="arcade" hidden>
            <h3 style="color:#FFF44F">Carte speciali</h3>
            <div style="display:flex; gap:18px; align-items:center; justify-content:center; margin:10px 0 6px">
              <div class="big-symbol" aria-hidden="true">⚡</div>
              <div class="big-symbol" aria-hidden="true">💀</div>
            </div>
            <ul>
              <li>⚡ rimescola tutte le carte coperte (tranne 💀 e ⚡).</li>
              <li>💀 se rivelato due volte: <b>sconfitta!</b></li>
            </ul>
          </div>

          <!-- Slide 3 -->
          <div class="tutorial-slide" data-mode="arcade" hidden>
            <h3 style="color:#FFF44F">Bonus, penalità e punteggio</h3>
            <ul>
              <li><b>Bonus 1</b>: ogni coppia trovata = <b>+1s</b></li>
              <li><b>Bonus 2</b>: 2 coppie di fila entro 5s = <b>+5s</b></li>
              <li><b>Penalità</b>: ogni errore <b>−1s</b></li>
              <li><b>Punteggio</b>: secondi risparmiati <b>x</b> efficienza mosse.</li>
            </ul>
          </div>

          <!-- Slide Zen -->
          <div class="tutorial-slide" data-mode="zen" hidden>
            <h3 style="color:#FFF44F">Modalità Zen 🧘</h3>
            <ul>
              <li>Nessun timer, nessun punteggio a schermo.</li>
              <li>Giochi tranquillo: niente poteri, niente carte speciali.</li>
              <li>Alla fine vedi il report: <b>tempo impiegato</b>, <b>mosse</b>, <b>efficienza</b> e ⭐.</li>
            </ul>
          </div>
        </div>

        <button class="tutorial-arrow prev" id="intro-prev" aria-label="Slide precedente">‹</button>
        <button class="tutorial-arrow next" id="intro-next" aria-label="Slide successiva">›</button>

        <div class="tutorial-dots" id="intro-dots" role="tablist" aria-label="Pagine tutorial"></div>

        <div class="actions" style="margin-top:14px; display:flex; justify-content:center; gap:10px">
          <button class="primary" id="intro-play">Gioca</button>
        </div>
      </div>
    </div>

    <!-- Gestore Salvataggi (Modal) -->
    <!-- Conferma Ricomincia -->
    <div class="overlay" id="restartConfirm" aria-hidden="true">
      <div class="dialog">
        <h2>Vuoi ricominciare ?</h2>
        <p style="margin-top:4px; color:var(--muted)">Perderai lo stato del quadro corrente.</p>
        <div style="display:flex; gap:10px; justify-content:center; margin-top:8px">
          <button class="primary" id="restart-yes">Sì, ricomincia</button>
          <button class="primary" id="restart-no" style="background:var(--bad); color:#fff">Annulla</button>
        </div>
      </div>
    </div>

    <div class="overlay" id="saveModal" aria-hidden="true">
      <div class="dialog" style="text-align:left; position:relative">
        <button class="save-close" id="save-close" aria-label="Chiudi salvataggi">✕</button>
        <h2 style="text-align:center; margin-top:2px">Salvataggi</h2>
        <div id="saveList" style="max-height:46vh; overflow:auto; margin:8px 0 12px"></div>

        <div id="saveControls" style="display:flex; gap:8px; align-items:center; margin-top:6px">
          <input id="saveName" placeholder="Nome partita…"
            style="width:150px; padding:10px 12px; border-radius:10px;
                   border:1px solid var(--panel-border); background:var(--panel-2);
                   color:var(--text)"/>
          <button class="primary" id="doSave">Salva</button>
        </div>

        <p style="color:var(--muted); margin-top:10px">
          I salvataggi sono consentiti <b>solo a fine quadro</b> o <b>prima di iniziare</b> il prossimo.
        </p>
      </div>
    </div>

    <!-- Overlay di fine quadro -->
    <div class="overlay" id="overlay">
      <div class="dialog">
        <h2 id="ov-title">Hai vinto!</h2>
        <p id="ov-sub">Tempo rimasto: —</p>

        <div class="ov-actions" style="display:flex;gap:10px;justify-content:center;flex-wrap:wrap">
          <button class="primary" id="ov-btn">Continua</button>
          <button class="primary outline-btn" id="ov-btn-skip" style="display:none">Salta</button>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  const RED = '💀';
  const YELLOW = '⚡';
// Durate identiche a quelle già percepite (mismatch ~420ms)
const MISMATCH_HOLD_MS = 420;
const MATCH_HOLD_MS = 120; // per coerenza (non serve bloccare l’input)

  // --- SIMON: manopole per le durate ---
  const SIMON_CFG = {
    previewMs: 700,
    gapMs: 140,
    inputRevealMs: 520,
    wrongHoldMs: 850,
    startLen: 3
  };

  const GHOST = '👻';
  let sim = null;
  let modeZen = false;

  const STORAGE_KEY = 'skullory_save_v1';
  const SAVES_KEY = 'skullory_saves_v2';

  const LEVELS = [
    { name: '3×3 (no centro)', side: 3, disabled: [4], pairs: 3, red: 0, yellow: 2, timeMs: 20000, unlockMs: [20000, 15000, 10000], postDeltaSec: 1 },
    { name: '3×3', side: 3, disabled: [], pairs: 4, red: 1, yellow: 0, timeMs: 40000, unlockMs: [40000, 35000, 30000], postDeltaSec: 2 },
    { name: '4×4 (–angoli)', side: 4, disabled: [0,3,12,15], pairs: 5, red: 1, yellow: 1, timeMs: 45000, unlockMs: [45000, 40000, 35000], postDeltaSec: 2 },
    { name: '4×4', side: 4, disabled: [], pairs: 7, red: 1, yellow: 1, timeMs: 60000, unlockMs: [60000, 55000, 50000], postDeltaSec: 2 },
    { name: '5×5 (caotico simm.)', side: 5, disabled: [1,3,5,9,12,15,19,21,23], pairs: 6, red: 1, yellow: 3, timeMs: 65000, unlockMs: [65000, 60000, 55000], postDeltaSec: 3 },
    { name: '5×5 (cornice)', side: 5, disabled: [0,4,12,20,24], pairs: 9, red: 1, yellow: 1, timeMs: 70000, unlockMs: [70000, 65000, 60000], postDeltaSec: 3 },
    { name: '5×5 (–angoli)', side: 5, disabled: [0,4,20,24], pairs: 9, red: 1, yellow: 2, timeMs: 70000, unlockMs: [70000, 65000, 60000], postDeltaSec: 3 },
    { name: '5×5', side: 5, disabled: [], pairs: 11, red: 1, yellow: 2, timeMs: 80000, unlockMs: [80000, 75000, 70000], postDeltaSec: 3 },
    { name: '6×6 (croce)', side: 6, disabled: [0,1,4,5,6,11,24,29,30,31,34,35], pairs: 10, red: 1, yellow: 3, timeMs: 90000, unlockMs: [90000, 85000, 80000], postDeltaSec: 3 },
    { name: '6×6 (cornici+centro)', side: 6, disabled: [0, 5, 30, 35, 14, 15, 20, 21], pairs: 12, red: 1, yellow: 3, timeMs: 112000, unlockMs: [112000, 108000, 104000], postDeltaSec: 4 },
    { name: '6×6 (–angoli)', side: 6, disabled: [0,5,30,35], pairs: 14, red: 1, yellow: 3, timeMs: 95000, unlockMs: [95000, 90000, 85000], postDeltaSec: 3 },
    { name: '6×6', side: 6, disabled: [], pairs: 16, red: 1, yellow: 3, timeMs: 100000, unlockMs: [100000, 95000, 90000], postDeltaSec: 3 }
  ];

  const EMOJI = ['🐶','🐱','🦊','🐼','🐵','🐯','🦁','🐸','🐨','🦄','🐷','🐹','🐙','🦉','🦋','🐝','🐢','🐠','🍎','🍉','🍇','🍒','🍓','🍑','🥑','🌽','🥕','🍩','🍪','🍰','🍔','🍕','🍣','🍤','🍜','🍿','🐋','🦭','🦀','🐞','🐍','🦜','🦢','🐎','🐫','🦒','🐿','🦔','🦩','🐬','🐳','🦦','🐡','🐌','🍋','🍊','🫐','🥥','🥭','🥒','🫑','🥔','🌶','🍄','🧄','🧅','🧀','🥨','🥯','🥞','🥪','🥙','🥗','🥘','🥟','🍮','🍫','🍹','🧋','🍺','☕','🥛','🍷','🍵'];

const GAME_URL = 'https://dadegames.github.io/Skullory/';

  // --- SFX: inizializza al primo gesto utente ---
  function ensureSfx(){
    if (window.__sfxReady) return;
    window.__sfxReady = true;

    try {
      SFX.init();

      if (window.BGM){
        BGM._markInteracted();
        BGM.start();
        BGM.updateUi?.();
      }

      if (!SFX.__wrapped){
        const origPlay = SFX.play.bind(SFX);
        SFX.play = (name, opts = {}) => {
          if (name === 'bgm') {
            if (musicMuted) return null;
            if (opts.volume == null) opts.volume = 0.18;
            opts.loop = (opts.loop !== false);
          } else {
            if (sfxMuted) return null;
          }
          return origPlay(name, opts);
        };
        SFX.__wrapped = true;
      }

      setMusicMuted(musicMuted);
      setSfxMuted(sfxMuted);
      refreshAudioButtons();

    } catch(e){
      window.__sfxReady = false;
    }
  }

  function setMusicMuted(v){
    musicMuted = !!v;
    localStorage.setItem('skullory.musicMuted', JSON.stringify(musicMuted));

    if (window.BGM) {
      if (musicMuted) {
        try { BGM.setEnabled(false); } catch(_) {}
        try { BGM.stop(); } catch(_) {}
      } else {
        try { BGM.setEnabled(true); } catch(_) {}
        try { BGM.start(); } catch(_) {}
      }
    }
    refreshAudioButtons();
  }

  function setSfxMuted(v){
    sfxMuted = !!v;
    localStorage.setItem('skullory.sfxMuted', JSON.stringify(sfxMuted));
    if (window.SFX && SFX.setSfxMuted) SFX.setSfxMuted(sfxMuted);
    refreshAudioButtons();
  }

  // 0 = musica+SFX, 1 = solo SFX, 2 = tutto OFF
  function getAudioMode(){
    if (!musicMuted && !sfxMuted) return 0;
    if (musicMuted && !sfxMuted)  return 1;
    return 2;
  }
  function setAudioMode(mode){
    if (mode === 0){ setMusicMuted(false); setSfxMuted(false); }
    else if (mode === 1){ setMusicMuted(true); setSfxMuted(false); }
    else { setMusicMuted(true); setSfxMuted(true); }
  }
  function cycleAudioMode(){
    const next = (getAudioMode() + 1) % 3;
    setAudioMode(next);
    if (next === 0)      flashMessage('Audio: musica + effetti');
    else if (next === 1) flashMessage('Audio: solo effetti');
    else                 flashMessage('Audio: spento');
    refreshAudioButtons();
  }

  const grid = document.getElementById('grid');
  const movesEl = document.getElementById('moves');
  const timerEl = document.getElementById('timer');
  const restartBtn = document.getElementById('restart');
  const overlay = document.getElementById('overlay');
  const ovTitle = document.getElementById('ov-title');
  const ovSub = document.getElementById('ov-sub');
  const ovBtn = document.getElementById('ov-btn');
  const ovBtnSkip = document.getElementById('ov-btn-skip');
  function showSkip(v){ if (ovBtnSkip) ovBtnSkip.style.display = v ? '' : 'none'; }
  const pauseBtn = document.getElementById('pause');
  const saveBtn = document.getElementById('save');
  const levelChip = document.getElementById('levelChip');
  const statusChip = document.getElementById('statusChip');
  const scoreChip = document.getElementById('score');

  const powerRevealBtn = document.getElementById('powerReveal');
  const powerPlus10Btn = document.getElementById('powerPlus10');
  const powerShiftBtn  = document.getElementById('powerShift');

  // 🔊 Bottone unico audio (🎵 → 🔊 → 🔇)
  const audioBtn = document.getElementById('audioCycle');
  if (audioBtn) {
    audioBtn.addEventListener('click', () => {
      ensureSfx();
      cycleAudioMode();
    });
  }

  let musicMuted = JSON.parse(localStorage.getItem('skullory.musicMuted') || 'false');
  let sfxMuted   = JSON.parse(localStorage.getItem('skullory.sfxMuted')   || 'false');
  refreshAudioButtons();

  const restartConfirm = document.getElementById('restartConfirm');
  const restartYes = document.getElementById('restart-yes');
  const restartNo = document.getElementById('restart-no');

  const saveModal = document.getElementById('saveModal');
  const saveList = document.getElementById('saveList');
  const saveNameInput = document.getElementById('saveName');
  const doSaveBtn = document.getElementById('doSave');
  const saveClose = document.getElementById('save-close');

  const intro = document.getElementById('intro');
  const introBtn = document.getElementById('intro-play');

  // ===== TUTORIAL =====
  let currentSlide = 0;
  const slides = [];
  let dotsWrap, prevBtn, nextBtn, closeBtn;
  let allSlides = [];
  let tutorialMode = 'root';

  function rebuildDots(){
    dotsWrap.innerHTML = '';
    slides.length = 0;
    const active = allSlides.filter(s => s.dataset.mode === tutorialMode);
    active.forEach(s => slides.push(s));

    allSlides.forEach(s => s.setAttribute('hidden',''));
    slides.forEach(s => s.removeAttribute('hidden'));

    slides.forEach((_, i) => {
      const d = document.createElement('button');
      d.setAttribute('aria-label', `Vai alla slide ${i+1}`);
      d.addEventListener('click', () => goToSlide(i));
      dotsWrap.appendChild(d);
    });

    const multi = slides.length > 1;
    if (prevBtn)  prevBtn.style.display  = multi ? '' : 'none';
    if (nextBtn)  nextBtn.style.display  = multi ? '' : 'none';
    if (dotsWrap) dotsWrap.style.display = multi ? '' : 'none';
  }

  function setTutorialMode(mode){
    tutorialMode = mode;
    rebuildDots();
    goToSlide(0);

    const introTitle = document.getElementById('intro-title');
    if (introTitle){
      if (mode === 'root') {
        introTitle.style.display = 'none';
      } else {
        introTitle.style.display = '';
        introTitle.textContent =
          mode === 'arcade' ? 'Come si gioca (Arcade)' :
          mode === 'zen'    ? 'Allenamento Zen' :
                              '';
      }
    }

    if (introBtn){
      if (mode === 'arcade'){
        introBtn.textContent = 'Gioca (Arcade)';
        introBtn.onclick = () => { ensureSfx(); modeZen = false; currentLevelIdx = 0; hideIntro(); startArcade(); };
        introBtn.style.display = '';
      } else if (mode === 'zen'){
        introBtn.textContent = 'Allenati (Zen 5×5)';
        introBtn.onclick = () => { ensureSfx(); modeZen = true; hideIntro(); startZen(); };
        introBtn.style.display = '';
      } else {
        introBtn.textContent = 'Gioca';
        introBtn.onclick = () => {};
        introBtn.style.display = 'none';
      }
    }
  }

  function buildTutorialRefs(){
    dotsWrap = document.getElementById('intro-dots');
    prevBtn  = document.getElementById('intro-prev');
    nextBtn  = document.getElementById('intro-next');
    closeBtn = document.getElementById('intro-close');

    allSlides = Array.from(document.querySelectorAll('#intro .tutorial-slide'));

    prevBtn.addEventListener('click', () => goToSlide(currentSlide - 1));
    nextBtn.addEventListener('click', () => goToSlide(currentSlide + 1));

    closeBtn.addEventListener('click', () => hideIntro());

    document.addEventListener('keydown', (e) => {
      if (intro.classList.contains('hide')) return;
      if (e.key === 'ArrowLeft')  goToSlide(currentSlide - 1);
      if (e.key === 'ArrowRight') goToSlide(currentSlide + 1);
    });

    const btnArcade = document.getElementById('intro-arcade');
    const btnZen    = document.getElementById('intro-zen');
    if (btnArcade) btnArcade.addEventListener('click', () => setTutorialMode('arcade'));
    if (btnZen)    btnZen.addEventListener('click',    () => setTutorialMode('zen'));

    setTutorialMode('root');
  }

  function goToSlide(i){
    currentSlide = Math.max(0, Math.min(slides.length - 1, i));
    slides.forEach((el, idx) => {
      if (idx === currentSlide) el.removeAttribute('hidden');
      else el.setAttribute('hidden', '');
    });

    Array.from(dotsWrap.children).forEach((dot, idx) => {
      dot.setAttribute('aria-current', idx === currentSlide ? 'true' : 'false');
    });

    prevBtn.disabled = (currentSlide === 0);
    nextBtn.disabled = (currentSlide === slides.length - 1);
  }

  function showIntro(){
    intro.classList.remove('hide');
    intro.classList.add('show');
    if (slides.length === 0) buildTutorialRefs();
    setTutorialMode('root');
  }
  function hideIntro(){ intro.classList.add('hide'); intro.classList.remove('show'); }

  let state;
  let currentLevelIdx = 0;
  let totalScore = 0;
  let themeIndex = 1;
  let frameBaseScore = 0;
  let activeSaveName = localStorage.getItem('skullory_active_save') || '';

  function setActiveSaveName(name){
    activeSaveName = name || '';
    try {
      if (activeSaveName) localStorage.setItem('skullory_active_save', activeSaveName);
      else localStorage.removeItem('skullory_active_save');
    } catch(_) {}
  }

  function refreshAudioButtons(){
    // NUOVO: bottone unico ciclico
    if (typeof getAudioMode === 'function' && audioBtn){
      const mode = getAudioMode(); // 0=tutto ON, 1=solo SFX, 2=tutto OFF

      if (mode === 0){
        audioBtn.textContent = '🎵';
        audioBtn.title = 'Audio: musica + effetti';
        audioBtn.setAttribute('aria-label','Audio: musica + effetti');
      } else if (mode === 1){
        audioBtn.textContent = '🔊';
        audioBtn.title = 'Audio: solo effetti (musica OFF)';
        audioBtn.setAttribute('aria-label','Audio: solo effetti (musica OFF)');
      } else {
        audioBtn.textContent = '🔇';
        audioBtn.title = 'Audio: spento';
        audioBtn.setAttribute('aria-label','Audio: spento');
      }
    }
  }

  let pendingCheck = null;
  let tapBuffer = [];
  const TAP_BUFFER_MAX = 2;
  let progress = LEVELS.map(L => ({
    streak: 0,
    unlocked: false,
    baseTimeMs: L.unlockMs[0],
    postUnlockWins: 0,
    carryBonusMs: 0
  }));

  function setCols(n){ document.documentElement.style.setProperty('--cols', n); }
  function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } return a; }
  function fmt(ms){ const s = Math.max(0, Math.floor(ms/1000)); const mm = Math.floor(s/60), ss = s%60; return `${mm}:${ss.toString().padStart(2,'0')}`; }
  function calcElapsedMs(){
    const now = performance.now();
    return Math.max(0, now - (state.frameStartTs || now));
  }
  function calcZenEfficiency(moves, level){
    const free = freeMovesFor(level);
    if (moves <= free) return 100;
    const over = moves - free;
    return Math.max(50, Math.round(100 - over));
  }
// Da % efficienza a numero stelle (1..5)
function effToStars(eff){
  // Soglie consigliate (tienile pure come vuoi):
  // 96–100 => 5 ⭐, 90–95 => 4 ⭐, 80–89 => 3 ⭐, 70–79 => 2 ⭐, <70 => 1 ⭐
  if (eff >= 96) return 5;
  if (eff >= 90) return 4;
  if (eff >= 80) return 3;
  if (eff >= 70) return 2;
  return 1;
}

// Etichetta testuale carina per il rating
function starsLabel(n){
  return (
    n === 5 ? 'Eccellente! (5/5)' :
    n === 4 ? 'Ottimo! (4/5)' :
    n === 3 ? 'Buono! (3/5)' :
    n === 2 ? 'Discreto (2/5)' :
              'Da ritentare (1/5)'
  );
}

  function markFrameStart(){ state.frameStartTs = performance.now(); }

  function rotateTheme(){
    themeIndex = themeIndex % 10 + 1;
    const b = document.body;
    b.className = (b.className || '').replace(/\btheme-\d+\b/g, '').trim();
    b.classList.add('theme-' + themeIndex);
  }

  function updateStatusChip(){
    const p = progress[currentLevelIdx];
    const extra = !p.unlocked ? (p.carryBonusMs || 0) : 0;
    const baseSec = Math.max(0, p.baseTimeMs + extra) / 1000 | 0;
    if(!p.unlocked){
      statusChip.textContent = `Sbloc ${p.streak}/3 · ${baseSec}s`;
    } else {
      statusChip.textContent = `Grind ${p.postUnlockWins} · ${baseSec}s`;
    }
  }

  function buildDeck(level){
    const pool = EMOJI.slice();
    const unique = shuffle(pool).slice(0, level.pairs);
    const pairs = unique.concat(unique);
    const specials = [ ...Array(level.red).fill(RED), ...Array(level.yellow).fill(YELLOW) ];
    const deck = pairs.concat(specials);
    return shuffle(deck);
  }
  function getActiveCards(){
    return Array.from(grid.querySelectorAll('.card'))
      .filter(c => !c.classList.contains('placeholder'));
  }
  function getCardByIndex(idx){ return grid.querySelector(`.card[data-index="${idx}"]`); }

  // --- MOSSE & PUNTEGGIO ---
  function freeMovesFor(level){ return level.side * level.side; }
  function efficiencyMultiplier(moves, free){
    const delta = moves - free;
    if (delta <= 0){
      const bonus = Math.min(0.30, 0.02 * (-delta));
      return 1 + bonus;
    } else {
      return Math.max(0.5, 1 - 0.05 * delta);
    }
  }
  function roundNearest(n){ return Math.round(n); }
  function updateScoreChip(){ if(scoreChip) scoreChip.textContent = `Punti: ${totalScore}`; }

  function canSaveNow(){
  if (state?.isZen) return false; 
    const endOfFrame = overlay.classList.contains('show');
    const freshStart = !state.running && state.moves === 0 && state.matched === 0;
    return endOfFrame || freshStart;
  }
function updateSaveButton(){
  if (!saveBtn) return;

  if (state?.isZen){
    // In modalità Zen non si salva mai
    saveBtn.disabled = true;
    saveBtn.style.opacity = '0.6';
    saveBtn.title = 'In Zen non si salva';
    return;
  }

  const ok = canSaveNow();
  saveBtn.disabled = !ok;
  saveBtn.style.opacity = ok ? '1' : '0.6';
  saveBtn.title = ok ? 'Salva' : 'Salva disponibile solo a fine quadro o prima di iniziare';
}

function isPreFrame(){
  return !!state && !state.running && state.moves === 0 && state.matched === 0;
}

  function anyOverlayOpen(){
    return overlay.classList.contains('show')
        || restartConfirm.classList.contains('show')
        || saveModal.classList.contains('show')
        || (intro && !intro.classList.contains('hide'));
  }

  function canUsePowersBase(){
    if (state?.isZen) return false;
    return !!state
        && state.running
        && !state.paused
        && !state.lock
        && !anyOverlayOpen()
        && !(sim && sim.active)
        && !document.body.classList.contains('mode-simon');
  }

  function addTimeMs(ms){
    if (state?.isZen) return;
    const now = performance.now();
    state.deadlineTs += ms;
    state.leftMs = Math.max(0, state.deadlineTs - now);
    updateTime();
  }
  function takeTimeMs(ms){ addTimeMs(-Math.max(0, ms)); }

  function refreshPowersUI(){
    if (!powerRevealBtn || !powerPlus10Btn || !powerShiftBtn) return;

    if (state?.isZen){
      [powerRevealBtn, powerPlus10Btn, powerShiftBtn].forEach(b => {
        if (!b) return;
        b.classList.remove('ready');
        b.setAttribute('aria-disabled','true');
      });
      return;
    }

    const base = canUsePowersBase();
    const haveOnePair = state.matched >= 1;
    const skullSeen = state.redFlips >= 1;

    const revealCost = Math.max(4000, Math.floor(state.leftMs * 0.20));
    const safeAfterReveal = (state.leftMs - revealCost) >= 3000;

    const canReveal = base && !state.powerUsed.reveal && haveOnePair && safeAfterReveal;
    const canPlus10 = base && !state.powerUsed.plus10 && haveOnePair;
    const canShift  = base && !state.powerUsed.shift  && skullSeen;

    setPowerState(powerRevealBtn, canReveal);
    setPowerState(powerPlus10Btn, canPlus10);
    setPowerState(powerShiftBtn,  canShift);
  }
  function setPowerState(btn, enabled){
    btn.classList.toggle('ready', !!enabled);
    btn.setAttribute('aria-disabled', String(!enabled));
  }

  function getHiddenNonSpecialCards(){
    return getActiveCards().filter(c =>
      c.getAttribute('data-state') === 'hidden' &&
      c.dataset.symbol !== RED && c.dataset.symbol !== YELLOW
    );
  }
  function getMatchedPairs(){
    const map = new Map();
    getActiveCards().forEach(c => {
      if (c.getAttribute('data-state') === 'matched'){
        const s = c.dataset.symbol;
        if (s === RED || s === YELLOW) return;
        if (!map.has(s)) map.set(s, []);
        map.get(s).push(c);
      }
    });
    return Array.from(map.entries()).filter(([_, arr]) => arr.length === 2);
  }

  function usePowerReveal(){
    const baseOk = canUsePowersBase();
    if (!baseOk || state.powerUsed.reveal || state.matched < 1){
      if (isPreFrame()) explainPower('reveal');
      return;
    }

    const cost = Math.max(4000, Math.floor(state.leftMs * 0.20));
    if ((state.leftMs - cost) < 3000) { refreshPowersUI(); return; }

    ensureSfx();
    state.powerUsed.reveal = true;
    takeTimeMs(cost);
    flashMessage(`👁️ Svela tutto (−${Math.ceil(cost/1000)}s)`);
    SFX.play?.('flip', { volume:.85 });

    const cards = getActiveCards();
    const prev = new Map(cards.map(c => [c, c.getAttribute('data-state')]));

    const prevLock = state.lock;
    state.lock = true;

    cards.forEach(c => c.setAttribute('data-state', 'revealed'));

    setTimeout(() => {
      cards.forEach(c => c.setAttribute('data-state', prev.get(c)));
      state.lock = prevLock;
      if (tapBuffer.length){
        const next = tapBuffer.shift();
        setTimeout(() => onCardClick(next), 0);
      }
      refreshPowersUI();
    }, 1000);
  }

  function usePowerPlus10(){
    const baseOk = canUsePowersBase();
    if (!baseOk || state.powerUsed.plus10 || state.matched < 1){
      if (isPreFrame()) explainPower('plus10');
      return;
    }

    const pairs = getMatchedPairs();
    if (!pairs.length){ refreshPowersUI(); return; }

    ensureSfx();
    state.powerUsed.plus10 = true;

    const [symSac, cardsSac] = pairs[(Math.random() * pairs.length) | 0];

    const pool = getHiddenNonSpecialCards();
    shuffle(pool);

    cardsSac.forEach(c => c.setAttribute('data-state','hidden'));
    state.matched = Math.max(0, state.matched - 1);

    if (pool.length >= 2){
      const t1 = pool[0], t2 = pool[1];
      const t1Sym = t1.dataset.symbol, t2Sym = t2.dataset.symbol;

      t1.dataset.symbol = symSac; t1.querySelector('.symbol').textContent = symSac;
      t2.dataset.symbol = symSac; t2.querySelector('.symbol').textContent = symSac;

      cardsSac[0].dataset.symbol = t1Sym; cardsSac[0].querySelector('.symbol').textContent = t1Sym;
      cardsSac[1].dataset.symbol = t2Sym; cardsSac[1].querySelector('.symbol').textContent = t2Sym;
    }
    addTimeMs(10000);
    flashMessage('+10s • Coppia annullata');
    SFX.play?.('bonus5', { volume:1.0 });

    refreshPowersUI();
  }

  function usePowerShift(){
    const baseOk = canUsePowersBase();
    if (!baseOk || state.powerUsed.shift || state.redFlips < 1){
      if (isPreFrame()) explainPower('shift');
      return;
    }

    ensureSfx();
    state.powerUsed.shift = true;

    const specials = getActiveCards().filter(c => c.dataset.symbol === RED || c.dataset.symbol === YELLOW);
    let pool = getHiddenNonSpecialCards();
    shuffle(pool);

    for (let i=0; i<specials.length && i<pool.length; i++){
      const s = specials[i];
      const t = pool[i];

      const tSym = t.dataset.symbol;
      const sSym = s.dataset.symbol;

      t.dataset.symbol = sSym; t.querySelector('.symbol').textContent = sSym;
      s.dataset.symbol = tSym; s.querySelector('.symbol').textContent = tSym;
    }

    reshuffleHiddenNonSpecial();

    state.redFlips = 0;

    addTimeMs(15000);
    flashMessage('🌀 Speciali spostate • +15s');
    SFX.play?.('reshuffle', { volume:.9 });

    refreshPowersUI();
  }

  function startArcade(){ init(currentLevelIdx || 0); }

  function startZen(){
    const idx5base = LEVELS.findIndex(L => L.side === 5 && (!L.disabled || L.disabled.length === 0));
    const idx5any  = LEVELS.findIndex(L => L.side === 5);
    const target   = (idx5base >= 0) ? idx5base : (idx5any >= 0 ? idx5any : 0);
    init(target);
  }

  function init(levelIdx = currentLevelIdx){
    rotateTheme();

    const L = LEVELS[levelIdx];
    currentLevelIdx = levelIdx;
    setCols(L.side);
    levelChip.textContent = `Livello: ${levelIdx+1}/${LEVELS.length}`;
    updateStatusChip();

    if (pendingCheck) { clearTimeout(pendingCheck); pendingCheck = null; }
    state = {
      level: L,
      deck: buildDeck(L),
      pivot: null, matched: 0, moves: 0,
hideTimers: new Map(),
      running: false, startTs: 0,
      leftMs: Math.max(0, progress[levelIdx].baseTimeMs + (!progress[levelIdx].unlocked ? (progress[levelIdx].carryBonusMs || 0) : 0)),
      lock: false,
      redFlips: 0, yellowFlips: 0,
      paused: false, streak: 0, lastMatchTime: 0, totalBonusMs: 0,
      deadlineTs: 0,
      pauseLeftMs: 0,
      powerUsed: { reveal:false, plus10:false, shift:false },
      preAppliedBonusMs: 0,
      startBonusMs: 0
    };

    // === UI: nascondi chip e poteri in Zen + CENTRA i 5 bottoni ===
    if (modeZen) {
      if (levelChip)  levelChip.style.display  = 'none';
      if (statusChip) statusChip.style.display = 'none';
      if (scoreChip)  scoreChip.style.display  = 'none';
      if (movesEl)    movesEl.style.display    = 'none';
      if (timerEl)    timerEl.style.display    = 'none';

      const cr = document.querySelector('.controls-right');
      if (cr) cr.style.display = 'none';

      const cb = document.querySelector('.controls-bottom');
      const cl = document.querySelector('.controls-left');
      if (cb) cb.style.justifyContent = 'center';
      if (cl) cl.style.margin = '0 auto';
if (saveBtn) saveBtn.style.display = 'none';
    } else {
      if (levelChip)  levelChip.style.display  = '';
      if (statusChip) statusChip.style.display = '';
      if (scoreChip)  scoreChip.style.display  = '';
      if (movesEl)    movesEl.style.display    = '';
      if (timerEl)    timerEl.style.display    = '';

      const cr = document.querySelector('.controls-right');
      if (cr) cr.style.display = '';

      const cb = document.querySelector('.controls-bottom');
      const cl = document.querySelector('.controls-left');
      if (cb) cb.style.justifyContent = 'space-between';
      if (cl) cl.style.margin = '';
if (saveBtn) saveBtn.style.display = '';
    }

    if (modeZen){
      if (timerEl){
        timerEl.textContent = '—';
        timerEl.style.opacity = .65;
      }
      state.isZen = true;
    } else {
      state.isZen = false;
    }

    updateSaveButton?.();
    refreshPowersUI?.();
    markFrameStart?.();

    grid.innerHTML = '';
    const frag = document.createDocumentFragment();

    const disabled = new Set((L.disabled || []).map(Number));
    let deckPtr = 0;

    for(let i=0;i<L.side*L.side;i++){
      if (disabled.has(i)){
        const placeholder = document.createElement('div');
        placeholder.className = 'card placeholder';
        placeholder.setAttribute('aria-hidden','true');
        frag.appendChild(placeholder);
        continue;
      }

      const symbol = state.deck[deckPtr++];
      const card = document.createElement('div');
      card.className = 'card';
      card.dataset.index = i;
      card.dataset.symbol = symbol;
      card.setAttribute('data-state','hidden');
      card.setAttribute('role','button');
      card.setAttribute('tabindex','0');
      card.setAttribute('aria-label','Carta di Slapmory');

      const inner = document.createElement('div'); inner.className = 'inner';
      const back  = document.createElement('div'); back.className  = 'face back';
      const front = document.createElement('div'); front.className = 'face front';
      const sym   = document.createElement('div'); sym.className   = 'symbol'; sym.textContent = symbol;
      front.appendChild(sym); inner.append(back, front); card.append(inner);

      card.addEventListener('click', () => onCardClick(card));
      card.addEventListener('keydown', (ev) => { if(ev.key==='Enter'||ev.key===' '){ ev.preventDefault(); onCardClick(card); } });

      frag.appendChild(card);
    }

    grid.appendChild(frag);
    tapBuffer = [];
    updateHud();
    updateScoreChip();
    hideOverlay();
    updateSaveButton();
    refreshPowersUI();
  }

  function startTimer(){
    if(state.paused) return;
    if(state.running) return;

    if (state.isZen){
      state.running = true;
      frameBaseScore = totalScore;
      updateSaveButton();
      return;
    }

    state.running = true;
    frameBaseScore = totalScore;
    const now = performance.now();
    state.startTs = now;

    const p = progress[currentLevelIdx];
    const carry = !p.unlocked ? (p.carryBonusMs || 0) : 0;
    const base = Math.max(0, p.baseTimeMs + carry);

    state.deadlineTs = now + base;
    tick();
    updateSaveButton();
  }

  function tick(){
    if (state?.isZen) return;
    if(!state.running || state.paused) return;
    const now = performance.now();
    state.leftMs = Math.max(0, state.deadlineTs - now);
    updateTime();
    if(state.leftMs<=0){ state.running=false; lose('Tempo scaduto ⏰'); return; }
    requestAnimationFrame(tick);
  }

  function updateTime() {
    if (state?.isZen) return;
    timerEl.textContent = fmt(state.leftMs);
  }

  function updateHud(){
    if (!state?.isZen){
      movesEl.textContent = `Mosse: ${state.moves}`;
      timerEl.textContent = fmt(state.leftMs);
    }
    updateStatusChip();
    updateScoreChip();
  }

function onCardClick(card){
  ensureSfx();

  // SIMON attivo → comportamento invariato
  if (sim && sim.active){
    simonOnTap(card);
    return;
  }

  SFX.play('tap', { volume:.5, rate: 0.98 + Math.random()*0.04 });

  // Pausa / lock (da overlay o potere 👁️) → comportamento invariato
  if (state.paused) { flashMessage('In pausa ▶'); return; }
  if (state.lock) {
    if (tapBuffer.length < TAP_BUFFER_MAX &&
        card.dataset.state !== 'matched' &&
        card.dataset.state !== 'revealed') {
      tapBuffer.push(card);
    }
    return;
  }

  // Niente re-click su carte già visibili / già abbinate
  if (card.dataset.state === 'matched' || card.dataset.state === 'revealed') return;

  startTimer();
  flip(card, true);

  // Gestione speciali come prima (aggiuntiva, NON interrompe il confronto)
  if (card.dataset.symbol === RED){
    state.redFlips++;
    refreshPowersUI();
    SFX.play('skull', { volume:.9, rate: 0.98 });
    if(state.redFlips >= 2){
      setTimeout(() => lose('Oh no! 💀', 'Hai rivelato il teschio due volte.'), 220);
      // Anche in caso di sconfitta lascio il resto fermarsi naturalmente
      return;
    }
  }
  if (card.dataset.symbol === YELLOW){
    state.yellowFlips++;
    flashMessage('Shuffle!');
    reshuffleHiddenNonSpecial();
  }

  // --- Confronto "pivot → nuova carta" (mosse per confronto, non per primo flip isolato) ---
  const prev = state.pivot;

  // Se non esiste un pivot valido, questa carta DIVENTA il pivot e basta
  if (!prev || prev.getAttribute('data-state') === 'matched'){
    state.pivot = card;
    return;
  }

  // Non confrontare una carta con sé stessa
  if (prev === card){
    return;
  }

  // Qui c'è un confronto: conta 1 mossa
  state.moves++;
  if (!state.isZen) movesEl.textContent = `Mosse: ${state.moves}`;

  const aSym = prev.dataset.symbol;
  const bSym = card.dataset.symbol;
  const isSpecial = s => (s === RED || s === YELLOW);
  const isMatch = !isSpecial(aSym) && !isSpecial(bSym) && (aSym === bSym);

  if (isMatch){
    // Annulla eventuali richiuse pendenti sul pivot
    cancelHide(prev);
    cancelHide(card);

    // Bonus tempo & combo come prima
    const now = performance.now();
    if (!state.isZen){
      state.deadlineTs += 1000;            // +1s
      state.leftMs = Math.max(0, state.deadlineTs - now);
      updateTime();
      flashMessage('+1s');
      SFX.play('bonus1', { volume:.85, rate: 1.02 });

      if (state.streak >= 1 && (now - state.lastMatchTime) < 5000){
        state.deadlineTs += 5000;          // +5s combo
        state.leftMs = Math.max(0, state.deadlineTs - performance.now());
        updateTime();
        flashMessage('+5s Bonus!');
        SFX.play('bonus5', { volume:1 });
      }
      state.lastMatchTime = now;
    }

    // Marca la coppia
    prev.setAttribute('data-state','matched');
    card.setAttribute('data-state','matched');
    spawnMatchStars(prev);
    spawnMatchStars(card);
    SFX.play('ok', { volume:.9, rate: 0.98 });

    state.matched++;
    state.streak++;
    refreshPowersUI();

    // Fine quadro?
    if(state.matched >= state.level.pairs){
      win();
      return;
    }

    // Dopo un match non c'è pivot
    state.pivot = null;
    return;
  }

  // --- Mismatch: nessun blocco input, ma programmo la richiusa di entrambe ---
  state.streak = 0;
  if (!state.isZen){
    const now = performance.now();
    state.deadlineTs = state.deadlineTs - 1000; // -1s
    state.leftMs = Math.max(0, state.deadlineTs - now);
    updateTime();
    flashMessage('-1s');
    SFX.play('fail', { volume:.9 });
  }

  // Le due carte restano visibili per la solita finestra, poi si richiudono
  scheduleHidePair(prev, card);

  // Il nuovo pivot diventa l'ultima carta girata (così puoi matchare al terzo flip)
  state.pivot = card;
}

  function flip(card, reveal){ card.setAttribute('data-state', reveal ? 'revealed' : 'hidden'); }
function cancelHide(card){
  const t = state.hideTimers?.get(card);
  if (t){ clearTimeout(t); state.hideTimers.delete(card); }
}

function scheduleHide(card, ms){
  cancelHide(card);
  const t = setTimeout(() => {
    if (card.getAttribute('data-state') !== 'matched' &&
        card.getAttribute('data-state') === 'revealed'){
      flip(card, false);
    }
    state.hideTimers?.delete(card);
  }, ms);
  state.hideTimers?.set(card, t);
}

function scheduleHidePair(a, b){
  scheduleHide(a, MISMATCH_HOLD_MS);
  scheduleHide(b, MISMATCH_HOLD_MS);
}


  function reshuffleHiddenNonSpecial(){
    const cards = Array.from(grid.querySelectorAll('.card'));
    const targets = cards.filter(c => c.getAttribute('data-state') === 'hidden' && c.dataset.symbol !== '💀' && c.dataset.symbol !== '⚡');
    if(targets.length <= 1) return;
    const symbols = targets.map(c => c.dataset.symbol);
    for(let i=symbols.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [symbols[i],symbols[j]]=[symbols[j],symbols[i]]; }
    targets.forEach((c,i) => {
      c.dataset.symbol = symbols[i];
      c.querySelector('.symbol').textContent = symbols[i];
    });
    flashMessage('🔀 Rimescolo!');
    SFX.play('reshuffle', { volume:.9 });
  }

  function startSimonIntermezzo(){
    ensureSfx();
    document.body.classList.add('mode-simon');
    refreshPowersUI();

    document.body.classList.add('no-flip');
    getActiveCards().forEach(c => c.setAttribute('data-state', 'hidden'));

    requestAnimationFrame(() => {
      document.body.classList.remove('no-flip');

      const activeIdx = getActiveCards().map(c => +c.dataset.index);
      const order = shuffle(activeIdx.slice());
      const maxLen   = order.length;
      const startLen = Math.min(SIMON_CFG.startLen, maxLen);

      sim = { active: true, busy: false, order, round: startLen - 1, pos: 0, maxLen };

      if (pauseBtn) pauseBtn.disabled = true;
      flashMessage('👻 Simon: ripeti la sequenza');
      simNextRound();
    });
  }

  function simNextRound(){
    if (!sim || !sim.active) return;
    if (sim.round >= sim.maxLen){
      endSimon(sim.round);
      return;
    }
    sim.round++;
    simShowSequence();
  }

  async function simShowSequence(){
    sim.pos = 0;
    sim.busy = true;

    await new Promise(r => setTimeout(r, 350));

    for (let i = 0; i < sim.round; i++){
      await simFlash(sim.order[i]);
      await new Promise(r => setTimeout(r, SIMON_CFG.gapMs));
    }

    sim.busy = false;
  }

  function simFlash(idx){
    return new Promise(res => {
      const card = getCardByIndex(idx);
      if (!card){ res(); return; }

      const ghost = document.createElement('div');
      ghost.className = 'simon-ghost';
      ghost.textContent = GHOST;
      ghost.style.animationDuration = SIMON_CFG.previewMs + 'ms';

      card.appendChild(ghost);

      SFX.play?.('tap', { volume:.6, rate: 1.05 });
      setTimeout(() => { ghost.remove(); res(); }, SIMON_CFG.previewMs);
    });
  }

  function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }

  async function simonRevealTemp(card, symbol, holdMs){
    const ghost = document.createElement('div');
    ghost.className = 'simon-ghost';
    ghost.style.animationDuration = holdMs + 'ms';
    ghost.textContent = symbol;

    card.appendChild(ghost);
    if (symbol === '💀') {
      SFX.play?.('skull', { volume:.95 });
    } else {
      SFX.play?.('flip', { volume:.75 });
    }

    await sleep(holdMs);
    ghost.remove();
  }
  async function simonRevealSkull(card, holdMs){ return simonRevealTemp(card, '💀', holdMs); }

  async function simonOnTap(card){
    if (!sim || !sim.active) return;
    if (sim.busy) return;

    const idx = +card.dataset.index;
    const expected = sim.order[sim.pos];

    if (idx !== expected){
      sim.busy = true;
      await simonRevealSkull(card, SIMON_CFG.wrongHoldMs);
      sim.busy = false;
      endSimon(Math.max(0, sim.round - 1));
      return;
    }

    sim.busy = true;
    sim.pos++;
    SFX.play?.('ok', { volume:.8 });
    await simonRevealTemp(card, GHOST, SIMON_CFG.inputRevealMs);
    sim.busy = false;

    if (sim.pos === sim.round){
      flashMessage('✓');
      setTimeout(() => simNextRound(), 350);
    }
  }

  function endSimon(completedLen){
    document.body.classList.remove('mode-simon');
    refreshPowersUI();

    const bonusSec = Math.max(0, Math.min(completedLen, sim?.maxLen || 0));
    sim.active = false;
    sim = null;

    if (pauseBtn) pauseBtn.disabled = false;

    const bonusMs = bonusSec * 1000;
    const next = currentLevelIdx + 1;

    if (next < LEVELS.length && !progress[next].unlocked) {
      progress[next].carryBonusMs = (progress[next].carryBonusMs || 0) + bonusMs;
    }

    const finalMsg = bonusSec > 0
      ? `Hai guadagnato <b>+${bonusSec}s</b> per il prossimo livello!`
      : 'Nessun bonus ottenuto.';

    showOverlay('Intermezzo Simon concluso', `${finalMsg}`);
    ovBtn.textContent = 'Vai al livello successivo';
    ovBtn.onclick = () => { hideOverlay(); init(next); };
  }

  function spawnMatchStars(card){
    const wrap = document.createElement('div');
    wrap.className = 'match-stars';
    card.appendChild(wrap);

    const N = 6;
    for(let i=0;i<N;i++){
      const s = document.createElement('span');
      s.className = 'star';
      s.textContent = '✨';
      const r = 26 + Math.random()*18;
      const ang = (Math.PI*2/N)*i + Math.random()*0.7;
      const dx = Math.cos(ang)*r;
      const dy = Math.sin(ang)*r;
      s.style.setProperty('--dx', `${dx}px`);
      s.style.setProperty('--dy', `${dy}px`);
      wrap.appendChild(s);
    }
    setTimeout(() => wrap.remove(), 650);
  }
// ===== Condivisione testuale Zen =====
function buildZenShareText(){
 const elapsedMs = state?.finalElapsedMs ?? calcElapsedMs();  // preferisci il tempo congelato
  const moves = state?.moves || 0;
  const eff = calcZenEfficiency(moves, LEVELS[currentLevelIdx]);
  const stars = effToStars(eff);

  // Messaggio richiesto
return `Ho fatto ${stars}/5 ⭐ in Zen su Skullory in ${moves} mosse, ${eff}% efficienza e tempo ${fmt(elapsedMs)} — prova a battermi!\n\n${GAME_URL}`;

}

async function shareZen(){
  const text = buildZenShareText();
  try{
    if (navigator.share){
      await navigator.share({
        title: 'Skullory — Zen',
        text
        // ❌ niente 'url' qui: molti target (WhatsApp) ignorano 'text' se 'url' è presente
      });
      return;
    }
  }catch(e){
    // utente ha annullato: ignora
  }

  // Fallback: copia negli appunti
  try{
    if (navigator.clipboard && window.isSecureContext){
      await navigator.clipboard.writeText(text);
      flashMessage('✅ Copiato: incolla dove vuoi!');
      return;
    }
  }catch(_) {}

  // Ultimo fallback: mailto
  const mailto = `mailto:?subject=${encodeURIComponent('Il mio risultato Zen su Skullory')}&body=${encodeURIComponent(text)}`;
  window.location.href = mailto;
}

function showZenEnd(){
  // Congela l'elapsed al momento della vittoria
  state.finalElapsedMs = calcElapsedMs();
  const elapsedMs = state.finalElapsedMs;   // <-- usa quello salvato
  const moves = state.moves || 0;
  const eff = calcZenEfficiency(moves, LEVELS[currentLevelIdx]);

  ovTitle.textContent = 'Griglia completata!';
  ovSub.innerHTML =
    `⏱️ Tempo impiegato: <b>${fmt(elapsedMs)}</b><br/>` +
    `🎯 Mosse totali: <b>${moves}</b><br/>` +
    `📊 Efficienza: <b>${eff}%</b>`;

  // ⭐⭐⭐⭐⭐ — nuovo rating a 5 stelle
  const nStars = effToStars(eff);
  ovSub.innerHTML += `<br/>${'⭐'.repeat(nStars)} <small>${starsLabel(nStars)}</small>`;

  ovBtn.textContent = 'Gioca ancora';
  ovBtn.onclick = () => { hideOverlay(); startZen(); };

  showSkip(true);
  ovBtnSkip.textContent = 'Torna al menu';
  ovBtnSkip.onclick = () => { hideOverlay(); showIntro(); };


const actions = document.querySelector('.ov-actions');
if (actions) {
  document.getElementById('shareTextBtn')?.remove();
  const shareBtn = document.createElement('button');
  shareBtn.id = 'shareTextBtn';
  shareBtn.className = 'primary outline-btn';
  shareBtn.textContent = 'Condividi';
  shareBtn.onclick = () => shareZen();
  actions.appendChild(shareBtn);
}

  overlay.classList.add('show');
  updateSaveButton();
}


  function win(){
    if (state?.isZen){ showZenEnd(); return; }
    state.running = false;
    SFX.play('win', { volume:1.0 });

    const secondsLeft = Math.floor(state.leftMs/1000);
    const free = freeMovesFor(state.level);
    const mult = efficiencyMultiplier(state.moves, free);
    const frameScore = roundNearest(secondsLeft * mult);
    totalScore = frameBaseScore + frameScore;
    updateScoreChip();

    const L = LEVELS[currentLevelIdx];
    const p = progress[currentLevelIdx];

    const detailRow = `Tempo: ${secondsLeft}s · Mosse: ${state.moves}<br>
Punti quadro = <b>${frameScore}</b><br>
Punteggio parziale: <b>${totalScore}</b>`;

    if(!p.unlocked){
      p.streak += 1;
      if(p.streak < 3){
        p.baseTimeMs = L.unlockMs[p.streak];
        showOverlay('Quadro completato ✔️', `Sblocco: ${p.streak}/3<br>${detailRow}<br><small>Prossimo tentativo: tempo base ${Math.floor(p.baseTimeMs/1000)}s</small>`);
        ovBtn.textContent = 'Continua a giocare';
        ovBtn.onclick = () => { hideOverlay(); init(currentLevelIdx); };
      } else {
        p.unlocked = true;
        p.postUnlockWins = 0;
        p.carryBonusMs = 0;

        const next = currentLevelIdx + 1;

        showOverlay(
          'Sblocco conquistato! 🏆',
          `Hai completato 3 quadri di fila.<br>
           ${detailRow}<br><br>
           <b>Cosa vuoi fare adesso?</b>`
        );

        ovBtn.textContent = 'Continua qui (fai punti)';
        ovBtn.onclick = () => {
          hideOverlay();
          init(currentLevelIdx);
        };

        if (next < LEVELS.length){
          showSkip(true);
          ovBtnSkip.textContent = 'Livello successivo';
          ovBtnSkip.onclick = () => { openSimonChoice(next); };
        } else {
          showSkip(false);
        }
      }
    } else {
      p.postUnlockWins += 1;
      p.baseTimeMs = Math.max(0, p.baseTimeMs - L.postDeltaSec*1000);
      showOverlay('Quadro completato ✔️', `Post-sblocco: ${p.postUnlockWins} completati<br>${detailRow}<br><small>Prossimo tentativo: tempo base ${Math.floor(p.baseTimeMs/1000)}s</small>`);
      ovBtn.textContent = 'Continua a giocare';
      ovBtn.onclick = () => { hideOverlay(); init(currentLevelIdx); };
    }

    if (activeSaveName) {
      upsertSave(activeSaveName, buildPayload());
      flashMessage('💾 Autosalvato: ' + activeSaveName);
    }
    updateSaveButton();
  }

  function lose(title, sub){
    const L = LEVELS[currentLevelIdx];
    const p = progress[currentLevelIdx];
    state.running = false;
    SFX.play('lose', { volume:1.0 });

    if (p.unlocked){
      const next = currentLevelIdx + 1;
      openSimonChoice(next);
      return;
    } else {
      p.streak = 0;
      p.baseTimeMs = L.unlockMs[0];

      totalScore = 0;
      frameBaseScore = 0;
      updateScoreChip();

      showOverlay(
        title || 'Hai perso',
        (sub || 'Ritenta!') +
        `<br><small>Sblocco: ${p.streak}/3 – tempo base ripristinato a ${Math.floor(p.baseTimeMs/1000)}s</small>`
      );
      ovBtn.textContent = 'Riprova questo livello';
      ovBtn.onclick = () => { hideOverlay(); init(currentLevelIdx); };
    }
    updateSaveButton();
  }

  function showOverlay(title, sub){
    ovTitle.textContent = title;
    ovSub.innerHTML = sub;
    overlay.classList.add('show');
    showSkip(false);
    updateSaveButton();
    refreshPowersUI();
  }
  function hideOverlay(){
    overlay.classList.remove('show');
    updateSaveButton();
    refreshPowersUI();
  }

  function openSimonChoice(next){
    showOverlay(
      'Intermezzo bonus tempo 👻',
      '<b>Bravo!</b> Prima di accedere al livello successivo puoi provare a guadagnare <b>secondi bonus</b> con un mini-gioco cliccando i fantasmini nella giusta sequenza.<br><br>' +
      '<small>Ogni passo corretto = <b>+1s</b> al prossimo livello. Se riveli il teschio il mini-gioco termina.</small>'
    );

    ovBtn.textContent = 'Prova il Bonus';
    ovBtn.onclick = () => {
      hideOverlay();
      startSimonIntermezzo();
    };

    showSkip(true);
    if (ovBtnSkip) {
      ovBtnSkip.textContent = 'Prosegui senza Bonus';
      ovBtnSkip.onclick = () => {
        hideOverlay();
        if (next < LEVELS.length) {
          init(next);
        } else {
          init(currentLevelIdx);
        }
      };
    }
  }

  function explainPower(which){
    let title = '', desc = '', avail = '';

    if (which === 'reveal'){
      title = '👁️ Sbirciatina!';
      desc  = 'Svela tutte le carte per 1s ma costa il 20% del tempo rimanente.';
      avail = 'Disponibile dopo aver fatto almeno 1 coppia.';
    } else if (which === 'plus10'){
      title = '🦇 Guadagna 10s!';
      desc  = '+10 secondi, ma una coppia già trovata torna coperta e viene rilocalizzata.';
      avail = 'Disponibile dopo aver fatto almeno 1 coppia.';
    } else if (which === 'shift'){
      title = '🌀 Guadagna 15s!';
      desc  = '+15 secondi, ma rimescola tutto, anche 💀 e ⚡.';
      avail = 'Disponibile dopo aver svelato almeno un 💀.';
    }

    const html = `${desc}<br><small>${avail}</small><br><small>Utilizzabile solo durante la manche.</small>`;
    showOverlay(title, html);
    ovBtn.textContent = 'Ok';
    ovBtn.onclick = () => { hideOverlay(); };
    showSkip(false);
  }

  function openRestartConfirm(){
    restartConfirm.classList.add('show');
    restartConfirm.setAttribute('aria-hidden','false');
    refreshPowersUI();
  }
  function closeRestartConfirm(){
    restartConfirm.classList.remove('show');
    restartConfirm.setAttribute('aria-hidden','true');
    refreshPowersUI();
  }

  function flashMessage(text){
    const msg = document.createElement('div');
    msg.className = 'flash-msg';
    msg.textContent = text;
    document.body.appendChild(msg);
    setTimeout(() => msg.remove(), 1500);
  }

  // ===== Multi-slot Saves =====
  function readSaves(){
    try{ const raw = localStorage.getItem(SAVES_KEY); return raw ? JSON.parse(raw) : []; }catch(e){ return []; }
  }
  function writeSaves(list){ try{ localStorage.setItem(SAVES_KEY, JSON.stringify(list)); }catch(e){} }
  function upsertSave(name, payload){
    const list = readSaves();
    const idx = list.findIndex(s => s && s.name === name);
    const entry = { name, when: Date.now(), data: payload };
    if(idx>=0) list[idx] = entry; else list.push(entry);
    writeSaves(list);
  }
  function deleteSave(name){ writeSaves(readSaves().filter(s => s && s.name !== name)); }

  function buildPayload(){
    return {
      version: 3,
      when: Date.now(),
      themeIndex,
      totalScore,
      currentLevelIdx,
      progress
    };
  }
  function loadPayload(data){
    if(!data) return false;
    themeIndex = data.themeIndex ?? themeIndex;
    totalScore = data.totalScore ?? 0;
    currentLevelIdx = data.currentLevelIdx ?? 0;
    if (Array.isArray(data.progress)) progress = data.progress;

    init(currentLevelIdx);
    frameBaseScore = totalScore;
    const b = document.body;
    b.className = (b.className || '').split(' ').filter(c => !c.startsWith('theme-')).join(' ');
    b.classList.add('theme-' + themeIndex);

    state.paused = false;
    state.running = false;
    pauseBtn.textContent = '⏸️';
    updateHud();
    updateSaveButton();
    return true;
  }

  function openSaveManager(){
 if (state?.isZen) {                         // ⬅️ AGGIUNGI
    flashMessage('In Zen non si salva 😊');
    return;
  }
    if(!canSaveNow()){
      flashMessage('💾 Salva solo a fine quadro o prima di iniziare');
      return;
    }
    renderSaveList();
    const sc = document.getElementById('saveControls');
    if (sc) sc.style.display = '';

    saveModal.classList.add('show');
    saveModal.setAttribute('aria-hidden','false');
    saveNameInput.value = '';
    saveNameInput.focus();
  }
  function closeSaveManager(){
    saveModal.classList.remove('show');
    saveModal.setAttribute('aria-hidden','true');
  }
  function renderSaveList(){
    const list = readSaves().sort((a,b)=> (b.when||0)-(a.when||0));
    if(!list.length){ saveList.innerHTML = '<div style="color:var(--muted)">Nessun salvataggio.</div>'; return; }
    saveList.innerHTML = '';
    list.forEach(entry => {
      const row = document.createElement('div');
      row.className = 'save-row';
      row.style.display = 'grid';
      row.style.gridTemplateColumns = '1fr auto auto';
      row.style.gap = '8px';
      row.style.alignItems = 'center';
      row.style.padding = '6px 0';

      const name = document.createElement('div');
      const d = new Date(entry.when||Date.now());
      const title = document.createElement('b');  title.textContent = entry.name;
      const small = document.createElement('small'); small.textContent = d.toLocaleString();
      name.append(title, document.createElement('br'), small);

      const loadBtn = document.createElement('button');
      loadBtn.className = 'icon-btn';
      loadBtn.innerHTML = '📤';
      loadBtn.title = 'Carica questo salvataggio';
      loadBtn.setAttribute('aria-label','Carica questo salvataggio');

      const delBtn = document.createElement('button');
      delBtn.className = 'icon-btn';
      delBtn.innerHTML = '🗑️';
      delBtn.title = 'Elimina questo salvataggio';
      delBtn.setAttribute('aria-label','Elimina questo salvataggio');

      loadBtn.onclick = () => {
        loadPayload(entry.data);
        setActiveSaveName(entry.name);
        closeSaveManager();
        flashMessage('📂 Caricato: ' + entry.name);
      };
      delBtn.onclick = () => {
        document.querySelectorAll('.inline-confirm').forEach(el => el.remove());
        const rows = saveList.querySelectorAll('.save-row');
        rows.forEach(r => { if (r !== row) r.style.display = 'none'; });

        const toolbar = doSaveBtn ? doSaveBtn.parentElement : null;
        const restoreToolbar = () => { if (toolbar) toolbar.style.display = ''; };
        if (toolbar) toolbar.style.display = 'none';

        const wrap = document.createElement('div');
        wrap.className = 'inline-confirm';
        wrap.style.display = 'flex';
        wrap.style.gap = '8px';
        wrap.style.alignItems = 'center';
        wrap.style.gridColumn = '1 / -1';
        wrap.style.marginTop = '6px';
        wrap.style.padding = '8px 10px';
        wrap.style.border = '1px solid var(--panel-border)';
        wrap.style.borderRadius = '10px';
        wrap.style.background = 'linear-gradient(180deg,var(--panel-1),var(--panel-2))';
        wrap.innerHTML = `
          <span>Eliminare <b>${entry.name}</b>?</span>
          <div style="margin-left:auto; display:flex; gap:8px">
            <button class="primary" id="c-yes">Sì, elimina</button>
            <button class="primary" id="c-no" style="background:var(--bad); color:#fff">Annulla</button>
          </div>
        `;

        row.after(wrap);

        wrap.querySelector('#c-yes').onclick = () => {
          deleteSave(entry.name);
          renderSaveList();
          restoreToolbar();
        };
        wrap.querySelector('#c-no').onclick = () => {
          wrap.remove();
          rows.forEach(r => { r.style.display = ''; });
          restoreToolbar();
        };
      };

      row.append(name, loadBtn, delBtn);
      saveList.appendChild(row);
    });
  }

  if (introBtn){ /* handler impostato da setTutorialMode() */ }

  restartBtn.addEventListener('click', () => { openRestartConfirm(); });
  if (restartYes) {
    restartYes.addEventListener('click', () => {
      closeRestartConfirm();
      hideOverlay();
      currentLevelIdx = 0;
      showIntro();
    });
  }
  if (restartNo) {
    restartNo.addEventListener('click', () => { closeRestartConfirm(); });
  }

  pauseBtn.addEventListener('click', togglePause);
  if(saveBtn){ saveBtn.addEventListener('click', openSaveManager); }
  if (powerRevealBtn) powerRevealBtn.addEventListener('click', usePowerReveal);
  if (powerPlus10Btn) powerPlus10Btn.addEventListener('click', usePowerPlus10);
  if (powerShiftBtn)  powerShiftBtn.addEventListener('click', usePowerShift);

  if (doSaveBtn) {
    let overwritePrompt = null;

    doSaveBtn.addEventListener('click', () => {
      const nm = (saveNameInput.value || '').trim();
      if (!nm) { flashMessage('Inserisci un nome'); return; }
      if (!canSaveNow()) { flashMessage('Puoi salvare solo a fine quadro o prima di iniziare'); return; }

      const exists = readSaves().some(s => s && s.name === nm);

      if (exists && !overwritePrompt) {
        overwritePrompt = document.createElement('div');
        overwritePrompt.setAttribute('role', 'dialog');
        overwritePrompt.setAttribute('aria-label', 'Conferma sovrascrittura salvataggio');
        overwritePrompt.style.marginTop = '8px';
        overwritePrompt.style.padding = '10px';
        overwritePrompt.style.background = 'var(--panel-1)';
        overwritePrompt.style.border = '1px solid var(--panel-border)';
        overwritePrompt.style.borderRadius = '12px';
        overwritePrompt.innerHTML = `
          <div style="margin-bottom:8px; color:var(--muted)">
            Sovrascrivere <b>${nm}</b>?
          </div>
          <div style="display:flex; gap:8px; justify-content:flex-end">
            <button class="primary" id="ow-yes" tabindex="0">Sì</button>
            <button class="primary" id="ow-no" style="background:var(--bad); color:#fff">No</button>
          </div>
        `;

        saveNameInput.parentElement.parentElement.appendChild(overwritePrompt);

        const yesBtn = overwritePrompt.querySelector('#ow-yes');
        const noBtn  = overwritePrompt.querySelector('#ow-no');

        requestAnimationFrame(() => yesBtn && yesBtn.focus());

        yesBtn.onclick = () => {
          upsertSave(nm, buildPayload());
          setActiveSaveName(nm);
          flashMessage('💾 Sovrascritto: ' + nm);
          renderSaveList();
          saveNameInput.value = '';
          overwritePrompt.remove();
          overwritePrompt = null;
        };

        noBtn.onclick = () => {
          overwritePrompt.remove();
          overwritePrompt = null;
        };

        setTimeout(() => {
          if (overwritePrompt) {
            overwritePrompt.remove();
            overwritePrompt = null;
          }
        }, 5000);

        return;
      }

      upsertSave(nm, buildPayload());
      setActiveSaveName(nm);
      flashMessage('💾 Salvato: ' + nm);
      renderSaveList();
      saveNameInput.value = '';
    });
  }

  if (saveClose){ saveClose.addEventListener('click', closeSaveManager); }

  // scorciatoia Ctrl/⌘+S
  window.addEventListener('keydown', (e)=>{
    const sKey = (e.key||'').toLowerCase()==='s';
    if(sKey && (e.ctrlKey || e.metaKey)){
      e.preventDefault();
      if (!state?.isZen) openSaveManager();
    }
  });

  // ===== Pausa / Resume =====
  function togglePause(){
    if(!state) return;
    if(!state.running && state.pauseLeftMs>0){
      state.paused = false;
      state.running = true;
      state.deadlineTs = performance.now() + state.pauseLeftMs;
      state.pauseLeftMs = 0;
      pauseBtn.textContent = '⏸️';
      tick();
      refreshPowersUI();
      return;
    }
    if(state.running){
      state.paused = true;
      const now = performance.now();
      state.pauseLeftMs = Math.max(0, state.deadlineTs - now);
      state.running = false;
      pauseBtn.textContent = '▶️';
      tapBuffer = [];
      refreshPowersUI();
      return;
    }
  }

  // --- S P L A S H ---
  document.addEventListener('DOMContentLoaded', () => {
    const splash = document.getElementById('splash');
    let splashTimer = null;

    function showSplash(){
      if (!splash) return;
      splash.classList.remove('hide');
      splash.classList.add('show');
    }
    function hideSplash(){
      if (!splash) return;
      splash.classList.add('hide');
      splash.classList.remove('show');
    }
    function skipSplash(){
      if (splashTimer) { clearTimeout(splashTimer); splashTimer = null; }
      ensureSfx();
      hideSplash();
      showIntro();
    }

    if (splash){
      splash.addEventListener('click', skipSplash);
      window.addEventListener('keydown', (e) => {
        if (!splash || splash.classList.contains('hide')) return;
        if (e.key === 'Enter' || e.key === ' ' || e.key === 'Escape') skipSplash();
      });
    }

    init(0);
    showSplash();
    splashTimer = setTimeout(() => {
      hideSplash();
      showIntro();
    }, 3000);
  });

  // Migrazione legacy → slot "Ultimo"
  try{
    if(localStorage.getItem(STORAGE_KEY)){
      const raw = localStorage.getItem(STORAGE_KEY);
      const data = raw ? JSON.parse(raw) : null;
      if(data) upsertSave('Ultimo', { version:3, themeIndex, totalScore:0, currentLevelIdx:0, progress });
      localStorage.removeItem(STORAGE_KEY);
      flashMessage('Importato salvataggio legacy in "Ultimo"');
    }
  }catch(e){}
})();
</script>

<!-- Splash pre-tutorial (3s) -->
<div id="splash" class="splash show" role="button" aria-label="Splash iniziale (tocca per saltare)">
  <svg viewBox="0 0 1200 1200" preserveAspectRatio="xMidYMid meet" class="splash-art" aria-hidden="true">
    <defs>
      <radialGradient id="bg" cx="50%" cy="40%" r="70%">
        <stop offset="0%" stop-color="#2b335c"/>
        <stop offset="100%" stop-color="#141724"/>
      </radialGradient>
    </defs>
    <rect width="1200" height="1200" fill="url(#bg)"/>
  </svg>
  <img src="splash-template.svg" class="splash-art" alt="Skullory" style="position:absolute;">
</div>

</body>
</html>
