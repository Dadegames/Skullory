<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Skullory ‚Äì 7 livelli</title>
<style>
  :root{
    --bg-1:#141724; --bg-2:#232a46; --bg-3:#2b335c; --bg-4:#28315a;
    --panel:#0f1322; --panel-1:#12162a; --panel-2:#0d1120; --panel-border:#2b3357;
    --grid-1:#101429; --grid-2:#0c1020; --grid-border:#2b3357;
    --card-back:#2a3157; --card-front:#171b2d; --card-border:#394275; --card-pattern:#3b4479;
    --accent:#7484ff; --ok:#52ce89; --bad:#f4606c; --text:#f5f5f8; --muted:#c8cde0;
    --gap:12px; --radius:16px; --shadow:0 10px 30px rgba(0,0,0,.35);
    --flip-ms:380ms; --cols:4;
  }
  /* THEME CLASSES (override variables) */
  body.theme-1{ --card-pattern:#3b4479;  --bg-1:#141724; --bg-2:#232a46; --bg-3:#2b335c; --bg-4:#28315a; --panel:#0f1322; --panel-1:#12162a; --panel-2:#0d1120; --panel-border:#2b3357; --grid-1:#101429; --grid-2:#0c1020; --grid-border:#2b3357; --card-back:#2a3157; --card-front:#171b2d; --card-border:#394275; --card-pattern:#3b4479; --accent:#7484ff; --ok:#52ce89; --bad:#f4606c; --text:#f5f5f8; --muted:#c8cde0; }
  body.theme-2{ --card-pattern:#5d3a78;  --bg-1:#2b1838; --bg-2:#401b3f; --bg-3:#52234f; --bg-4:#5a2558; --panel:#1a0f24; --panel-1:#2a1536; --panel-2:#0c1b29; --panel-border:#4e2b6b; --grid-1:#261433; --grid-2:#0c1020; --grid-border:#4e2b6b; --card-back:#3b2648; --card-front:#23142e; --card-border:#5d3a78; --accent:#ff7a59; --ok:#56df9a; --bad:#ff5c7a; --text:#fff3f5; --muted:#e0c9d6; }
  body.theme-3{ --card-pattern:#2c6a4c;  --bg-1:#0f1a14; --bg-2:#163024; --bg-3:#1c3d2c; --bg-4:#214736; --panel:#0b1913; --panel-1:#0f221a; --panel-2:#0c1b14; --panel-border:#2a5a43; --grid-1:#13261e; --grid-2:#0e1f18; --grid-border:#2a5a43; --card-back:#183b2b; --card-front:#0f221a; --card-border:#2c6a4c; --accent:#9be564; --ok:#4fe39c; --bad:#ff6b6b; --text:#eaf7ef; --muted:#b4d7c7; }
  body.theme-4{ --card-pattern:#7a5f44;  --bg-1:#2a241d; --bg-2:#3a2f23; --bg-3:#4a3b2b; --bg-4:#5a4a35; --panel:#1c1712; --panel-1:#251e17; --panel-2:#19140f; --panel-border:#6c553d; --grid-1:#211b15; --grid-2:#1a150f; --grid-border:#6c553d; --card-back:#4b3b2b; --card-front:#2a2119; --card-border:#7a5f44; --accent:#ffb84d; --ok:#7adf8a; --bad:#ff7f66; --text:#fff6e9; --muted:#e6d2b8; }
  body.theme-5{ --card-pattern:#2f5f80;  --bg-1:#0f1e2a; --bg-2:#123346; --bg-3:#17425a; --bg-4:#1a4b66; --panel:#0a1722; --panel-1:#0d2130; --panel-2:#0a1a26; --panel-border:#2b5574; --grid-1:#0f2736; --grid-2:#0b1f2a; --grid-border:#2b5574; --card-back:#163b52; --card-front:#0d2330; --card-border:#2f5f80; --accent:#4fd1ff; --ok:#6ae6b5; --bad:#ff6a7a; --text:#e6f7ff; --muted:#bdd8e7; }
  body.theme-6{ --card-pattern:#7a3535;  --bg-1:#1b1212; --bg-2:#2a1717; --bg-3:#3a1e1e; --bg-4:#4a2525; --panel:#140d0d; --panel-1:#1c1212; --panel-2:#110a0a; --panel-border:#6b2f2b; --grid-1:#1f1414; --grid-2:#170f0f; --grid-border:#6b2f2b; --card-back:#3a1e1e; --card-front:#241212; --card-border:#7a3535; --accent:#ff5e3a; --ok:#50e3a4; --bad:#ff4d4d; --text:#ffeceb; --muted:#e0b3b3; }
  body.theme-7{ --card-pattern:#415082;  --bg-1:#0f1116; --bg-2:#191d2b; --bg-3:#1f2640; --bg-4:#232b48; --panel:#0a0c12; --panel-1:#111521; --panel-2:#0d1019; --panel-border:#384064; --grid-1:#131827; --grid-2:#0f1320; --grid-border:#384064; --card-back:#1d2336; --card-front:#0f1522; --card-border:#415082; --accent:#ff3fb4; --ok:#50e3c2; --bad:#ff6b8b; --text:#f7f7ff; --muted:#c8cbe6; }
  body.theme-8{ --card-pattern:#2e6a73;  --bg-1:#0e1a1c; --bg-2:#14333a; --bg-3:#184249; --bg-4:#1d4e57; --panel:#0a1618; --panel-1:#0d2023; --panel-2:#0a1a1d; --panel-border:#2b5861; --grid-1:#10282d; --grid-2:#0c2024; --grid-border:#2b5861; --card-back:#15454d; --card-front:#0e262c; --card-border:#2e6a73; --accent:#42d6c5; --ok:#60e8a8; --bad:#ff6f7c; --text:#e8fffb; --muted:#bfe2de; }
  body.theme-9{ --card-pattern:#44684a;  --bg-1:#111a12; --bg-2:#1b2a1c; --bg-3:#223826; --bg-4:#284330; --panel:#0c140d; --panel-1:#111c13; --panel-2:#0d160f; --panel-border:#3b5f41; --grid-1:#162418; --grid-2:#111d13; --grid-border:#3b5f41; --card-back:#223b25; --card-front:#142018; --card-border:#44684a; --accent:#7bd88f; --ok:#6ee7b7; --bad:#ef6464; --text:#eaf6ee; --muted:#c7dccb; }
  body.theme-10{ --card-pattern:#57459a;  --bg-1:#1e1630; --bg-2:#2a1e46; --bg-3:#34285a; --bg-4:#3f306d; --panel:#150f22; --panel-1:#1e1733; --panel-2:#17102a; --panel-border:#4b3a7a; --grid-1:#221a3a; --grid-2:#1a1430; --grid-border:#4b3a7a; --card-back:#2f2759; --card-front:#1b1533; --card-border:#57459a; --accent:#00e0ff; --ok:#66f0a6; --bad:#ff7aa2; --text:#f4f2ff; --muted:#cdc6ff; }

  *{box-sizing:border-box}
  html,body{height:100%}
body{
  margin:0; color:var(--text); font:16px/1.45 system-ui,Segoe UI,Roboto,Helvetica,Arial;
  background:
    radial-gradient(1200px 800px at 20% -10%, var(--bg-3), transparent),
    radial-gradient(900px 600px at 110% 20%, var(--bg-4), transparent),
    linear-gradient(180deg, var(--bg-1), var(--bg-2));
  display:flex; 
  align-items:flex-start;      /* ‚Üê da center a flex-start */
  justify-content:center; 
  padding:10px 18px 18px;      /* ‚Üê prima era 18px uniformi */
  -webkit-font-smoothing: antialiased; 
  min-height:100dvh;
}
  .wrap{ width:min(1100px, 98vw); margin: 30px auto 0; /* 12px sopra, centrato orizzontalmente, 0 sotto */ }
.top{
  display:block;          /* non serve pi√π il flex: c‚Äô√® solo il logo */
  padding: 0;             /* niente padding per far aderire il logo */
}

.brand{ width:100%; }

.brand img{
  display:block;
  width:100%;             /* il logo si estende su tutta la larghezza del banner */
  height:auto;            /* scala proporzionalmente */
  /* opzionale: sblocca il vecchio vincolo di altezza e imposta un massimo */
  max-height: 70px;       /* cambia a tuo gusto (60‚Äì90px sono comuni) */
}

.controls {
  display: flex; /* pulsanti in riga */
  gap: 6px;      /* spazio tra pulsanti */
}
.controls-bottom{
  display: flex;            /* riga orizzontale */
  justify-content: center;  /* centrati in orizzontale */
  align-items: center;      /* centrati in verticale */
  gap: 8px;                 /* spazio tra pulsanti */
  width: 100%;              /* occupa tutta la riga del wrap */
  margin-top: 14px;         /* spazio sotto la griglia (regolabile) */
}

/* Riduci la larghezza SOLO dei tre bottoni in alto a destra */
.controls-bottom .outline-btn{
  padding: 8px 8px;
  min-width: 40px;
}


  button.primary{background:var(--accent); color:#0b0f1e; border:none; padding:10px 16px; border-radius:12px; font-weight:700; cursor:pointer}
  button.primary:active{transform:translateY(1px)}
  .stats-container{ display:flex; justify-content:center; margin:12px 0 8px; gap:12px; flex-wrap:wrap }
  .stats{ display:flex; align-items:center; gap:12px; flex-wrap:wrap; justify-content:center }
  .chip{ padding:8px 12px; border-radius:999px; background:#1a1f37; border:1px solid var(--panel-border); color:#c8cde0; white-space:nowrap }
  .level-chip{ padding:6px 10px; border-radius:999px; background:#1a1f37; border:1px solid var(--panel-border); color:#c8cde0; font-size:14px; white-space:nowrap }
  .timer{ font-size:26px; font-weight:700 }
  .grid{
    margin-top:18px; display:grid; grid-template-columns:repeat(var(--cols), minmax(0,1fr));
    gap:var(--gap); padding:18px; background:linear-gradient(180deg,var(--grid-1),var(--grid-2));
    border:1px solid var(--grid-border); border-radius:24px; box-shadow:var(--shadow);
  }
  .card{
    position:relative; aspect-ratio:1/1; perspective:900px;
    cursor:pointer; border-radius:var(--radius); -webkit-tap-highlight-color:transparent; touch-action:manipulation;
container-type: inline-size;   /* ‚üµ nuovo: abilita i cqi relativi alla larghezza della carta */
  }
  .face{ pointer-events:none; }
  .face{
    position:absolute; inset:0; display:grid; place-items:center; border-radius:var(--radius); border:1px solid var(--card-border);
    backface-visibility:hidden;
  }
  .front{ background:var(--card-front); transform:rotateY(180deg) }
  .back{ background:var(--card-back) }
  .back::before{
    content:""; position:absolute; inset:10px; border-radius:12px;
    background:
      linear-gradient(45deg,
        var(--card-pattern) 0 12%,
        transparent 12% 25%,
        var(--card-pattern) 25% 37%,
        transparent 37% 50%,
        var(--card-pattern) 50% 62%,
        transparent 62% 75%,
        var(--card-pattern) 75% 87%,
        transparent 87% 100%
      );
    opacity:.35;
  }
  .inner{
    position:absolute; inset:0; border-radius:var(--radius);
    transform-style:preserve-3d; transition: transform var(--flip-ms) cubic-bezier(.2,.7,.1,1);
    box-shadow: 0 12px 24px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.03);
  }
  .card[data-state="revealed"] .inner,
  .card[data-state="matched"] .inner{ transform:rotateY(180deg) }
.symbol{
  /* prima era: font-size: clamp(28px, 7.2vw, 64px);  */
  font-size: clamp(28px, 50cqi, 86px);  /* ‚üµ scala con la carta: 58% della sua larghezza */
  line-height: 1;
  filter: drop-shadow(0 4px 10px rgba(0,0,0,.45));
}
  .card[data-state="matched"] .front{ outline:3px solid var(--ok); box-shadow:0 0 18px rgba(82,206,137,.45) inset }
  .card[data-state="locked"]{ pointer-events:none }

  /* Placeholder per slot vuoto nei livelli senza angoli */
  .card.placeholder{
    background:transparent;
    border:none;
    box-shadow:none;
    pointer-events:none;
  }

  /* Special effects for üíÄ e ‚ö° */
  .card[data-symbol="üíÄ"] .front .symbol{ text-shadow: 0 0 10px rgba(244,96,108,.6) }
  .card[data-symbol="üíÄ"][data-state="revealed"] .front{ outline:3px solid var(--bad); box-shadow:0 0 22px rgba(244,96,108,.45) inset }
  .card[data-symbol="‚ö°"] .front .symbol{ text-shadow: 0 0 10px rgba(255,213,79,.6) }
  .card[data-symbol="‚ö°"][data-state="revealed"] .front{ outline:3px solid #ffd54f; box-shadow:0 0 22px rgba(255,213,79,.4) inset }

.flash-msg{
  position:fixed;
  top:20%;
  left:50%;
  transform:translateX(-50%);
  background:rgba(0,0,0,.8);
  color:#fff;
  padding:12px 20px;          /* pi√π grande */
  border-radius:12px;         /* un filo pi√π morbido */
  font-weight:700;
  font-size:1.3em;            /* testo pi√π grande */
  z-index:9999;
  pointer-events:none;        /* NON blocca i clic sotto */
  animation:flashUp 1.5s ease forwards; /* durata 1.5s */
}
/* Stelline match */
.match-stars { 
  position: absolute; inset: 0; pointer-events: none; 
  display: grid; place-items: center; 
}
.match-stars .star {
  position: absolute;
  font-size: 18px;
  opacity: 0;
  animation: starPop 600ms ease-out forwards;
  will-change: transform, opacity;
  filter: drop-shadow(0 6px 10px rgba(0,0,0,.35));
}
@keyframes starPop {
  0%   { transform: translate(0,0) scale(.4) rotate(0deg);   opacity: 0; }
  20%  { opacity: 1; }
  100% { transform: translate(var(--dx), var(--dy)) scale(1.2) rotate(35deg); opacity: 0; }
}
/* Anellino ‚Äúpulse‚Äù sulla carta matched (delicatissimo) */
.card[data-state="matched"] .front {
  animation: ringPulse 420ms ease-out;
}
@keyframes ringPulse {
  0%   { box-shadow: 0 0 0 0 rgba(82,206,137,.45) inset; }
  100% { box-shadow: 0 0 18px rgba(82,206,137,.45) inset; }
}

/* Accessibilit√†: niente animazioni se l‚Äôutente le riduce */
@media (prefers-reduced-motion: reduce){
  .match-stars .star, .card[data-state="matched"] .front { animation: none !important; }
}

@keyframes flashUp{
  0%{opacity:0; transform:translate(-50%, 8px)}
  15%{opacity:1; transform:translate(-50%, 0)}
  100%{opacity:0; transform:translate(-50%, -8px)}
}
  .overlay{ position:fixed; inset:0; display:none; place-items:center; background:rgba(0,0,0,.5); z-index:1000 }
  .overlay.show{ display:grid }
  .overlay.hide{ display:none !important }
  .dialog{ width:min(640px, 92vw); background:linear-gradient(180deg,var(--panel-1),var(--panel-2)); border:1px solid var(--panel-border);
    border-radius:20px; padding:24px; text-align:center; box-shadow:var(--shadow) }
  .dialog h2{ margin:6px 0 8px; font-size:28px }
  .dialog p{ margin:0 0 14px; color:var(--muted) }
  @media (max-width: 600px){
    .wrap{ width:min(520px, 96vw) }
    .top, .grid{ width:100% }
  }
/* Pulsanti Pausa, Salva, Ricomincia in versione outline */
.outline-btn {
  background: transparent !important;      /* sfondo trasparente */
  color: var(--accent) !important;          /* colore icona/testo = colore tema */
  border: 2px solid var(--accent) !important; /* bordo a tema */
}

.outline-btn:hover {
  background: rgba(255, 255, 255, 0.05);    /* leggero highlight al passaggio */
}

.outline-btn:active {
  background: rgba(255, 255, 255, 0.12);    /* feedback al click/tap */
}
/* Splash pre-tutorial */
.splash{
  position: fixed;
  inset: 0;
  z-index: 2000;                /* sopra intro/overlay */
  display: grid;
  place-items: center;
  background: linear-gradient(180deg, var(--bg-1), var(--bg-2));
  transition: opacity 280ms ease, visibility 280ms ease;
  opacity: 1;
  visibility: visible;
  cursor: pointer;
}
.splash.hide{
  opacity: 0;
  visibility: hidden;
  pointer-events: none;
}
.splash .splash-art{
  width: min(70vmin, 900px);
  max-width: 92vw;
  height: auto;
  filter: drop-shadow(0 24px 50px rgba(0,0,0,.45));
}
.splash .splash-skip{
  position: absolute;
  bottom: 28px;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(0,0,0,.35);
  border: 1px solid var(--panel-border);
  color: var(--muted);
  padding: 8px 12px;
  border-radius: 999px;
  font-size: 14px;
  user-select: none;
}
/* Tutorial a slide */
.tutorial-dialog{ position:relative; overflow:hidden; }
.tutorial-carousel{ position:relative; min-height: 140px; }
.tutorial-slide[hidden]{ display:none !important; }

.tutorial-arrow{
  position:absolute;
 bottom: 20px;
  width:38px; height:38px;
  display:grid; place-items:center;
  border-radius:999px;
  border:1px solid var(--panel-border);
  background:linear-gradient(180deg, var(--panel-1), var(--panel-2));
  color:var(--text);
  cursor:pointer;
  box-shadow: var(--shadow);
  user-select:none;
}
.tutorial-arrow.prev{ left:10px; }
.tutorial-arrow.next{ right:10px; }
.tutorial-arrow:disabled{ opacity:.5; cursor:default; }

.tutorial-dots{
  display:flex; gap:8px; justify-content:center; align-items:center;
  margin-top:12px;
}
.tutorial-dots button{
  width:8px; height:8px; border-radius:999px; border:none;
  background:#3a4168; cursor:pointer;
}
.tutorial-dots button[aria-current="true"]{
  width:22px; height:8px; border-radius:999px; background:var(--accent);
}

.big-symbol{
  font-size: clamp(42px, 10vw, 72px);
  line-height: 1;
  filter: drop-shadow(0 6px 16px rgba(0,0,0,.35));
}

/* X in alto a destra */
.tutorial-close{
  position:absolute; top:10px; right:10px;
  width:34px; height:34px; display:grid; place-items:center;
  border-radius:10px;
  border:1px solid var(--panel-border);
  background:linear-gradient(180deg, var(--panel-1), var(--panel-2));
  color:var(--muted);
  cursor:pointer;
}
/* --- Testo centrato e niente pallini nelle slide del tutorial --- */
#intro .tutorial-slide { text-align: center; }
#intro .tutorial-slide ul { 
  list-style: none; 
  padding: 0; 
  margin: 10px 0 0; 
}
#intro .tutorial-slide li { 
  margin: 8px 0; 
}
#intro .tutorial-slide h3{
  margin: 6px 0 10px; 
  font-size: 22px;
}
/* Close del popup Salvataggi (stile coerente col tutorial) */
.save-close{
  position:absolute; top:10px; right:10px;
  width:34px; height:34px; display:grid; place-items:center;
  border-radius:10px;
  border:1px solid var(--panel-border);
  background:linear-gradient(180deg,var(--panel-1),var(--panel-2));
  color:var(--muted);
  cursor:pointer;
}

/* Bottoni icona (Upload, Cestino) */
.icon-btn{
  width:36px; height:36px;
  display:grid; place-items:center;
  border-radius:10px;
  border:1px solid var(--panel-border);
  background:linear-gradient(180deg,var(--panel-1),var(--panel-2));
  color:var(--text);
  cursor:pointer;
  box-shadow:var(--shadow);
  font-size:18px; line-height:1;
}
.icon-btn:hover{ filter:brightness(1.05) }
.icon-btn:active{ transform:translateY(1px) }

</style>
</head>
<body class="theme-1">
<!-- ‚¨áÔ∏è AGGIUNGI QUESTA RIGA PRIMA DEL TUO <script> PRINCIPALE -->
<script src="sfx.js?v=5"></script>
<div class="wrap">
<div class="top">
  <!-- Logo a sinistra -->
  <div class="brand">
    <img src="skullory-logo.svg" alt="Skullory">
  </div>
 <div class="stats-container">
    <div class="stats">
      <span class="level-chip" id="levelChip">Livello: ‚Äî</span>
      <span class="level-chip" id="statusChip">Stato: ‚Äî</span>
      <span class="level-chip" id="moves" aria-live="polite">Mosse: 0</span>
      <span class="chip timer" id="timer" aria-live="polite">0:30</span>
      <span class="chip" id="score" aria-live="polite" style="color:#FFF44F">Punti: 0</span>
    </div>
  </div>

  <div class="grid" id="grid" aria-label="Griglia Slapmory"></div>
<!-- Pulsanti centrati sotto la griglia -->
<div class="controls controls-bottom">
  <button class="primary outline-btn" id="pause">‚è∏Ô∏è</button>
  <button class="primary outline-btn" id="save">üíæ</button>
  <button class="primary outline-btn" id="restart">üîÑ</button>

  <!-- ‚¨áÔ∏è nuovi -->
  <button class="primary outline-btn" id="muteMusic" title="Musica: on" aria-pressed="false">üéµ</button>
  <button class="primary outline-btn" id="muteSfx"   title="SFX: on"    aria-pressed="false">üîä</button>
</div>

<!-- Intro / Tutorial (carousel a 3 slide) -->
<div class="overlay hide" id="intro">
  <div class="dialog tutorial-dialog">
    <!-- X in alto a destra -->
    <button class="tutorial-close" id="intro-close" aria-label="Chiudi tutorial">‚úï</button>

    <h2 id="intro-title" style="margin-bottom:8px">Come si gioca</h2>

    <!-- Contenitore slide -->
    <div class="tutorial-carousel" aria-live="polite">
      <!-- Slide 1 -->
<div class="tutorial-slide" data-slide="0">
  <h3 style="color:#FFF44F">Obiettivo</h3>
  <ul>
    <li>Trova tutte le <b>coppie</b> ribaltando le carte, ma <b>occhio al tempo!</b></li>
<li><b>Sblocco livello</b>: completa lo stesso livello <b>3 volte di fila</b>!</li>
<li>Dopo lo sblocco resti sul livello <b>per fare punti</b>.</li>
<li><b>Al primo errore</b>, sali al livello successivo.</li>
  </ul>
</div>

<!-- Slide 2 (simboli grandi) -->
<div class="tutorial-slide" data-slide="1" hidden>
  <h3 style="color:#FFF44F">Carte speciali</h3>
  <div style="display:flex; gap:18px; align-items:center; justify-content:center; margin:10px 0 6px">
    <div class="big-symbol" aria-hidden="true">‚ö°</div>
    <div class="big-symbol" aria-hidden="true">üíÄ</div>
  </div>
  <ul>
    <li>‚ö° rimescola subito tutte le carte coperte (tranne üíÄ e ‚ö°).</li>
    <li>üíÄ se rivelato due volte: <b>sconfitta!</b></li>
  </ul>
</div>

<!-- Slide 3 -->
<div class="tutorial-slide" data-slide="2" hidden>
  <h3 style="color:#FFF44F">Bonus, penalit√† e punteggio</h3>
  <ul>
    <li><b>Bonus 1</b>: ogni coppia trovata = <b>+1s</b></li>
    <li><b>Bonus 2</b>: 2 coppie di fila entro 5s = <b>+5s</b></li>
    <li><b>Penalit√†</b>: ogni errore <b>‚àí1s</b></li>
    <li><b>Punteggio</b>: secondi risparmiati <b>x</b> efficienza mosse.</li>
  </ul>
</div>

    </div>

    <!-- Frecce laterali -->
    <button class="tutorial-arrow prev" id="intro-prev" aria-label="Slide precedente">‚Äπ</button>
    <button class="tutorial-arrow next" id="intro-next" aria-label="Slide successiva">‚Ä∫</button>

    <!-- Pallini -->
    <div class="tutorial-dots" id="intro-dots" role="tablist" aria-label="Pagine tutorial"></div>

    <!-- CTA: manteniamo l'id intro-play per compatibilit√† col tuo JS -->
    <div class="actions" style="margin-top:14px; display:flex; justify-content:center; gap:10px">
      <button class="primary" id="intro-play">Gioca</button>
    </div>
  </div>
</div>


<!-- Gestore Salvataggi (Modal) -->
<!-- Conferma Ricomincia -->
<div class="overlay" id="restartConfirm" aria-hidden="true">
  <div class="dialog">
    <h2>Ricominciare il livello?</h2>
    <p style="margin-top:4px; color:var(--muted)">Perderai lo stato del quadro corrente.</p>
    <div style="display:flex; gap:10px; justify-content:center; margin-top:8px">
      <button class="primary" id="restart-yes">S√¨, ricomincia</button>
      <button class="primary" id="restart-no" style="background:var(--bad); color:#fff">Annulla</button>
    </div>
  </div>
</div>
<div class="overlay" id="saveModal" aria-hidden="true">
  <div class="dialog" style="text-align:left; position:relative">
    <!-- X in alto a destra -->
    <button class="save-close" id="save-close" aria-label="Chiudi salvataggi">‚úï</button>

    <h2 style="text-align:center; margin-top:2px">Salvataggi</h2>

    <div id="saveList" style="max-height:46vh; overflow:auto; margin:8px 0 12px"></div>

<div id="saveControls" style="display:flex; gap:8px; align-items:center; margin-top:6px">
  <input id="saveName" placeholder="Nome partita‚Ä¶"
    style="width:150px; padding:10px 12px; border-radius:10px;
           border:1px solid var(--panel-border); background:var(--panel-2);
           color:var(--text)"/>
  <button class="primary" id="doSave">Salva</button>
</div>

    <p style="color:var(--muted); margin-top:10px">
      I salvataggi sono consentiti <b>solo a fine quadro</b> o <b>prima di iniziare</b> il prossimo.
    </p>
  </div>
</div>


<!-- Overlay di fine quadro -->
<div class="overlay" id="overlay">
  <div class="dialog">
    <h2 id="ov-title">Hai vinto!</h2>
    <p id="ov-sub">Tempo rimasto: ‚Äî</p>
    <button class="primary" id="ov-btn">Continua</button>
  </div>
</div>

<script>
(() => {
  const RED = 'üíÄ';
  const YELLOW = '‚ö°';
  const STORAGE_KEY = 'skullory_save_v1'; // legacy single-save (migrazione)
  const SAVES_KEY = 'skullory_saves_v2';   // multi-slot (v2: solo meta, niente stato carte)

const LEVELS = [
  // 3√ó3 (no centro) ‚Äî NUOVO
  {
    name: '3√ó3 (no centro)',
    side: 3,
    disabled: [4], // centro vuoto
    pairs: 3,
    red: 0,
    yellow: 2,
    timeMs: 20000,
    unlockMs: [20000, 15000, 10000],
    postDeltaSec: 1
  },

  // 3√ó3 base
  { name: '3√ó3', side: 3, disabled: [], pairs: 4, red: 1, yellow: 0,
    timeMs: 40000, unlockMs: [40000, 35000, 30000], postDeltaSec: 2 },

  // 4√ó4 (‚Äìangoli)
  { name: '4√ó4 (‚Äìangoli)', side: 4,
    disabled: [0,3,12,15],
    pairs: 5, red: 1, yellow: 1,
    timeMs: 45000, unlockMs: [45000, 40000, 35000], postDeltaSec: 2 },

  // 4√ó4 base
  { name: '4√ó4', side: 4, disabled: [], pairs: 7, red: 1, yellow: 1,
    timeMs: 60000, unlockMs: [60000, 55000, 50000], postDeltaSec: 2 },

  // 5√ó5 (caotico simm.) ‚Äî NUOVO
  { 
    name: '5√ó5 (caotico simm.)',
    side: 5,
    disabled: [1,3,5,9,12,15,19,21,23],
    pairs: 6,
    red: 1,
    yellow: 3,
    timeMs: 65000,
    unlockMs: [65000, 60000, 55000],
    postDeltaSec: 3
  },

  // 5√ó5 (cornice) ‚Äî NUOVO
  {
    name: '5√ó5 (cornice)',
    side: 5,
    disabled: [0,4,12,20,24],
    pairs: 9,
    red: 1,
    yellow: 1,
    timeMs: 70000,
    unlockMs: [70000, 65000, 60000],
    postDeltaSec: 3
  },

  // 5√ó5 (‚Äìangoli)
  { name: '5√ó5 (‚Äìangoli)', side: 5,
    disabled: [0,4,20,24],
    pairs: 9, red: 1, yellow: 2,
    timeMs: 70000, unlockMs: [70000, 65000, 60000], postDeltaSec: 3 },

  // 5√ó5 base
  { name: '5√ó5', side: 5, disabled: [], pairs: 12, red: 1, yellow: 2,
    timeMs: 80000, unlockMs: [80000, 75000, 70000], postDeltaSec: 3 },

  // 6√ó6 (croce) ‚Äî NUOVO
  {
    name: '6√ó6 (croce)',
    side: 6,
    disabled: [0,1,4,5,6,11,24,29,30,31,34,35],
    pairs: 10,
    red: 1,
    yellow: 3,
    timeMs: 90000,
    unlockMs: [90000, 85000, 80000],
    postDeltaSec: 3
  },

  // 6√ó6 (cornici+centro) ‚Äî NUOVO
  { 
    name: '6√ó6 (cornici+centro)',
    side: 6,
    disabled: [0, 5, 30, 35, 14, 15, 20, 21], // angoli + centro 2√ó2
    pairs: 12,
    red: 1,
    yellow: 3,
    timeMs: 112000,
    unlockMs: [112000, 108000, 104000],
    postDeltaSec: 4
  },

  // 6√ó6 (‚Äìangoli)
  { name: '6√ó6 (‚Äìangoli)', side: 6,
    disabled: [0,5,30,35],
    pairs: 14, red: 1, yellow: 3,
    timeMs: 95000, unlockMs: [95000, 90000, 85000], postDeltaSec: 3 },

  // 6√ó6 base
  { name: '6√ó6', side: 6, disabled: [], pairs: 17, red: 1, yellow: 3,
    timeMs: 100000, unlockMs: [100000, 95000, 90000], postDeltaSec: 3 }
];


  const EMOJI = ['üê∂','üê±','ü¶ä','üêº','üêµ','üêØ','ü¶Å','üê∏','üê®','ü¶Ñ','üê∑','üêπ','üêô','ü¶â','ü¶ã','üêù','üê¢','üê†','üçé','üçâ','üçá','üçí','üçì','üçë','ü•ë','üåΩ','ü•ï','üç©','üç™','üç∞','üçî','üçï','üç£','üç§','üçú','üçø','üêã','ü¶≠','ü¶Ä','üêû','üêç','ü¶ú','ü¶¢','üêé','üê´','ü¶í','üêø','ü¶î','ü¶©','üê¨','üê≥','ü¶¶','üê°','üêå','üçã','üçä','ü´ê','ü••','ü•≠','ü•í','ü´ë','ü•î','üå∂','üçÑ','üßÑ','üßÖ','üßÄ','ü•®','ü•Ø','ü•û','ü•™','ü•ô','ü•ó','ü•ò','ü•ü','üçÆ','üç´','üçπ','üßã','üç∫','‚òï','ü•õ','üç∑','üçµ'];

 // --- SFX: inizializza al primo gesto utente ---
// --- SFX: inizializza al primo gesto utente ---
function ensureSfx(){
  if (window.__sfxReady) return;
  window.__sfxReady = true;

  try {
    // inizializza effetti
    SFX.init();
SFX.setMasterVolume(parseFloat(localStorage.getItem('skullory_sfx_vol') || '0.8'));
BGM.setVolume(parseFloat(localStorage.getItem('skullory_bgm_vol') || '0.5'));


    // segna interazione utente e prova a far partire la musica
    if (window.BGM){
      BGM._markInteracted();
      BGM.start();
      BGM.updateUi?.(); // se esiste, aggiorna icona
    }

    // Avvolgi SFX.play una sola volta per rispettare i mute
    if (!SFX.__wrapped){
      const origPlay = SFX.play.bind(SFX);
      SFX.play = (name, opts = {}) => {
        if (name === 'bgm') {
          // (se mai userai SFX per la musica)
          if (musicMuted) return null;
          if (opts.volume == null) opts.volume = 0.18;
          opts.loop = (opts.loop !== false);
        } else {
          if (sfxMuted) return null;
        }
        return origPlay(name, opts);
      };
      SFX.__wrapped = true;
    }

    // Applica stato iniziale mute ai controlli/UI
    setMusicMuted(musicMuted);
    setSfxMuted(sfxMuted);
    refreshAudioButtons();

  } catch(e){
    window.__sfxReady = false;
    // opzionale: console.error(e);
  }
}

function setMusicMuted(v){
  musicMuted = !!v;
  localStorage.setItem('skullory.musicMuted', JSON.stringify(musicMuted));

  if (window.BGM) {
    if (musicMuted) {
      // Muto musica = disabilita e ferma
      try { BGM.setEnabled(false); } catch(_) {}
      try { BGM.stop(); } catch(_) {}
    } else {
      // Riattiva musica
      try { BGM.setEnabled(true); } catch(_) {}
      try { BGM.start(); } catch(_) {}
    }
  }

  refreshAudioButtons();
}


function setSfxMuted(v){
  sfxMuted = !!v;
  localStorage.setItem('skullory.sfxMuted', JSON.stringify(sfxMuted));

  // Se la tua SFX ha un'API dedicata, usala
  if (window.SFX && SFX.setSfxMuted) SFX.setSfxMuted(sfxMuted);

  refreshAudioButtons();
}

const grid = document.getElementById('grid');
  const movesEl = document.getElementById('moves');
  const timerEl = document.getElementById('timer');
  const restartBtn = document.getElementById('restart');
  const overlay = document.getElementById('overlay');
  const ovTitle = document.getElementById('ov-title');
  const ovSub = document.getElementById('ov-sub');
  const ovBtn = document.getElementById('ov-btn');
  const pauseBtn = document.getElementById('pause');
  const saveBtn = document.getElementById('save');
  const levelChip = document.getElementById('levelChip');
  const statusChip = document.getElementById('statusChip');
  const scoreChip = document.getElementById('score');
const muteMusicBtn = document.getElementById('muteMusic');
const muteSfxBtn   = document.getElementById('muteSfx');
if (muteMusicBtn) muteMusicBtn.addEventListener('click', () => setMusicMuted(!musicMuted));
if (muteSfxBtn)   muteSfxBtn.addEventListener('click',   () => setSfxMuted(!sfxMuted));

let musicMuted = JSON.parse(localStorage.getItem('skullory.musicMuted') || 'false');
let sfxMuted   = JSON.parse(localStorage.getItem('skullory.sfxMuted')   || 'false');
refreshAudioButtons();

const restartConfirm = document.getElementById('restartConfirm');
const restartYes = document.getElementById('restart-yes');
const restartNo = document.getElementById('restart-no');
  // Save modal refs
  const saveModal = document.getElementById('saveModal');
  const saveList = document.getElementById('saveList');
  const saveNameInput = document.getElementById('saveName');
const doSaveBtn = document.getElementById('doSave');
const saveClose = document.getElementById('save-close');

  const intro = document.getElementById('intro');
  const introBtn = document.getElementById('intro-play');

// ===== Tutorial a 3 slide =====
let currentSlide = 0;
const slides = [];   // verr√† riempito dopo il DOM build
let dotsWrap, prevBtn, nextBtn, closeBtn;

function buildTutorialRefs(){
  // prendi riferimenti dopo che l'HTML √® nel DOM
  dotsWrap = document.getElementById('intro-dots');
  prevBtn  = document.getElementById('intro-prev');
  nextBtn  = document.getElementById('intro-next');
  closeBtn = document.getElementById('intro-close');

  // colleziona le slide
  document.querySelectorAll('#intro .tutorial-slide').forEach(s => slides.push(s));

  // crea i pallini
  dotsWrap.innerHTML = '';
  slides.forEach((_, i) => {
    const d = document.createElement('button');
    d.setAttribute('aria-label', `Vai alla slide ${i+1}`);
    d.addEventListener('click', () => goToSlide(i));
    dotsWrap.appendChild(d);
  });

  // frecce
  prevBtn.addEventListener('click', () => goToSlide(currentSlide - 1));
  nextBtn.addEventListener('click', () => goToSlide(currentSlide + 1));

  // chiudi (nasconde solo il tutorial; il gioco parte quando clicchi "Gioca" o inizi a giocare)
  closeBtn.addEventListener('click', () => hideIntro());

  // tastiera: frecce ‚Üê ‚Üí per cambiare slide
  document.addEventListener('keydown', (e) => {
    if (intro.classList.contains('hide')) return; // attivo solo quando il tutorial √® visibile
    if (e.key === 'ArrowLeft')  goToSlide(currentSlide - 1);
    if (e.key === 'ArrowRight') goToSlide(currentSlide + 1);
  });
}

function goToSlide(i){
  currentSlide = Math.max(0, Math.min(slides.length - 1, i));
  slides.forEach((el, idx) => {
    if (idx === currentSlide) el.removeAttribute('hidden');
    else el.setAttribute('hidden', '');
  });

  // aggiorna pallini
  Array.from(dotsWrap.children).forEach((dot, idx) => {
    dot.setAttribute('aria-current', idx === currentSlide ? 'true' : 'false');
  });

  // disabilita frecce agli estremi
  prevBtn.disabled = (currentSlide === 0);
  nextBtn.disabled = (currentSlide === slides.length - 1);
}

 function showIntro(){
  // mostra l‚Äôoverlay
  intro.classList.remove('hide');
  intro.classList.add('show');

  // inizializza i riferimenti del tutorial SOLO la prima volta
  if (slides.length === 0) buildTutorialRefs();
  // vai sempre alla prima slide quando si apre
  goToSlide(0);
}

  function hideIntro(){ intro.classList.add('hide'); intro.classList.remove('show'); }

  let state;
  let currentLevelIdx = 0;
  let totalScore = 0;
  let themeIndex = 1;
let frameBaseScore = 0;  // punteggio di partenza del quadro corrente


let __bgmHandle = null;  // terr√† l‚Äôhandle della musica (se SFX.play lo restituisce)

function refreshAudioButtons(){
  if (muteMusicBtn){
    muteMusicBtn.textContent = musicMuted ? 'üö´üéµ' : 'üéµ';
    muteMusicBtn.title = musicMuted ? 'Musica: off' : 'Musica: on';
    muteMusicBtn.setAttribute('aria-pressed', musicMuted);
  }
  if (muteSfxBtn){
    muteSfxBtn.textContent = sfxMuted ? 'üîá' : 'üîä';
    muteSfxBtn.title = sfxMuted ? 'SFX: off' : 'SFX: on';
    muteSfxBtn.setAttribute('aria-pressed', sfxMuted);
  }
}

  let pendingCheck = null; // id timeout per checkPair
let tapBuffer = [];
const TAP_BUFFER_MAX = 2; // massimo 2 tocchi accodati
  let progress = LEVELS.map(L => ({ streak: 0, unlocked: false, baseTimeMs: L.unlockMs[0], postUnlockWins: 0 }));

  function setCols(n){ document.documentElement.style.setProperty('--cols', n); }
  function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } return a; }
  function fmt(ms){ const s = Math.max(0, Math.floor(ms/1000)); const mm = Math.floor(s/60), ss = s%60; return `${mm}:${ss.toString().padStart(2,'0')}`; }

  function rotateTheme(){
    themeIndex = themeIndex % 10 + 1; // 1..10
    const b = document.body;
    b.className = (b.className || '').replace(/\btheme-\d+\b/g, '').trim();
    b.classList.add('theme-' + themeIndex);
  }

  function updateStatusChip(){
    const p = progress[currentLevelIdx];
    const baseSec = Math.max(0, p.baseTimeMs) / 1000 | 0;
    if(!p.unlocked){
      statusChip.textContent = `Sbloc ${p.streak}/3 ¬∑ ${baseSec}s`;
    } else {
      statusChip.textContent = `Grind ${p.postUnlockWins} ¬∑ ${baseSec}s`;
    }
  }

  function buildDeck(level){
    const pool = EMOJI.slice();
    const unique = shuffle(pool).slice(0, level.pairs);
    const pairs = unique.concat(unique);
    const specials = [ ...Array(level.red).fill(RED), ...Array(level.yellow).fill(YELLOW) ];
    const deck = pairs.concat(specials);
    return shuffle(deck);
  }

  // --- MOSSE & PUNTEGGIO: funzioni helper ---
  function freeMovesFor(level){ return level.side * level.side; }
  function efficiencyMultiplier(moves, free){
    const delta = moves - free;
    if (delta <= 0){
      const bonus = Math.min(0.30, 0.02 * (-delta));
      return 1 + bonus;
    } else {
      return Math.max(0.5, 1 - 0.05 * delta);
    }
  }
  function roundNearest(n){ return Math.round(n); }
  function updateScoreChip(){ if(scoreChip) scoreChip.textContent = `Punti: ${totalScore}`; }

  function canSaveNow(){
    // Consentito: overlay visibile (fine quadro) OPPURE stato appena inizializzato prima di qualsiasi mossa
    const endOfFrame = overlay.classList.contains('show');
    const freshStart = !state.running && state.moves === 0 && state.matched === 0;
    return endOfFrame || freshStart;
  }
  function updateSaveButton(){
    if(!saveBtn) return;
    const ok = canSaveNow();
    saveBtn.disabled = !ok;
    saveBtn.style.opacity = ok ? '1' : '0.6';
    saveBtn.title = ok ? 'Salva' : 'Salva disponibile solo a fine quadro o prima di iniziare';
  }

  function init(levelIdx = currentLevelIdx){
    rotateTheme();

    const L = LEVELS[levelIdx];
    currentLevelIdx = levelIdx;
    setCols(L.side);
    levelChip.textContent = `Livello: ${levelIdx+1}/${LEVELS.length}`;
    updateStatusChip();

    if (pendingCheck) { clearTimeout(pendingCheck); pendingCheck = null; }

    state = {
      level: L,
      deck: buildDeck(L),
      flipped: [], matched: 0, moves: 0,
      running: false, startTs: 0,
      leftMs: Math.max(0, progress[levelIdx].baseTimeMs),
      lock: false,
      redFlips: 0, yellowFlips: 0,
      paused: false, streak: 0, lastMatchTime: 0, totalBonusMs: 0,
      deadlineTs: 0,
      pauseLeftMs: 0
    };

    grid.innerHTML = '';
    const frag = document.createDocumentFragment();

    const disabled = new Set((L.disabled || []).map(Number));
    let deckPtr = 0;

    for(let i=0;i<L.side*L.side;i++){
      if (disabled.has(i)){
        const placeholder = document.createElement('div');
        placeholder.className = 'card placeholder';
        placeholder.setAttribute('aria-hidden','true');
        frag.appendChild(placeholder);
        continue;
      }

      const symbol = state.deck[deckPtr++]; // usa il deck solo per slot attivi
      const card = document.createElement('div');
      card.className = 'card';
      card.dataset.index = i;
      card.dataset.symbol = symbol;
      card.setAttribute('data-state','hidden');
      card.setAttribute('role','button');
      card.setAttribute('tabindex','0');
      card.setAttribute('aria-label','Carta di Slapmory');

      const inner = document.createElement('div'); inner.className = 'inner';
      const back  = document.createElement('div'); back.className  = 'face back';
      const front = document.createElement('div'); front.className = 'face front';
      const sym   = document.createElement('div'); sym.className   = 'symbol'; sym.textContent = symbol;
      front.appendChild(sym); inner.append(back, front); card.append(inner);

      card.addEventListener('click', () => onCardClick(card));
      card.addEventListener('keydown', (ev) => { if(ev.key==='Enter'||ev.key===' '){ ev.preventDefault(); onCardClick(card); } });

      frag.appendChild(card);
    }

    grid.appendChild(frag);
tapBuffer = [];
    updateHud();
    updateScoreChip();
    hideOverlay();
    updateSaveButton();
  }

  function startTimer(){
    if(state.paused) return;
    if(state.running) return;
    state.running = true;
frameBaseScore = totalScore;  // snapshot del totale prima di iniziare il quadro
    const now = performance.now();
    state.startTs = now;
    const base = Math.max(0, progress[currentLevelIdx].baseTimeMs);
    state.deadlineTs = now + base;
    tick();
    updateSaveButton(); // durante il quadro il salvataggio non √® consentito
  }

  function tick(){
    if(!state.running || state.paused) return;
    const now = performance.now();
    state.leftMs = Math.max(0, state.deadlineTs - now);
    updateTime();
    if(state.leftMs<=0){ state.running=false; lose('Tempo scaduto ‚è∞'); return; }
    requestAnimationFrame(tick);
  }

  function updateTime(){ timerEl.textContent = fmt(state.leftMs); }
  function updateHud(){
    movesEl.textContent = `Mosse: ${state.moves}`;
    timerEl.textContent = fmt(state.leftMs);
    updateStatusChip();
    updateScoreChip();
  }

  function onCardClick(card){
ensureSfx(); // sblocca audio al primo tocco
SFX.play('tap', { volume:.5, rate: 0.98 + Math.random()*0.04 });
    if (state.paused) { flashMessage('In pausa ‚ñ∂Ô∏è'); return; }
  if (state.lock) {
  // Accoda il tap, se sensato, cos√¨ lo eseguiamo appena si sblocca
  if (tapBuffer.length < TAP_BUFFER_MAX &&
      card.dataset.state !== 'matched' &&
      card.dataset.state !== 'revealed') {
    tapBuffer.push(card);
  }
  return;
}
    if(card.dataset.state === 'matched' || card.dataset.state === 'revealed') return;
    startTimer();

    flip(card, true);
SFX.play('flip', { volume:.75, rate: 0.96 + Math.random()*0.08 });

    state.flipped.push(card);

    if(card.dataset.symbol === RED){
      state.redFlips++;
SFX.play('skull', { volume:.9, rate: 0.98 });

      if(state.redFlips >= 2){
        setTimeout(() => lose('Oh no! üíÄ', 'Hai rivelato il teschio due volte.'), 220);
        return;
      }
    }
if(card.dataset.symbol === YELLOW){
  state.yellowFlips++;
  flashMessage('Shuffle!');
  reshuffleHiddenNonSpecial(); 
}


    if(state.flipped.length === 2){
      state.moves++;
      movesEl.textContent = `Mosse: ${state.moves}`;
      checkPair();
    }
  }

  function flip(card, reveal){ card.setAttribute('data-state', reveal ? 'revealed' : 'hidden'); }

  function checkPair(){
    const [a, b] = state.flipped;
    if(!a || !b) return;
    const specialInvolved = (s => s===RED || s===YELLOW);
    const match = !specialInvolved(a.dataset.symbol) && !specialInvolved(b.dataset.symbol) && (a.dataset.symbol === b.dataset.symbol);
    state.lock = true;

    if (pendingCheck) { clearTimeout(pendingCheck); pendingCheck = null; }
    pendingCheck = setTimeout(() => {
      if (state.paused) {
        flip(a,false); flip(b,false);
        state.flipped.length = 0;
        state.lock = false;
// Se l'utente ha "tappato" durante il lock, esegui 1 tap in coda
if (tapBuffer.length) {
  const next = tapBuffer.shift();
  setTimeout(() => onCardClick(next), 0);
}
        pendingCheck = null;
        return;
      }

      if(match){
        state.streak++;
        const now = performance.now();
        state.deadlineTs += 1000;
        state.leftMs = Math.max(0, state.deadlineTs - now);
        updateTime();
        flashMessage('+1s');
SFX.play('bonus1', { volume:.85, rate: 1.02 });


        if(state.streak >= 2 && (now - state.lastMatchTime) < 5000){
          const now2 = performance.now();
          state.deadlineTs += 5000;
          state.leftMs = Math.max(0, state.deadlineTs - now2);
          updateTime();
          flashMessage('+5s Bonus!');
SFX.play('bonus5', { volume:1 });

        }
        state.lastMatchTime = now;

        a.setAttribute('data-state','matched');
        b.setAttribute('data-state','matched');
spawnMatchStars(a);
spawnMatchStars(b);
SFX.play('ok', { volume:.9, rate: 0.98 });

        state.matched++;
        if(state.matched >= state.level.pairs){ win(); }
      } else {
        state.streak = 0;
        const now = performance.now();
        state.deadlineTs = state.deadlineTs - 1000; // penalit√† di 1 secondo;
        state.leftMs = Math.max(0, state.deadlineTs - now);
        updateTime();
        flashMessage('-1s');
SFX.play('fail', { volume:.9 });

        flip(a,false); flip(b,false);
      }
      state.flipped.length = 0;
      state.lock = false;
      pendingCheck = null;
    }, match ? 120 : 420);
  }

  function reshuffleHiddenNonSpecial(){
    const cards = Array.from(grid.querySelectorAll('.card'));
    const targets = cards.filter(c => c.getAttribute('data-state') === 'hidden' && c.dataset.symbol !== 'üíÄ' && c.dataset.symbol !== '‚ö°');
    if(targets.length <= 1) return;
    const symbols = targets.map(c => c.dataset.symbol);
    for(let i=symbols.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [symbols[i],symbols[j]]=[symbols[j],symbols[i]]; }
    targets.forEach((c,i) => {
      c.dataset.symbol = symbols[i];
      c.querySelector('.symbol').textContent = symbols[i];
    });
    flashMessage('üîÄ Rimescolo!');
SFX.play('reshuffle', { volume:.9 });

  }
function spawnMatchStars(card){
  // Contenitore
  const wrap = document.createElement('div');
  wrap.className = 'match-stars';
  card.appendChild(wrap);

  // Crea 6 stelline con direzioni diverse
  const N = 6;
  for(let i=0;i<N;i++){
    const s = document.createElement('span');
    s.className = 'star';
    s.textContent = '‚ú®';
    // offset casuali (px) verso fuori
    const r = 26 + Math.random()*18;                 // raggio
    const ang = (Math.PI*2/N)*i + Math.random()*0.7; // angolo
    const dx = Math.cos(ang)*r;
    const dy = Math.sin(ang)*r;
    s.style.setProperty('--dx', `${dx}px`);
    s.style.setProperty('--dy', `${dy}px`);
    wrap.appendChild(s);
  }

  // Ripulisci dopo l‚Äôanimazione
  setTimeout(() => wrap.remove(), 650);
}

  function win(){
    state.running = false;
// in win()
SFX.play('win', { volume:1.0 });

    const secondsLeft = Math.floor(state.leftMs/1000);
    const free = freeMovesFor(state.level);
    const mult = efficiencyMultiplier(state.moves, free);
const frameScore = roundNearest(secondsLeft * mult);
// totale robusto: base all'inizio del quadro + punti del quadro
totalScore = frameBaseScore + frameScore;
updateScoreChip();
    const L = LEVELS[currentLevelIdx];
    const p = progress[currentLevelIdx];

const detailRow = `Tempo: ${secondsLeft}s ¬∑ Mosse: ${state.moves}<br>
Punti quadro = <b>${frameScore}</b><br>
Punteggio parziale: <b>${totalScore}</b>`;


    if(!p.unlocked){
      p.streak += 1;
      if(p.streak < 3){
        p.baseTimeMs = L.unlockMs[p.streak];
        showOverlay('Quadro completato ‚úîÔ∏è', `Sblocco: ${p.streak}/3<br>${detailRow}<br><small>Prossimo tentativo: tempo base ${Math.floor(p.baseTimeMs/1000)}s</small>`);
        ovBtn.textContent = 'Continua a giocare';
        ovBtn.onclick = () => { hideOverlay(); init(currentLevelIdx); };
      } else {
        p.unlocked = true;
        p.postUnlockWins = 0;
        showOverlay('Sblocco conquistato! üèÜ', `Hai completato 3 quadri di fila.<br>Ora resta su questo livello e fai punti!<br>${detailRow}`);
        ovBtn.textContent = 'Continua a giocare';
        ovBtn.onclick = () => { hideOverlay(); init(currentLevelIdx); };
      }
    } else {
      p.postUnlockWins += 1;
      p.baseTimeMs = Math.max(0, p.baseTimeMs - L.postDeltaSec*1000);
      showOverlay('Quadro completato ‚úîÔ∏è', `Post-sblocco: ${p.postUnlockWins} completati<br>${detailRow}<br><small>Prossimo tentativo: tempo base ${Math.floor(p.baseTimeMs/1000)}s</small>`);
      ovBtn.textContent = 'Continua a giocare';
      ovBtn.onclick = () => { hideOverlay(); init(currentLevelIdx); };
    }
    updateSaveButton();
  }

  function lose(title, sub){
    const L = LEVELS[currentLevelIdx];
    const p = progress[currentLevelIdx];
    state.running = false;
SFX.play('lose', { volume:1.0 });
    if(p.unlocked){
      const next = currentLevelIdx + 1;
      if(next < LEVELS.length){
        showOverlay('Passi al livello successivo ‚ÜóÔ∏è', (sub || 'Hai perso questo quadro, ma il passaggio era gi√† conquistato.') + `<br><small>Punteggio parziale: ${totalScore}</small>`);
        ovBtn.textContent = 'Vai al prossimo livello';
        ovBtn.onclick = () => { hideOverlay(); init(next); };
      } else {
        showOverlay('Fine partita', (sub || 'Hai terminato l‚Äôultimo livello.') + `<br><b>Punteggio finale: ${totalScore} punti</b>`);
        ovBtn.textContent = 'Gioca ancora';
        ovBtn.onclick = () => { totalScore=0; progress = LEVELS.map(L => ({ streak:0, unlocked:false, baseTimeMs:L.unlockMs[0], postUnlockWins:0 })); hideOverlay(); init(0); updateScoreChip(); };
      }
} else {
  // ‚ùå hai perso PRIMA dello sblocco ‚Üí azzera tentativi e punteggio
  p.streak = 0;
  p.baseTimeMs = L.unlockMs[0];

totalScore = 0;         // ‚Üê azzera punteggio
frameBaseScore = 0;     // ‚Üê allinea la base
updateScoreChip();
  showOverlay(
    title || 'Hai perso',
    (sub || 'Ritenta!') +
    `<br><small>Sblocco: ${p.streak}/3 ‚Äì tempo base ripristinato a ${Math.floor(p.baseTimeMs/1000)}s</small>`
  );
  ovBtn.textContent = 'Riprova questo livello';
  ovBtn.onclick = () => { hideOverlay(); init(currentLevelIdx); };
}

    updateSaveButton();
  }

  function showOverlay(title, sub){ ovTitle.textContent = title; ovSub.innerHTML = sub; overlay.classList.add('show'); updateSaveButton(); }
  function hideOverlay(){ overlay.classList.remove('show'); updateSaveButton(); }
function openRestartConfirm(){
  // opzionale: metti in pausa mentre chiedi conferma
  // if (state && state.running && !state.paused) togglePause();

  restartConfirm.classList.add('show');
  restartConfirm.setAttribute('aria-hidden','false');
}

function closeRestartConfirm(){
  restartConfirm.classList.remove('show');
  restartConfirm.setAttribute('aria-hidden','true');

  // opzionale: se avevi messo in pausa automaticamente, puoi riavviare
  // if (state && state.paused && state.pauseLeftMs > 0) togglePause();
}
  function flashMessage(text){
    const msg = document.createElement('div');
    msg.className = 'flash-msg';
    msg.textContent = text;
    document.body.appendChild(msg);
   setTimeout(() => msg.remove(), 1500);
  }

  // ===== Multi-slot Saves (solo meta, niente stato del quadro) =====
  function readSaves(){
    try{ const raw = localStorage.getItem(SAVES_KEY); return raw ? JSON.parse(raw) : []; }catch(e){ return []; }
  }
  function writeSaves(list){ try{ localStorage.setItem(SAVES_KEY, JSON.stringify(list)); }catch(e){} }
  function upsertSave(name, payload){
    const list = readSaves();
    const idx = list.findIndex(s => s && s.name === name);
    const entry = { name, when: Date.now(), data: payload };
    if(idx>=0) list[idx] = entry; else list.push(entry);
    writeSaves(list);
  }
  function deleteSave(name){ writeSaves(readSaves().filter(s => s && s.name !== name)); }

  function buildPayload(){
    // Versione 3: salviamo SOLO metadati per ripartire da inizio quadro
    return {
      version: 3,
      when: Date.now(),
      themeIndex,
      totalScore,
      currentLevelIdx,
      progress
    };
  }
  function loadPayload(data){
    if(!data) return false;
    themeIndex = data.themeIndex ?? themeIndex;
    totalScore = data.totalScore ?? 0;
    currentLevelIdx = data.currentLevelIdx ?? 0;
    if (Array.isArray(data.progress)) progress = data.progress;

    // Avvia sempre un QUADRO NUOVO non in pausa
    init(currentLevelIdx);
frameBaseScore = totalScore;   // la prossima vittoria partir√† da questo totale
    const b = document.body;
    b.className = (b.className || '').split(' ').filter(c => !c.startsWith('theme-')).join(' ');
    b.classList.add('theme-' + themeIndex);

    state.paused = false; // non in pausa
    state.running = false; // fermo finch√© il giocatore non clicca
    pauseBtn.textContent = '‚è∏Ô∏è';
    updateHud();
    updateSaveButton();
    return true;
  }

  // ===== Save Modal =====
  function openSaveManager(){
    if(!canSaveNow()){
      flashMessage('üíæ Salva solo a fine quadro o prima di iniziare');
      return;
    }
    renderSaveList();
const sc = document.getElementById('saveControls');
if (sc) sc.style.display = '';

    saveModal.classList.add('show');
    saveModal.setAttribute('aria-hidden','false');
    saveNameInput.value = '';
    saveNameInput.focus();
  }
  function closeSaveManager(){
    saveModal.classList.remove('show');
    saveModal.setAttribute('aria-hidden','true');
  }
  function renderSaveList(){
    const list = readSaves().sort((a,b)=> (b.when||0)-(a.when||0));
    if(!list.length){ saveList.innerHTML = '<div style="color:var(--muted)">Nessun salvataggio.</div>'; return; }
    saveList.innerHTML = '';
    list.forEach(entry => {
      const row = document.createElement('div');
row.className = 'save-row';
      row.style.display = 'grid';
      row.style.gridTemplateColumns = '1fr auto auto';
      row.style.gap = '8px';
      row.style.alignItems = 'center';
      row.style.padding = '6px 0';
      const name = document.createElement('div');
      const d = new Date(entry.when||Date.now());
      name.innerHTML = `<b>${entry.name}</b><br><small>${d.toLocaleString()}</small>`;
const loadBtn = document.createElement('button');
loadBtn.className = 'icon-btn';
loadBtn.innerHTML = 'üì§';           // Upload
loadBtn.title = 'Carica questo salvataggio';
loadBtn.setAttribute('aria-label','Carica questo salvataggio');

const delBtn = document.createElement('button');
delBtn.className = 'icon-btn';
delBtn.innerHTML = 'üóëÔ∏è';          // Cestino
delBtn.title = 'Elimina questo salvataggio';
delBtn.setAttribute('aria-label','Elimina questo salvataggio');

      loadBtn.onclick = () => { loadPayload(entry.data); closeSaveManager(); flashMessage('üìÇ Caricato: '+entry.name); };
delBtn.onclick = () => {
  // Pulisci eventuali conferme aperte
  document.querySelectorAll('.inline-confirm').forEach(el => el.remove());

  // Nascondi tutte le altre righe tranne questa
  const rows = saveList.querySelectorAll('.save-row');
  rows.forEach(r => { if (r !== row) r.style.display = 'none'; });

  // Nascondi temporaneamente la toolbar "Nome + Salva + Chiudi"
  const toolbar = doSaveBtn ? doSaveBtn.parentElement : null;
  const restoreToolbar = () => { if (toolbar) toolbar.style.display = ''; };
  if (toolbar) toolbar.style.display = 'none';

  // Conferma inline
  const wrap = document.createElement('div');
  wrap.className = 'inline-confirm';
  wrap.style.display = 'flex';
  wrap.style.gap = '8px';
  wrap.style.alignItems = 'center';
  wrap.style.gridColumn = '1 / -1';
  wrap.style.marginTop = '6px';
  wrap.style.padding = '8px 10px';
  wrap.style.border = '1px solid var(--panel-border)';
  wrap.style.borderRadius = '10px';
  wrap.style.background = 'linear-gradient(180deg,var(--panel-1),var(--panel-2))';
  wrap.innerHTML = `
    <span>Eliminare <b>${entry.name}</b>?</span>
    <div style="margin-left:auto; display:flex; gap:8px">
      <button class="primary" id="c-yes">S√¨, elimina</button>
      <button class="primary" id="c-no" style="background:var(--bad); color:#fff">Annulla</button>
    </div>
  `;

  row.after(wrap);

  // Conferma
  wrap.querySelector('#c-yes').onclick = () => {
    deleteSave(entry.name);
    // Ripristina vista completa e toolbar ricaricando la lista
    renderSaveList();
    restoreToolbar();
  };

  // Annulla
  wrap.querySelector('#c-no').onclick = () => {
    wrap.remove();
    // Ri-mostra tutte le righe
    rows.forEach(r => { r.style.display = ''; });
    restoreToolbar();
  };
};


      row.append(name, loadBtn, delBtn);
      saveList.appendChild(row);
    });
  }

  // ===== Event Listeners =====
  if(introBtn){ introBtn.addEventListener('click', () => { ensureSfx();
hideIntro(); }); }
  restartBtn.addEventListener('click', () => {
  openRestartConfirm();
});
if (restartYes) {
  restartYes.addEventListener('click', () => {
    closeRestartConfirm();
    hideOverlay();

    // üîÅ Nuova partita da zero
    totalScore = 0;                           // azzera punteggio
frameBaseScore = 0;            // allinea la base quando riparti da zero
    progress = LEVELS.map(L => ({             // azzera progressi/sblocchi
      streak: 0, unlocked: false, baseTimeMs: L.unlockMs[0], postUnlockWins: 0
    }));
    updateScoreChip();

    init(0);                                  // riparti dal livello 0
  });
}

if (restartNo) {
  restartNo.addEventListener('click', () => {
    closeRestartConfirm();    // annulla e chiudi
  });
}

  pauseBtn.addEventListener('click', togglePause);
  if(saveBtn){ saveBtn.addEventListener('click', openSaveManager); }
  if (doSaveBtn) {
    let overwritePrompt = null;

    doSaveBtn.addEventListener('click', () => {
      const nm = (saveNameInput.value || '').trim();
      if (!nm) { flashMessage('Inserisci un nome'); return; }
      if (!canSaveNow()) { flashMessage('Puoi salvare solo a fine quadro o prima di iniziare'); return; }

      const exists = readSaves().some(s => s && s.name === nm);

      if (exists && !overwritePrompt) {
        overwritePrompt = document.createElement('div');
        overwritePrompt.setAttribute('role', 'dialog');
        overwritePrompt.setAttribute('aria-label', 'Conferma sovrascrittura salvataggio');
        overwritePrompt.style.marginTop = '8px';
        overwritePrompt.style.padding = '10px';
        overwritePrompt.style.background = 'var(--panel-1)';
        overwritePrompt.style.border = '1px solid var(--panel-border)';
        overwritePrompt.style.borderRadius = '12px';
        overwritePrompt.innerHTML = `
          <div style="margin-bottom:8px; color:var(--muted)">
            Sovrascrivere <b>${nm}</b>?
          </div>
          <div style="display:flex; gap:8px; justify-content:flex-end">
            <button class="primary" id="ow-yes" tabindex="0">S√¨</button>
            <button class="primary" id="ow-no" style="background:var(--bad); color:#fff">No</button>
          </div>
        `;

        saveNameInput.parentElement.parentElement.appendChild(overwritePrompt);

        const yesBtn = overwritePrompt.querySelector('#ow-yes');
        const noBtn  = overwritePrompt.querySelector('#ow-no');

        requestAnimationFrame(() => yesBtn && yesBtn.focus());

        yesBtn.onclick = () => {
          upsertSave(nm, buildPayload());
          flashMessage('üíæ Sovrascritto: ' + nm);
          renderSaveList();
          saveNameInput.value = '';
          overwritePrompt.remove();
          overwritePrompt = null;
        };

        noBtn.onclick = () => {
          overwritePrompt.remove();
          overwritePrompt = null;
        };

        setTimeout(() => {
          if (overwritePrompt) {
            overwritePrompt.remove();
            overwritePrompt = null;
          }
        }, 5000);

        return;
      }

      upsertSave(nm, buildPayload());
      flashMessage('üíæ Salvato: ' + nm);
      renderSaveList();
      saveNameInput.value = '';
    });
  }

 if (saveClose){ saveClose.addEventListener('click', closeSaveManager); }

  // scorciatoia Ctrl/‚åò+S
  window.addEventListener('keydown', (e)=>{
    const sKey = (e.key||'').toLowerCase()==='s';
    if(sKey && (e.ctrlKey || e.metaKey)){
      e.preventDefault();
      openSaveManager();
    }
  });

  // ===== Pausa / Resume =====
  function togglePause(){
    if(!state) return;
    if(!state.running && state.pauseLeftMs>0){
      state.paused = false;
      state.running = true;
      state.deadlineTs = performance.now() + state.pauseLeftMs;
      state.pauseLeftMs = 0;
      pauseBtn.textContent = '‚è∏Ô∏è';
      tick();
      return;
    }
    if(state.running){
      state.paused = true;
      const now = performance.now();
      state.pauseLeftMs = Math.max(0, state.deadlineTs - now);
      state.running = false;
      pauseBtn.textContent = '‚ñ∂Ô∏è';
tapBuffer = []; // pulisci eventuali tocchi in coda
      return;
    }
  }
// --- S P L A S H  (versione robusta, attiva quando il DOM √® pronto) ---
document.addEventListener('DOMContentLoaded', () => {
  const splash = document.getElementById('splash');
  let splashTimer = null;

  function showSplash(){
    if (!splash) return;
    splash.classList.remove('hide');
    splash.classList.add('show');
  }
  function hideSplash(){
    if (!splash) return;
    splash.classList.add('hide');
    splash.classList.remove('show');
  }
  function skipSplash(){
    if (splashTimer) { clearTimeout(splashTimer); splashTimer = null; }
ensureSfx();

    hideSplash();
    showIntro(); // apre il tutorial
  }

  // Consenti di saltare la splash
  if (splash){
    splash.addEventListener('click', skipSplash);
    window.addEventListener('keydown', (e) => {
      if (!splash || splash.classList.contains('hide')) return;
      if (e.key === 'Enter' || e.key === ' ' || e.key === 'Escape') skipSplash();
    });
  }

  // Prepara la griglia e mostra la cover 3s
  init(0);      // costruisce la griglia "sotto" la splash
  showSplash(); // assicura che la splash sia visibile
  splashTimer = setTimeout(() => {
    hideSplash();
    showIntro();
  }, 3000);
});

  // Migrazione legacy (se presente) ‚Üí slot "Ultimo"
  try{
    if(localStorage.getItem(STORAGE_KEY)){
      const raw = localStorage.getItem(STORAGE_KEY);
      const data = raw ? JSON.parse(raw) : null;
      if(data) upsertSave('Ultimo', { version:3, themeIndex, totalScore:0, currentLevelIdx:0, progress });
      localStorage.removeItem(STORAGE_KEY);
      flashMessage('Importato salvataggio legacy in "Ultimo"');
    }
  }catch(e){}
})();
</script>
<!-- Splash pre-tutorial (3s) -->
<div id="splash" class="splash show" role="button" aria-label="Splash iniziale (tocca per saltare)">
  <svg viewBox="0 0 1200 1200" preserveAspectRatio="xMidYMid meet" class="splash-art" aria-hidden="true">
    <defs>
      <radialGradient id="bg" cx="50%" cy="40%" r="70%">
        <stop offset="0%" stop-color="#2b335c"/>
        <stop offset="100%" stop-color="#141724"/>
      </radialGradient>
    </defs>
    <rect width="1200" height="1200" fill="url(#bg)"/>
  </svg>
  <img src="splash-template.svg" class="splash-art" alt="Skullory" style="position:absolute;">

</div>

</body>
</html>








