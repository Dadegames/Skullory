<!DOCTYPE html>
<html lang="it">
<head>
<link rel="manifest" href="manifest.webmanifest">
<meta name="theme-color" content="#141724">
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Skullory</title>
<style>
  :root{
    --bg-1:#141724; --bg-2:#232a46; --bg-3:#2b335c; --bg-4:#28315a;
    --panel:#0f1322; --panel-1:#12162a; --panel-2:#0d1120; --panel-border:#2b3357;
    --grid-1:#101429; --grid-2:#0c1020; --grid-border:#2b3357;
    --card-back:#2a3157; --card-front:#171b2d; --card-border:#394275; --card-pattern:#3b4479;
    --accent:#7484ff; --ok:#52ce89; --bad:#f4606c; --text:#f5f5f8; --muted:#c8cde0;
    --gap:12px; --radius:16px; --shadow:0 10px 30px rgba(0,0,0,.35);
    --flip-ms:380ms; --cols:4;
  }
  /* THEME CLASSES (override variables) */
  body.theme-1{ --card-pattern:#3b4479;  --bg-1:#141724; --bg-2:#232a46; --bg-3:#2b335c; --bg-4:#28315a; --panel:#0f1322; --panel-1:#12162a; --panel-2:#0d1120; --panel-border:#2b3357; --grid-1:#101429; --grid-2:#0c1020; --grid-border:#2b3357; --card-back:#2a3157; --card-front:#171b2d; --card-border:#394275; --card-pattern:#3b4479; --accent:#7484ff; --ok:#52ce89; --bad:#f4606c; --text:#f5f5f8; --muted:#c8cde0; }
  body.theme-2{ --card-pattern:#5d3a78;  --bg-1:#2b1838; --bg-2:#401b3f; --bg-3:#52234f; --bg-4:#5a2558; --panel:#1a0f24; --panel-1:#2a1536; --panel-2:#0c1b29; --panel-border:#4e2b6b; --grid-1:#261433; --grid-2:#0c1020; --grid-border:#4e2b6b; --card-back:#3b2648; --card-front:#23142e; --card-border:#5d3a78; --accent:#ff7a59; --ok:#56df9a; --bad:#ff5c7a; --text:#fff3f5; --muted:#e0c9d6; }
  body.theme-3{ --card-pattern:#2c6a4c;  --bg-1:#0f1a14; --bg-2:#163024; --bg-3:#1c3d2c; --bg-4:#214736; --panel:#0b1913; --panel-1:#0f221a; --panel-2:#0c1b14; --panel-border:#2a5a43; --grid-1:#13261e; --grid-2:#0e1f18; --grid-border:#2a5a43; --card-back:#183b2b; --card-front:#0f221a; --card-border:#2c6a4c; --accent:#9be564; --ok:#4fe39c; --bad:#ff6b6b; --text:#eaf7ef; --muted:#b4d7c7; }
  body.theme-4{ --card-pattern:#7a5f44;  --bg-1:#2a241d; --bg-2:#3a2f23; --bg-3:#4a3b2b; --bg-4:#5a4a35; --panel:#1c1712; --panel-1:#251e17; --panel-2:#19140f; --panel-border:#6c553d; --grid-1:#211b15; --grid-2:#1a150f; --grid-border:#6c553d; --card-back:#4b3b2b; --card-front:#2a2119; --card-border:#7a5f44; --accent:#ffb84d; --ok:#7adf8a; --bad:#ff7f66; --text:#fff6e9; --muted:#e6d2b8; }
  body.theme-5{ --card-pattern:#2f5f80;  --bg-1:#0f1e2a; --bg-2:#123346; --bg-3:#17425a; --bg-4:#1a4b66; --panel:#0a1722; --panel-1:#0d2130; --panel-2:#0a1a26; --panel-border:#2b5574; --grid-1:#0f2736; --grid-2:#0b1f2a; --grid-border:#2b5574; --card-back:#163b52; --card-front:#0d2330; --card-border:#2f5f80; --accent:#4fd1ff; --ok:#6ae6b5; --bad:#ff6a7a; --text:#e6f7ff; --muted:#bdd8e7; }
  body.theme-6{ --card-pattern:#7a3535;  --bg-1:#1b1212; --bg-2:#2a1717; --bg-3:#3a1e1e; --bg-4:#4a2525; --panel:#140d0d; --panel-1:#1c1212; --panel-2:#110a0a; --panel-border:#6b2f2b; --grid-1:#1f1414; --grid-2:#170f0f; --grid-border:#6b2f2b; --card-back:#3a1e1e; --card-front:#241212; --card-border:#7a3535; --accent:#ff5e3a; --ok:#50e3a4; --bad:#ff4d4d; --text:#ffeceb; --muted:#e0b3b3; }
  body.theme-7{ --card-pattern:#415082;  --bg-1:#0f1116; --bg-2:#191d2b; --bg-3:#1f2640; --bg-4:#232b48; --panel:#0a0c12; --panel-1:#111521; --panel-2:#0d1019; --panel-border:#384064; --grid-1:#131827; --grid-2:#0f1320; --grid-border:#384064; --card-back:#1d2336; --card-front:#0f1522; --card-border:#415082; --accent:#ff3fb4; --ok:#50e3c2; --bad:#ff6b8b; --text:#f7f7ff; --muted:#c8cbe6; }
  body.theme-8{ --card-pattern:#2e6a73;  --bg-1:#0e1a1c; --bg-2:#14333a; --bg-3:#184249; --bg-4:#1d4e57; --panel:#0a1618; --panel-1:#0d2023; --panel-2:#0a1a1d; --panel-border:#2b5861; --grid-1:#10282d; --grid-2:#0c2024; --grid-border:#2b5861; --card-back:#15454d; --card-front:#0e262c; --card-border:#2e6a73; --accent:#42d6c5; --ok:#60e8a8; --bad:#ff6f7c; --text:#e8fffb; --muted:#bfe2de; }
  body.theme-9{ --card-pattern:#44684a;  --bg-1:#111a12; --bg-2:#1b2a1c; --bg-3:#223826; --bg-4:#284330; --panel:#0c140d; --panel-1:#111c13; --panel-2:#0d160f; --panel-border:#3b5f41; --grid-1:#162418; --grid-2:#111d13; --grid-border:#3b5f41; --card-back:#223b25; --card-front:#142018; --card-border:#44684a; --accent:#7bd88f; --ok:#6ee7b7; --bad:#ef6464; --text:#eaf6ee; --muted:#c7dccb; }
  body.theme-10{ --card-pattern:#57459a;  --bg-1:#1e1630; --bg-2:#2a1e46; --bg-3:#34285a; --bg-4:#3f306d; --panel:#150f22; --panel-1:#1e1733; --panel-2:#17102a; --panel-border:#4b3a7a; --grid-1:#221a3a; --grid-2:#1a1430; --grid-border:#4b3a7a; --card-back:#2f2759; --card-front:#1b1533; --card-border:#57459a; --accent:#00e0ff; --ok:#66f0a6; --bad:#ff7aa2; --text:#f4f2ff; --muted:#cdc6ff; }

  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; color:var(--text); font:16px/1.45 system-ui,Segoe UI,Roboto,Helvetica,Arial;
    background:
      radial-gradient(1200px 800px at 20% -10%, var(--bg-3), transparent),
      radial-gradient(900px 600px at 110% 20%, var(--bg-4), transparent),
      linear-gradient(180deg, var(--bg-1), var(--bg-2));
    display:flex; 
    align-items:flex-start;
    justify-content:center; 
    padding:10px 18px 18px;
    -webkit-font-smoothing: antialiased; 
    min-height:100dvh;
  }
  .wrap{ width:min(1100px, 98vw); margin: 30px auto 0; }
  .top{
    display:block;
    padding: 0;
  }

  .brand{ width:100%; }

  .brand img{
    display:block;
    width:100%;
    height:auto;
    max-height: 70px;
  }

  .controls { display: flex; gap: 6px; }
  .controls-bottom{
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 8px;
    width: 100%;
    margin-top: 14px;
  }
  .controls-left, .controls-right{
    display: flex;
    align-items: center;
    gap: 8px;
  }

  /* Riduci la larghezza SOLO dei tre bottoni in alto a destra */
  .controls-bottom .outline-btn{
    padding: 8px 8px;
    min-width: 40px;
  }

  /* Stato visivo disabilitato, ma cliccabile per mostrare l’help */
  .controls-right .power-btn[aria-disabled="true"]{
    filter: grayscale(100%);
    opacity: .35;
    cursor: not-allowed;
    box-shadow: none;
    border-color: #3a4168;
  }
  .controls-right .power-btn[aria-disabled="true"]:hover{
    transform: none;
    box-shadow: none;
  }

  button.primary{background:var(--accent); color:#0b0f1e; border:none; padding:10px 16px; border-radius:12px; font-weight:700; cursor:pointer}
  button.primary:active{transform:translateY(1px)}
  .stats-container{ display:flex; justify-content:center; margin:12px 0 8px; gap:12px; flex-wrap:wrap }
  .stats{ display:flex; align-items:center; gap:12px; flex-wrap:wrap; justify-content:center }
  .chip{ padding:8px 12px; border-radius:999px; background:#1a1f37; border:1px solid var(--panel-border); color:#c8cde0; white-space:nowrap }
  .level-chip{ padding:6px 10px; border-radius:999px; background:#1a1f37; border:1px solid var(--panel-border); color:#c8cde0; font-size:14px; white-space:nowrap }
  .timer{ font-size:26px; font-weight:700 }
  .grid{
    margin-top:18px; display:grid; grid-template-columns:repeat(var(--cols), minmax(0,1fr));
    gap:var(--gap); padding:18px; background:linear-gradient(180deg,var(--grid-1),var(--grid-2));
    border:1px solid var(--grid-border); border-radius:24px; box-shadow:var(--shadow);
  }
  .card{
    position:relative; aspect-ratio:1/1; perspective:900px;
    cursor:pointer; border-radius:var(--radius); -webkit-tap-highlight-color:transparent; touch-action:manipulation;
    container-type: inline-size;
  }
  .face{
    position:absolute; inset:0; display:grid; place-items:center; border-radius:var(--radius); border:1px solid var(--card-border);
    backface-visibility:hidden;
    pointer-events:none; /* unita qui */
  }
  .front{ background:var(--card-front); transform:rotateY(180deg) }
  .back{ background:var(--card-back) }
  .back::before{
    content:""; position:absolute; inset:10px; border-radius:12px;
    background:
      linear-gradient(45deg,
        var(--card-pattern) 0 12%,
        transparent 12% 25%,
        var(--card-pattern) 25% 37%,
        transparent 37% 50%,
        var(--card-pattern) 50% 62%,
        transparent 62% 75%,
        var(--card-pattern) 75% 87%,
        transparent 87% 100%
      );
    opacity:.35;
  }
  .inner{
    position:absolute; inset:0; border-radius:var(--radius);
    transform-style:preserve-3d; transition: transform var(--flip-ms) cubic-bezier(.2,.7,.1,1);
    box-shadow: 0 12px 24px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.03);
  }
  .card[data-state="revealed"] .inner,
  .card[data-state="matched"] .inner{ transform:rotateY(180deg) }
  .symbol{
    font-size: clamp(28px, 50cqi, 86px);
    line-height: 1;
    filter: drop-shadow(0 4px 10px rgba(0,0,0,.45));
  }
  .card[data-state="matched"] .front{ outline:3px solid var(--ok); box-shadow:0 0 18px rgba(82,206,137,.45) inset }
  .card[data-state="locked"]{ pointer-events:none }

  /* Placeholder per slot vuoto nei livelli senza angoli */
  .card.placeholder{
    background:transparent;
    border:none;
    box-shadow:none;
    pointer-events:none;
  }

  /* Special effects for 💀 e ⚡ */
  .card[data-symbol="💀"] .front .symbol{ text-shadow: 0 0 10px rgba(244,96,108,.6) }
  .card[data-symbol="💀"][data-state="revealed"] .front{ outline:3px solid var(--bad); box-shadow:0 0 22px rgba(244,96,108,.45) inset }
  .card[data-symbol="⚡"] .front .symbol{ text-shadow: 0 0 10px rgba(255,213,79,.6) }
  .card[data-symbol="⚡"][data-state="revealed"] .front{ outline:3px solid #ffd54f; box-shadow:0 0 22px rgba(255,213,79,.4) inset }

  .flash-msg{
    position:fixed;
    top:20%;
    left:50%;
    transform:translateX(-50%);
    background:rgba(0,0,0,.8);
    color:#fff;
    padding:12px 20px;
    border-radius:12px;
    font-weight:700;
    font-size:1.3em;
    z-index:9999;
    pointer-events:none;
    animation:flashUp 1.5s ease forwards;
  }
  /* Stelline match */
  .match-stars { 
    position: absolute; inset: 0; pointer-events: none; 
    display: grid; place-items: center; 
  }
  .match-stars .star {
    position: absolute;
    font-size: 18px;
    opacity: 0;
    animation: starPop 600ms ease-out forwards;
    will-change: transform, opacity;
    filter: drop-shadow(0 6px 10px rgba(0,0,0,.35));
  }
  @keyframes starPop {
    0%   { transform: translate(0,0) scale(.4) rotate(0deg);   opacity: 0; }
    20%  { opacity: 1; }
    100% { transform: translate(var(--dx), var(--dy)) scale(1.2) rotate(35deg); opacity: 0; }
  }
  /* Anellino “pulse” sulla carta matched */
  .card[data-state="matched"] .front { animation: ringPulse 420ms ease-out; }
  @keyframes ringPulse {
    0%   { box-shadow: 0 0 0 0 rgba(82,206,137,.45) inset; }
    100% { box-shadow: 0 0 18px rgba(82,206,137,.45) inset; }
  }

  /* Accessibilità: niente animazioni se l’utente le riduce */
  @media (prefers-reduced-motion: reduce){
    .match-stars .star, .card[data-state="matched"] .front { animation: none !important; }
  }

  @keyframes flashUp{
    0%{opacity:0; transform:translate(-50%, 8px)}
    15%{opacity:1; transform:translate(-50%, 0)}
    100%{opacity:0; transform:translate(-50%, -8px)}
  }

  /* Overlay unificato */
  .overlay{
    position:fixed;
    inset:0;
    display:none;
    place-items:center;
    background: rgba(10,12,22,.45);
    -webkit-backdrop-filter: blur(10px) saturate(110%);
    backdrop-filter: blur(10px) saturate(110%);
    z-index:1000;
  }
  .overlay.show{ display:grid }

  .dialog{ width:min(640px, 92vw); background:linear-gradient(180deg,var(--panel-1),var(--panel-2)); border:1px solid var(--panel-border);
    border-radius:20px; padding:24px; text-align:center; box-shadow:var(--shadow) }
  .dialog h2{ margin:6px 0 8px; font-size:28px }
  .dialog p{ margin:0 0 14px; color:var(--muted) }

  @media (max-width: 600px){
    .wrap{ width:min(520px, 96vw) }
    .top, .grid{ width:100% }
  }

  /* Disabilita il flip animato quando vogliamo richiudere le carte di colpo */
  .no-flip .inner { transition: none !important; }
  .simon-ghost { z-index: 30; }

  /* Quando è attivo il Simon, impedisci ogni flip e nascondi la faccia front */
  body.mode-simon .card .inner{ transform: none !important; transition: none !important; }
  body.mode-simon .card .front{ visibility: hidden !important; }

  /* Pulsanti Pausa, Salva, Ricomincia in versione outline */
  .outline-btn { background: transparent !important; color: var(--accent) !important; border: 2px solid var(--accent) !important; }
  .outline-btn:hover { background: rgba(255, 255, 255, 0.05); }
  .outline-btn:active { background: rgba(255, 255, 255, 0.12); }

  /* Splash pre-tutorial */
  .splash{
    position: fixed;
    inset: 0;
    z-index: 2000;
    display: grid;
    place-items: center;
    background: linear-gradient(180deg, var(--bg-1), var(--bg-2));
    transition: opacity 280ms ease, visibility 280ms ease;
    opacity: 1;
    visibility: visible;
    cursor: pointer;
  }
  .splash.hide{ opacity: 0; visibility: hidden; pointer-events: none; }
  .splash .splash-art{
    width: min(70vmin, 900px);
    max-width: 92vw;
    height: auto;
    filter: drop-shadow(0 24px 50px rgba(0,0,0,.45));
  }
  .splash .splash-skip{
    position: absolute;
    bottom: 28px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0,0,0,.35);
    border: 1px solid var(--panel-border);
    color: var(--muted);
    padding: 8px 12px;
    border-radius: 999px;
    font-size: 14px;
    user-select: none;
  }

  /* Tutorial a slide */
  .tutorial-dialog{ position:relative; overflow:hidden; }
  .tutorial-carousel{ position:relative; min-height: 140px; }
  .tutorial-slide[hidden]{ display:none !important; }

  .tutorial-arrow{
    position:absolute;
    bottom: 20px;
    width:38px; height:38px;
    display:grid; place-items:center;
    border-radius:999px;
    border:1px solid var(--panel-border);
    background:linear-gradient(180deg, var(--panel-1), var(--panel-2));
    color:var(--text);
    cursor:pointer;
    box-shadow: var(--shadow);
    user-select:none;
  }
  .tutorial-arrow.prev{ left:10px; }
  .tutorial-arrow.next{ right:10px; }
  .tutorial-arrow:disabled{ opacity:.5; cursor:default; }

  .tutorial-dots{
    display:flex; gap:8px; justify-content:center; align-items:center;
    margin-top:12px;
  }
  .tutorial-dots button{
    width:8px; height:8px; border-radius:999px; border:none;
    background:#3a4168; cursor:pointer;
  }
  .tutorial-dots button[aria-current="true"]{
    width:22px; height:8px; border-radius:999px; background:var(--accent);
  }

  .big-symbol{
    font-size: clamp(42px, 10vw, 72px);
    line-height: 1;
    filter: drop-shadow(0 6px 16px rgba(0,0,0,.35));
  }

  /* X in alto a destra */
  .tutorial-close{
    position:absolute; top:10px; right:10px;
    width:34px; height:34px; display:grid; place-items:center;
    border-radius:10px;
    border:1px solid var(--panel-border);
    background:linear-gradient(180deg, var(--panel-1), var(--panel-2));
    color:var(--muted);
    cursor:pointer;
  }

  /* --- Testo centrato e niente pallini nelle slide del tutorial --- */
  #intro .tutorial-slide { text-align: center; }
  #intro .tutorial-slide ul { list-style: none; padding: 0; margin: 10px 0 0; }
  #intro .tutorial-slide li { margin: 8px 0; }
  #intro .tutorial-slide h3{ margin: 6px 0 10px; font-size: 22px; }

  /* Close del popup Salvataggi (stile coerente col tutorial) */
  .save-close{
    position:absolute; top:10px; right:10px;
    width:34px; height:34px; display:grid; place-items:center;
    border-radius:10px;
    border:1px solid var(--panel-border);
    background:linear-gradient(180deg,var(--panel-1),var(--panel-2));
    color:var(--muted);
    cursor:pointer;
  }

  /* Bottoni icona (Upload, Cestino) */
  .icon-btn{
    width:36px; height:36px;
    display:grid; place-items:center;
    border-radius:10px;
    border:1px solid var(--panel-border);
    background:linear-gradient(180deg,var(--panel-1),var(--panel-2));
    color:var(--text);
    cursor:pointer;
    box-shadow:var(--shadow);
    font-size:18px; line-height:1;
  }
  .icon-btn:hover{ filter:brightness(1.05) }
  .icon-btn:active{ transform:translateY(1px) }

  /* --- SIMON (flash del fantasmino) --- */
  .simon-ghost{
    position:absolute; inset:0;
    display:grid; place-items:center;
    font-size: clamp(36px, 50cqi, 90px);
    border:2px solid var(--accent);
    border-radius: var(--radius);
    background: rgba(255,255,255,.05);
    animation: simonFlash .55s ease-out;
    filter: drop-shadow(0 10px 24px rgba(0,0,0,.35));
    pointer-events: none;
    backface-visibility: hidden;
    transform: translateZ(0);
    will-change: transform, opacity;
  }
  @keyframes simonFlash{
    0%{ opacity:.15; transform:scale(.92) }
    50%{ opacity:1; transform:scale(1.02) }
    100%{ opacity:0; transform:scale(1) }
  }
  .no-flip .card[data-state="hidden"] .front { visibility: hidden; }

  /* --- Poteri: stile dedicato --- */
  .controls-right .power-btn{
    width: 46px; height: 46px;
    padding: 0;
    border-radius: 999px;
    display: grid; place-items: center;
    border: 2px solid var(--accent);
    background: linear-gradient(180deg, var(--panel-1), var(--panel-2));
    box-shadow: var(--shadow);
    font-size: 20px;
    transition:
      filter .18s ease, opacity .18s ease,
      transform .12s ease, box-shadow .18s ease, border-color .18s ease;
  }
  .controls-right .power-btn:not(:disabled):hover{
    transform: translateY(-1px);
    box-shadow: 0 14px 28px rgba(0,0,0,.45);
  }
  .controls-right .power-btn:not(:disabled):active{ transform: translateY(0); }

  /* Stato “pronto” (abilitato): leggero bagliore/pulse */
  @keyframes powerPulse {
    0%   { box-shadow: 0 0 0 0 rgba(116,132,255,.25); }
    70%  { box-shadow: 0 0 0 8px rgba(116,132,255,0); }
    100% { box-shadow: 0 0 0 0 rgba(116,132,255,0); }
  }
  .controls-right .power-btn.ready{ animation: powerPulse 1.2s ease-out infinite; }
  #powerReveal.ready { border-color: #ffd54f; }
  #powerPlus10.ready { border-color: #60e8a8; }
  #powerShift.ready  { border-color: #ff7aa2; }
/* --- Zen: BUCHI (⚡→ buco) --- */
.card.placeholder.hole{
  position: relative;
  border: 1px dashed var(--panel-border);
  background: transparent;
  box-shadow: none;
  pointer-events: none;
}
.card.placeholder.hole::after{
  content:"";
  position:absolute; inset:10px;
  border-radius:12px;
  background: radial-gradient(closest-side, rgba(255,255,255,.08), transparent 70%);
  animation: holePulse 1.8s ease-in-out infinite;
}
@keyframes holePulse { 0%{opacity:.5} 50%{opacity:.75} 100%{opacity:.5} }

/* telegraph prima dello shift */
.hole-blink::after{
  animation: holeBlink .12s ease-out 1, holePulse 1.8s ease-in-out infinite .12s;
}
@keyframes holeBlink {
  0%{ box-shadow:0 0 0 0 rgba(255,255,255,.35) }
  100%{ box-shadow:0 0 0 14px rgba(255,255,255,0) }
}

/* feedback se bloccato */
.hole-shake{ animation: holeShake .2s ease; }
@keyframes holeShake {
  0%,100%{ transform: translateX(0); }
  25%{ transform: translateX(-2px); }
  75%{ transform: translateX(2px); }
}

/* mini pop/dissolve del ⚡ quando diventa buco */
.card.pop-out .front{ animation: popOut .16s ease-out forwards; }
@keyframes popOut { to { transform: scale(.85); opacity: 0; } }
/* --- Tutorial: contatore, progress bar, hint --- */
.tutorial-title{
  display:flex; align-items:center; justify-content:center; gap:10px;
  margin-bottom: 8px;
}
.tutorial-count{
  display:inline-flex; align-items:center; justify-content:center;
  min-width: 38px; padding: 3px 8px; border-radius: 999px;
  font-size: 13px; color: var(--muted);
  border:1px solid var(--panel-border);
  background: linear-gradient(180deg, var(--panel-1), var(--panel-2));
}
.tutorial-progress{
  height: 4px; width: 100%; border-radius: 999px;
  background: rgba(255,255,255,.06);
  overflow: hidden; margin: 8px 0 4px;
}
.tutorial-progress-bar{
  height: 100%; width: 0%;
  background: var(--accent);
  transition: width .25s ease;
}
.tutorial-hint{
  text-align:center; color: var(--muted); font-size: 13px;
  margin-top: 8px; user-select: none;
}
/* Nascondi del tutto la progress bar quando inutilizzata */
.tutorial-progress[aria-hidden="true"],
.tutorial-progress[hidden]{
  display: none;
}
/* Solo lettori di schermo */
.sr-only{
  position:absolute;width:1px;height:1px;padding:0;margin:-1px;
  overflow:hidden;clip:rect(0 0 1px 1px);white-space:nowrap;border:0;
}
.intro-legal{
  margin: 8px 0 0;
  text-align: center;
}
.link-like{
  background: none;
  border: none;
  padding: 0;
  font: inherit;
  color: var(--muted);
  text-decoration: underline;
  cursor: pointer;
  -webkit-tap-highlight-color: transparent; /* niente highlight rosso su mobile */
}
/* Link Privacy piccolo e discreto nel menu iniziale */
.intro-legal{
  font-size: 12px;
  text-align: center;
}
.intro-legal .link-like{
  font-size: inherit;   /* eredita 12px */
  opacity: .85;         /* leggermente più soft */
}

/* NON mostrare contorno sul semplice focus “da tap”… */
.link-like:focus{
  outline: none;
}

/* …mostralo solo quando l’utente usa la tastiera (TAB, ecc.) */
.link-like:focus-visible{
  outline: 2px solid var(--accent);
  outline-offset: 2px;
}
/* --- Privacy modal: testo centrato --- */
#privacy .dialog { 
  text-align: center;               /* centra tutto il testo/inline */
}
#privacy .dialog p {
  max-width: 560px;                 /* riga più corta = più leggibile */
  margin: 10px auto;                /* centra il paragrafo */
}
/* === Teleport FX (Zen specials) === */
.tp-glow-yellow { box-shadow: 0 0 18px rgba(255,213,79,.55), inset 0 0 32px rgba(255,213,79,.25); }
.tp-glow-red    { box-shadow: 0 0 18px rgba(244,96,108,.55), inset 0 0 32px rgba(244,96,108,.25); }

.tp-animating { will-change: transform; } /* per animazione FLIP */

.banners {
  margin-top: 8px;
  display: flex;
  flex-direction: column;   /* banner uno sotto l’altro */
  align-items: center;
  width: 100%;              /* stessa larghezza del contenitore logo */
}

.banners img {
  display: block;
  width: 100%;              /* si allargano a tutta la larghezza del logo */
  height: auto;             /* mantengono le proporzioni */
  max-height: none;         /* niente limite di altezza artificiale */
}

</style>
</head>
<body class="theme-1">
<!-- Splash pre-tutorial (3s) -->
<div id="splash" class="splash show" role="button" aria-label="Intro splash (tap to skip)">

  <svg viewBox="0 0 1200 1200" preserveAspectRatio="xMidYMid meet" class="splash-art" aria-hidden="true">
    <defs>
      <radialGradient id="bg" cx="50%" cy="40%" r="70%">
        <stop offset="0%" stop-color="#2b335c"/>
        <stop offset="100%" stop-color="#141724"/>
      </radialGradient>
    </defs>
    <rect width="1200" height="1200" fill="url(#bg)"/>
  </svg>
  <img src="splash-template.svg" class="splash-art" alt="Skullory" style="position:absolute;">
</div>

<!-- ⬇️ AGGIUNGI QUESTA RIGA PRIMA DEL TUO <script> PRINCIPALE -->
<script src="sfx.js?v=6"></script>
<div class="wrap">
  <div class="top">
    <div class="brand">
  <img src="skullory-logo.svg" alt="Skullory">
  <div id="mode-banners" class="banners"></div>
</div>
    <div class="stats-container">
      <div class="stats">
        <span class="level-chip" id="levelChip">Level: —</span>
        <span class="level-chip" id="statusChip">Status: —</span>
        <span class="level-chip" id="moves" aria-live="polite">Moves: 0</span>
        <span class="chip timer" id="timer" aria-live="polite">0:30</span>
        <span class="chip" id="score" aria-live="polite" style="color:#FFF44F">Score: 0</span>
      </div>
    </div>

    <div class="grid" id="grid" aria-label="Skullory grid"></div>

    <div class="controls controls-bottom">
      <div class="controls-left">
        <button class="primary outline-btn" id="pause">⏸️</button>
        <button class="primary outline-btn" id="save">💾</button>
        <button class="primary outline-btn" id="restart" title="Home" aria-label="Home">🏠</button>
        <button class="primary outline-btn" id="audioCycle" title="Audio">🎵</button>
      </div>

      <div class="controls-right">
        <button class="primary outline-btn power-btn" id="powerReveal"
          title="👁️ Reveal all for 1s (−20% time, min −4s, never below 3s) · 1×">👁️</button>
        <button class="primary outline-btn power-btn" id="powerPlus10"
          title="🦇 +10s (sacrifice 1 random matched pair, moved) · 1×">🦇</button>
        <button class="primary outline-btn power-btn" id="powerShift"
          title="🌀 Move 💀 & ⚡, reshuffle (like ⚡), +15s · 1×">🌀</button>
      </div>
    </div>

    <!-- Intro / Tutorial (carousel a 3 slide) -->
    <div class="overlay hide" id="intro">
      <div class="dialog tutorial-dialog">
        <button class="tutorial-close" id="intro-close" aria-label="Chiudi tutorial">✕</button>
        <div class="tutorial-title">
  <h2 id="intro-title" style="margin-bottom:8px">How to play</h2>
  <span id="intro-count" class="tutorial-count" hidden>1/3</span>
</div>


        <div class="tutorial-carousel" aria-live="polite">
<div class="tutorial-progress" id="intro-progress-wrap" aria-hidden="true">
  <div class="tutorial-progress-bar" id="intro-progress"></div>
</div>

  <!-- Slide 0 (scelta modalità) -->
<div class="tutorial-slide" data-mode="root">
  <h3 style="color:#FFF44F">Pick a mode</h3>

  <div style="
    display:flex; flex-direction:column; gap:10px; align-items:center;
    margin-top:12px; width:100%; max-width:420px; margin-left:auto; margin-right:auto;
  ">
    <button class="primary" id="intro-chaos-main"  style="width:100%">🧪 Chaos — Daily challenge!</button>
    <button class="primary outline-btn" id="intro-arcade-main" style="width:100%">🎮 Arcade — Climb the levels!</button>
    <button class="primary outline-btn" id="intro-zen-main"    style="width:100%">🧘 Zen — Practice!</button>
  </div>

  <p style="color:var(--muted); margin-top:12px; max-width:520px; margin-left:auto; margin-right:auto;">
    <b>Chaos</b>: same grid for everyone each day.<br/>
    <b>Arcade</b>: levels, timer, bonuses, powers.<br/>
    <b>Zen</b>: pure practice with a final rating.
  </p>
</div>

  <!-- Slide Arcade 1 -->
<div class="tutorial-slide" data-mode="arcade">
  <h3 style="color:#FFF44F">Goal</h3>
  <ul>
    <li>Match all <b>pairs</b> before the <b>time runs out!</b></li>
    <li><b>Unlock</b>: clear the same level <b>3 times in a row</b>!</li>
    <li>After unlocking, stay on the level <b>to score more</b>.</li>
    <li><b>On your first mistake</b>, you move to the next level.</li>
  </ul>
</div>

  <!-- Slide Arcade 2 -->
  <div class="tutorial-slide" data-mode="arcade" hidden>
    <h3 style="color:#FFF44F">Special cards</h3>
    <div style="display:flex; gap:18px; align-items:center; justify-content:center; margin:10px 0 6px">
      <div class="big-symbol" aria-hidden="true">⚡</div>
      <div class="big-symbol" aria-hidden="true">💀</div>
    </div>
    <ul>
      <li>⚡ reshuffles all covered cards (except 💀 and ⚡).</li>
      <li>💀 if revealed twice: <b>you lose!</b></li>
    </ul>
  </div>

  <!-- Slide Arcade 3 -->
  <div class="tutorial-slide" data-mode="arcade" hidden>
<h3 style="color:#FFF44F">Bonuses, penalties & scoring</h3>
<ul>
  <li><b>Bonus 1</b>: each match = <b>+1s</b></li>
  <li><b>Bonus 2</b>: 2 matches within 5s = <b>+5s</b></li>
  <li><b>Penalty</b>: each miss <b>−1s</b></li>
  <li><b>Score</b>: seconds saved <b>×</b> move efficiency.</li>
</ul>
  </div>

  <!-- Slide Zen -->
  <div class="tutorial-slide" data-mode="zen" hidden>
    <h3 style="color:#FFF44F">Play chill!</h3>
    <ul>
      <li>No timer, no on-screen score.</li>
      <li>Just play: no powers, no points.</li>
      <li>End report: <b>time</b>, <b>moves</b>, <b>efficiency</b>, and ⭐.</li>
    </ul>

    <h3 style="color:#FFF44F; margin-top:14px">Special cards</h3>
    <ul>
      <li>⚡ reshuffles all covered cards (except 💀 and ⚡).</li>
      <li>💀 if revealed twice: <b>you lose!</b></li>
    </ul>
  </div>

<!-- Slide Chaos -->
<div class="tutorial-slide" data-mode="chaos" hidden>
  <h3 style="color:#FFF44F">Challenge friends to beat you!</h3>
  <ul>
    <li>Same daily grid for everyone. <b>Share your best score!</b></li>
  </ul>

  <h3 style="color:#FFF44F; margin-top:14px">Special cards</h3>
  <ul>
    <li>⚡ reshuffles covered cards; <b>tap it twice and you’ll create a hole!</b></li>
    <li><b>💀</b> cancels a <b>matched pair</b> (if any) and <b>reshuffles covered cards</b>!</li>
    <li>On a match, the hole pulls in <b>1–4 adjacent covered cards</b>!</li>
  </ul>
</div>

</div>


        <button class="tutorial-arrow prev" id="intro-prev" aria-label="Slide precedente">‹</button>
        <button class="tutorial-arrow next" id="intro-next" aria-label="Slide successiva">›</button>

        <div class="tutorial-dots" id="intro-dots" role="tablist" aria-label="Pagine tutorial"></div>
<div class="tutorial-hint" id="intro-hint" hidden>3 pages — swipe or use the arrows ›</div>


        <div class="actions" style="margin-top:14px; display:flex; justify-content:center; gap:10px">
          <button class="primary" id="intro-play">Play</button>
        </div>
     <p class="intro-legal">
      <button type="button" data-open-privacy class="link-like">Privacy</button>
    </p>
  </div> <!-- chiusura .dialog -->
</div>   <!-- chiusura #intro -->

    <!-- Gestore Salvataggi (Modal) -->
    <!-- Conferma Ricomincia -->
    <div class="overlay" id="restartConfirm" aria-hidden="true">
      <div class="dialog">
        <h2>Restart game?</h2>
        <p style="margin-top:4px; color:var(--muted)">Current progress will be lost.</p>
        <div style="display:flex; gap:10px; justify-content:center; margin-top:8px">
          <button class="primary" id="restart-yes">Yes, restart</button>
          <button class="primary" id="restart-no" style="background:var(--bad); color:#fff">Cancel</button>
        </div>
      </div>
    </div>

    <div class="overlay" id="saveModal" aria-hidden="true">
      <div class="dialog" style="position:relative">
        <button class="save-close" id="save-close" aria-label="Close saves">✕</button>
        <h2 style="text-align:center; margin-top:2px">Saves</h2>
        <div id="saveList" style="max-height:46vh; overflow:auto; margin:8px 0 12px"></div>

        <div id="saveControls" style="display:flex; gap:8px; align-items:center; margin-top:6px">
          <input id="saveName" placeholder="Save name…"
            style="width:150px; padding:10px 12px; border-radius:10px;
                   border:1px solid var(--panel-border); background:var(--panel-2);
                   color:var(--text)"/>
          <button class="primary" id="doSave">Save</button>
        </div>

        <p style="color:var(--muted); margin-top:10px">
          You can save <b>only at the end of a board</b> or <b>before starting.
        </p>
      </div>
    </div>
<!-- Privacy -->
<div class="overlay" id="privacy" aria-hidden="true" style="z-index:1100">
  <div class="dialog" style="position:relative">
<button class="tutorial-close" id="privacy-close" aria-label="Close">✕</button>
<h2 id="privacy-title">Privacy</h2>
<p><b>No tracking.</b> The game uses no cookies or analytics.</p>
<p><b>Data stays on device.</b> Your state and saves never leave your phone.</p>
 
  </div>
</div>

    <!-- Overlay di fine quadro -->
<div class="overlay" id="overlay">
  <div class="dialog" style="position:relative">
    <button class="tutorial-close" id="ov-close" aria-label="Chiudi">✕</button>
<h2 id="ov-title">You win!</h2>
<p id="ov-sub">Time left: —</p>

<div class="ov-actions" style="display:flex;gap:10px;justify-content:center;flex-wrap:wrap">
  <button class="primary" id="ov-btn">Continue</button>
  <button class="primary outline-btn" id="ov-btn-skip" style="display:none">Skip</button>
</div>
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  const RED = '💀';
  const YELLOW = '⚡';
// Durate identiche a quelle già percepite (mismatch ~420ms)
const MISMATCH_HOLD_MS = 420;
const MATCH_HOLD_MS = 120; // per coerenza (non serve bloccare l’input)

  // --- SIMON: manopole per le durate ---
  const SIMON_CFG = {
    previewMs: 700,
    gapMs: 140,
    inputRevealMs: 520,
    wrongHoldMs: 850,
    startLen: 3
  };

  const GHOST = '👻';
  let sim = null;
  let modeZen = false;
let zenVariant = 'zen'; // 'zen' | 'chaos'


  const STORAGE_KEY = 'skullory_save_v1';
  const SAVES_KEY = 'skullory_saves_v2';
// Limite "soft" di slot (ordine/UX). Puoi alzarlo/abbassarlo.
const MAX_SAVES = 20;

// Riconosce errori di quota/localStorage off (Safari privato, WebView, ecc)
function isQuotaExceeded(err){
  if (!err) return false;
  return (
    err.name === 'QuotaExceededError' ||
    err.name === 'NS_ERROR_DOM_QUOTA_REACHED' || // Firefox
    err.code === 22 || err.code === 1014        // WebKit/Firefox (legacy)
  );
}


  const LEVELS = [
    { name: '3×3 (no centro)', side: 3, disabled: [4], pairs: 3, red: 1, yellow: 1, timeMs: 20000, unlockMs: [20000, 15000, 10000], postDeltaSec: 1 },
    { name: '3×3', side: 3, disabled: [], pairs: 4, red: 1, yellow: 0, timeMs: 40000, unlockMs: [40000, 35000, 30000], postDeltaSec: 2 },
    { name: '4×4 (–angoli)', side: 4, disabled: [0,3,12,15], pairs: 5, red: 1, yellow: 1, timeMs: 45000, unlockMs: [45000, 40000, 35000], postDeltaSec: 2 },
    { name: '4×4', side: 4, disabled: [], pairs: 7, red: 1, yellow: 1, timeMs: 60000, unlockMs: [60000, 55000, 50000], postDeltaSec: 2 },
    { name: '5×5 (caotico simm.)', side: 5, disabled: [1,3,5,9,12,15,19,21,23], pairs: 6, red: 1, yellow: 3, timeMs: 65000, unlockMs: [65000, 60000, 55000], postDeltaSec: 3 },
    { name: '5×5 (cornice)', side: 5, disabled: [0,4,12,20,24], pairs: 9, red: 1, yellow: 1, timeMs: 70000, unlockMs: [70000, 65000, 60000], postDeltaSec: 3 },
    { name: '5×5 (–angoli)', side: 5, disabled: [0,4,20,24], pairs: 9, red: 1, yellow: 2, timeMs: 70000, unlockMs: [70000, 65000, 60000], postDeltaSec: 3 },
    { name: '5×5', side: 5, disabled: [], pairs: 11, red: 1, yellow: 2, timeMs: 80000, unlockMs: [80000, 75000, 70000], postDeltaSec: 3 },
    { name: '6×6 (croce)', side: 6, disabled: [0,1,4,5,6,11,24,29,30,31,34,35], pairs: 10, red: 1, yellow: 3, timeMs: 90000, unlockMs: [90000, 85000, 80000], postDeltaSec: 3 },
    { name: '6×6 (cornici+centro)', side: 6, disabled: [0, 5, 30, 35, 14, 15, 20, 21], pairs: 12, red: 1, yellow: 3, timeMs: 112000, unlockMs: [112000, 108000, 104000], postDeltaSec: 4 },
    { name: '6×6 (–angoli)', side: 6, disabled: [0,5,30,35], pairs: 14, red: 1, yellow: 3, timeMs: 95000, unlockMs: [95000, 90000, 85000], postDeltaSec: 3 },
    { name: '6×6', side: 6, disabled: [], pairs: 16, red: 1, yellow: 3, timeMs: 100000, unlockMs: [100000, 95000, 90000], postDeltaSec: 3 }
  ];

  const EMOJI = ['🐶','🐱','🦊','🐼','🐵','🐯','🦁','🐸','🐨','🦄','🐷','🐹','🐙','🦉','🦋','🐝','🐢','🐠','🍎','🍉','🍇','🍒','🍓','🍑','🥑','🌽','🥕','🍩','🍪','🍰','🍔','🍕','🍣','🍤','🍜','🍿','🐋','🦭','🦀','🐞','🐍','🦜','🦢','🐎','🐫','🦒','🐿','🦔','🦩','🐬','🐳','🦦','🐡','🐌','🍋','🍊','🫐','🥥','🥭','🥒','🫑','🥔','🌶','🍄','🧄','🧅','🧀','🥨','🥯','🥞','🥪','🥙','🥗','🥘','🥟','🍮','🍫','🍹','🧋','🍺','☕','🥛','🍷','🍵'];

const GAME_URL = 'https://dadegames.github.io/Skullory/';
// --- Zen: buchi (fulmine→buco)
const HOLE_SHIFT_MS_MIN = 140;
const HOLE_SHIFT_MS_MAX = 180;
// === DAILY (seed-based) ===============================================
// Hash deterministico 32 bit
function hashString(str){
  let hash = 0;
  for (let i = 0; i < str.length; i++){
    hash = ((hash << 5) - hash) + str.charCodeAt(i);
    hash |= 0; // 32-bit
  }
  return hash >>> 0; // unsigned
}

// PRNG deterministic (Mulberry32)
function mulberry32(a){
  let t = a >>> 0;
  return function(){
    t += 0x6D2B79F5;
    t = Math.imul(t ^ (t >>> 15), t | 1);
    t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
  };
}

// Shuffle con RNG passato
function shuffleWithRng(arr, rng){
  const a = arr.slice();
  for (let i = a.length - 1; i > 0; i--){
    const j = Math.floor(rng() * (i + 1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}

// buildDeck deterministica
function buildDeckWithRng(level, rng){
  const pool = shuffleWithRng(EMOJI, rng);
  const unique = pool.slice(0, level.pairs);
  const pairs = unique.concat(unique);
  const specials = [
    ...Array(level.red).fill(RED),
    ...Array(level.yellow).fill(YELLOW)
  ];
  const deck = pairs.concat(specials);
  return shuffleWithRng(deck, rng);
}

function todayStr(){
  const d = new Date();
  const y = d.getFullYear();
  const m = String(d.getMonth()+1).padStart(2,'0');
  const day = String(d.getDate()).padStart(2,'0');
  return `${y}-${m}-${day}`;
}

function getDailyChallenge(){
  const today = todayStr();
  const seed = hashString(`skullory_daily_${today}`);
  const rng  = mulberry32(seed);

  // Fissa la daily sul livello 5×5 piena (nessuna cella disabilitata)
  let levelIndex = LEVELS.findIndex(L => L.side === 5 && (!L.disabled || L.disabled.length === 0));
  if (levelIndex < 0) levelIndex = 7; // fallback sicuro se cambi ordine in futuro

  const deck = buildDeckWithRng(LEVELS[levelIndex], rng);
  return { level: levelIndex, deck, date: today, id: `daily_${today}` };
}


// === Record giornaliero (localStorage) ================================
// Ordine: mosse < tempo < stelle; in parità totale vince la PRIMA run.
function isRunBetter(a, b){
  if (!b) return true;
  if (a.moves !== b.moves) return a.moves < b.moves;
  if (a.timeMs !== b.timeMs) return a.timeMs < b.timeMs;
  if (a.stars !== b.stars)   return a.stars > b.stars;
  return (a.ts || 0) < (b.ts || 0);
}
function dailyKey(date){ return `skullory_daily_record_${date}`; }
function readDailyRecord(date){
  try{
    const raw = localStorage.getItem(dailyKey(date));
    return raw ? JSON.parse(raw) : null;
  }catch(_){ return null; }
}
function writeDailyRecord(date, rec){
  try{ localStorage.setItem(dailyKey(date), JSON.stringify(rec)); }catch(_){}
}
function fmtShortSecDiff(ms){
  const sec = Math.max(0, Math.ceil(Math.abs(ms) / 1000));
  return (sec < 10 ? '0' + sec : '' + sec) + 's';
}

  // --- SFX: inizializza al primo gesto utente ---
  function ensureSfx(){
    if (window.__sfxReady) return;
    window.__sfxReady = true;

    try {
      SFX.init();

      if (window.BGM){
        BGM._markInteracted();
        BGM.start();
        BGM.updateUi?.();
      }

      if (!SFX.__wrapped){
        const origPlay = SFX.play.bind(SFX);
        SFX.play = (name, opts = {}) => {
          if (name === 'bgm') {
            if (musicMuted) return null;
            if (opts.volume == null) opts.volume = 0.18;
            opts.loop = (opts.loop !== false);
          } else {
            if (sfxMuted) return null;
          }
          return origPlay(name, opts);
        };
        SFX.__wrapped = true;
      }

      setMusicMuted(musicMuted);
      setSfxMuted(sfxMuted);
      refreshAudioButtons();

    } catch(e){
      window.__sfxReady = false;
    }
  }

function setMusicMuted(v){
  musicMuted = !!v;
  try { localStorage.setItem('skullory.musicMuted', JSON.stringify(musicMuted)); } catch(_) {}

  if (window.BGM) {
    if (musicMuted) {
      try { BGM.setEnabled(false); } catch(_) {}
      try { BGM.stop(); } catch(_) {}
    } else {
      try { BGM.setEnabled(true); } catch(_) {}
      try { BGM.start(); } catch(_) {}
    }
  }
  refreshAudioButtons();
}

function setSfxMuted(v){
  sfxMuted = !!v;
  try { localStorage.setItem('skullory.sfxMuted', JSON.stringify(sfxMuted)); } catch(_) {}
  if (window.SFX && SFX.setSfxMuted) SFX.setSfxMuted(sfxMuted);
  refreshAudioButtons();
}


  // 0 = musica+SFX, 1 = solo SFX, 2 = tutto OFF
  function getAudioMode(){
    if (!musicMuted && !sfxMuted) return 0;
    if (musicMuted && !sfxMuted)  return 1;
    return 2;
  }
  function setAudioMode(mode){
    if (mode === 0){ setMusicMuted(false); setSfxMuted(false); }
    else if (mode === 1){ setMusicMuted(true); setSfxMuted(false); }
    else { setMusicMuted(true); setSfxMuted(true); }
  }
  function cycleAudioMode(){
    const next = (getAudioMode() + 1) % 3;
    setAudioMode(next);
    if (next === 0)      flashMessage('Audio: music + SFX');
    else if (next === 1) flashMessage('Audio: SFX only (music OFF)');
    else                 flashMessage('Audio: muted');
    refreshAudioButtons();
  }

  const grid = document.getElementById('grid');
  const movesEl = document.getElementById('moves');
  const timerEl = document.getElementById('timer');
  const restartBtn = document.getElementById('restart');
  const overlay = document.getElementById('overlay');
  const ovTitle = document.getElementById('ov-title');
  const ovSub = document.getElementById('ov-sub');
  const ovBtn = document.getElementById('ov-btn');
  const ovBtnSkip = document.getElementById('ov-btn-skip');
  function showSkip(v){ if (ovBtnSkip) ovBtnSkip.style.display = v ? '' : 'none'; }
  const pauseBtn = document.getElementById('pause');
  const saveBtn = document.getElementById('save');
  const levelChip = document.getElementById('levelChip');
  const statusChip = document.getElementById('statusChip');
  const scoreChip = document.getElementById('score');
function updateBanners(mode) {
  const container = document.getElementById('mode-banners');
  if (!container) return;

  // Svuota sempre
  container.innerHTML = '';

  // Mostra solo in Zen o Chaos
  if (mode === 'zen') {
    const img = document.createElement('img');
    img.src = 'zen_.svg';
    img.alt = 'Zen banner';
    container.appendChild(img);
  } else if (mode === 'chaos') {
    const img = document.createElement('img');
    img.src = 'chaos_.svg';
    img.alt = 'Chaos banner';
    container.appendChild(img);
  }
}

  const powerRevealBtn = document.getElementById('powerReveal');
  const powerPlus10Btn = document.getElementById('powerPlus10');
  const powerShiftBtn  = document.getElementById('powerShift');

  // 🔊 Bottone unico audio (🎵 → 🔊 → 🔇)
  const audioBtn = document.getElementById('audioCycle');
  if (audioBtn) {
    audioBtn.addEventListener('click', () => {
      ensureSfx();
      cycleAudioMode();
    });
  }

  let musicMuted = JSON.parse(localStorage.getItem('skullory.musicMuted') || 'false');
  let sfxMuted   = JSON.parse(localStorage.getItem('skullory.sfxMuted')   || 'false');
  refreshAudioButtons();

  const restartConfirm = document.getElementById('restartConfirm');
  const restartYes = document.getElementById('restart-yes');
  const restartNo = document.getElementById('restart-no');

  const saveModal = document.getElementById('saveModal');
  const saveList = document.getElementById('saveList');
  const saveNameInput = document.getElementById('saveName');
  const doSaveBtn = document.getElementById('doSave');
  const saveClose = document.getElementById('save-close');

  const intro = document.getElementById('intro');
  const introBtn = document.getElementById('intro-play');
const privacy = document.getElementById('privacy');
const privacyClose = document.getElementById('privacy-close');

// Apri il modale quando tocchi il link/bottone "Privacy" nell'Intro
document.querySelectorAll('[data-open-privacy]').forEach(btn => {
  btn.addEventListener('click', () => openModal(privacy));
});

// Chiudi con la X
if (privacyClose){
  privacyClose.addEventListener('click', () => {
    const opener = privacy.__opener;   // chi ha aperto il modale
    closeModal(privacy);               // chiudi come prima
    opener?.blur?.();                  // e poi togli il focus dal bottone "Privacy"
  });
}


  // ===== TUTORIAL =====
  let currentSlide = 0;
  const slides = [];
  let dotsWrap, prevBtn, nextBtn, closeBtn;
  let allSlides = [];
  let tutorialMode = 'root';
let countBadge, progressWrap, progressBar, hintEl;
  function rebuildDots(){
    dotsWrap.innerHTML = '';
    slides.length = 0;
    const active = allSlides.filter(s => s.dataset.mode === tutorialMode);
    active.forEach(s => slides.push(s));

    allSlides.forEach(s => s.setAttribute('hidden',''));
    slides.forEach(s => s.removeAttribute('hidden'));

    slides.forEach((_, i) => {
      const d = document.createElement('button');
      d.setAttribute('aria-label', `Vai alla slide ${i+1}`);
      d.addEventListener('click', () => goToSlide(i));
      dotsWrap.appendChild(d);
    });

    const multi = slides.length > 1;
    if (prevBtn)  prevBtn.style.display  = multi ? '' : 'none';
    if (nextBtn)  nextBtn.style.display  = multi ? '' : 'none';
    if (dotsWrap) dotsWrap.style.display = multi ? '' : 'none';
  }

  function setTutorialMode(mode){
  tutorialMode = mode;
updateBanners(mode);
  rebuildDots();
  goToSlide(0);

  const introTitle = document.getElementById('intro-title');
  if (introTitle){
    if (mode === 'root') {
      introTitle.style.display = 'none';
    } else {
      introTitle.style.display = '';
    introTitle.textContent =
      mode === 'arcade' ? 'Climb the levels' :
      mode === 'zen'    ? 'Zen - Practice' :
      mode === 'chaos'  ? 'Chaos - Daily Challenge' :
                           '';

    }
  }

  // usa la variabile globale già definita in alto: const introBtn = document.getElementById('intro-play');
  if (introBtn){
    if (mode === 'arcade'){
      introBtn.textContent = 'Play (Arcade)';
      introBtn.onclick = () => { ensureSfx(); modeZen = false; currentLevelIdx = 0; hideIntro(); startArcade(); };
      introBtn.style.display = '';
    } else if (mode === 'zen'){
      introBtn.textContent = 'Play (Zen)';
      introBtn.onclick = () => { ensureSfx(); modeZen = true; hideIntro(); startZen('zen'); };
      introBtn.style.display = '';
   } else if (mode === 'chaos'){
  introBtn.textContent = 'Play (Daily challenge)';
  introBtn.onclick = () => { ensureSfx(); startDailyChaos(); };
  introBtn.style.display = '';
    } else {
      // root e zen-choose: niente tasto play centrale (si usano i bottoni nella slide)
      introBtn.textContent = 'Gioca';
      introBtn.onclick = () => {};
      introBtn.style.display = 'none';
    }
  }
  // Mostra il link "Privacy" solo nel menu iniziale (root)
  const introLegal = document.querySelector('.intro-legal');
  if (introLegal) introLegal.style.display = (mode === 'root') ? '' : 'none';
if (closeBtn) closeBtn.style.display = (mode === 'root') ? 'none' : '';

}

function buildTutorialRefs(){
  dotsWrap = document.getElementById('intro-dots');
  prevBtn  = document.getElementById('intro-prev');
  nextBtn  = document.getElementById('intro-next');
  closeBtn = document.getElementById('intro-close');
countBadge   = document.getElementById('intro-count');
progressWrap = document.getElementById('intro-progress-wrap');
progressBar  = document.getElementById('intro-progress');
hintEl       = document.getElementById('intro-hint');


  allSlides = Array.from(document.querySelectorAll('#intro .tutorial-slide'));

  // Frecce
  prevBtn.addEventListener('click', () => goToSlide(currentSlide - 1));
  nextBtn.addEventListener('click', () => goToSlide(currentSlide + 1));

  // X in alto a destra: se sei già nella root, chiudi; altrimenti torna alla root
  closeBtn.onclick = () => {
    if (tutorialMode === 'root') hideIntro();
    else setTutorialMode('root');
  };

  // Tastiera
  document.addEventListener('keydown', (e) => {
    if (intro.classList.contains('hide')) return;
    if (e.key === 'ArrowLeft')  goToSlide(currentSlide - 1);
    if (e.key === 'ArrowRight') goToSlide(currentSlide + 1);
  });

  // Bottoni della slide root (menu unico)
  const btnChaosMain  = document.getElementById('intro-chaos-main');
  const btnArcadeMain = document.getElementById('intro-arcade-main');
  const btnZenMain    = document.getElementById('intro-zen-main');

  if (btnChaosMain)  btnChaosMain.addEventListener('click',  () => setTutorialMode('chaos'));
  if (btnArcadeMain) btnArcadeMain.addEventListener('click', () => setTutorialMode('arcade'));
  if (btnZenMain)    btnZenMain.addEventListener('click',    () => setTutorialMode('zen'));


  // Mostra la root all’apertura
  setTutorialMode('root');
}


  function goToSlide(i){
    currentSlide = Math.max(0, Math.min(slides.length - 1, i));
    slides.forEach((el, idx) => {
      if (idx === currentSlide) el.removeAttribute('hidden');
      else el.setAttribute('hidden', '');
    });

    Array.from(dotsWrap.children).forEach((dot, idx) => {
      dot.setAttribute('aria-current', idx === currentSlide ? 'true' : 'false');
    });

    prevBtn.disabled = (currentSlide === 0);
    nextBtn.disabled = (currentSlide === slides.length - 1);
updateTutorialUI();

  }
function updateTutorialUI(){
  const total = slides.length || 1;
  const n = Math.min(total, Math.max(1, currentSlide + 1));
  const multi = total > 1;

  // Mostra UI di avanzamento SOLO per Arcade con più di 1 slide
  const showUi = (tutorialMode === 'arcade' && multi);

  // Badge 1/3
  if (countBadge){
    countBadge.textContent = `${n}/${total}`;
    countBadge.hidden = !showUi;
  }

  // Progress bar
  if (progressWrap){
    progressWrap.hidden = !showUi;
    progressWrap.setAttribute('aria-hidden', showUi ? 'false' : 'true');
  }
  if (progressBar && showUi){
    progressBar.style.width = `${(n/total)*100}%`;
  }

  // Micro-hint: solo prima visita Arcade, solo se multi e sulla 1ª slide
  if (hintEl){
    const KEY = 'skullory.arcadeHintShown';
    const shouldShow = showUi && currentSlide === 0 && !localStorage.getItem(KEY);
    hintEl.hidden = !shouldShow;
    if (shouldShow){
      setTimeout(() => {
        hintEl.hidden = true;
        localStorage.setItem(KEY, '1');
      }, 3500);
    }
  }
}


function showIntro(){
  intro.classList.remove('hide');
  intro.classList.add('show');
  if (slides.length === 0) buildTutorialRefs();
  setTutorialMode('root');
  openModal(intro);            // focus-trap anche per l’intro
}
function hideIntro(){
  closeModal(intro);           // ripristina focus al bottone che l’ha aperta
  intro.classList.add('hide');
  intro.classList.remove('show');
}


  let state;
  let currentLevelIdx = 0;
  let totalScore = 0;
  let themeIndex = 1;
  let frameBaseScore = 0;
  let activeSaveName = localStorage.getItem('skullory_active_save') || '';

  function setActiveSaveName(name){
    activeSaveName = name || '';
    try {
      if (activeSaveName) localStorage.setItem('skullory_active_save', activeSaveName);
      else localStorage.removeItem('skullory_active_save');
    } catch(_) {}
  }

  function refreshAudioButtons(){
    // NUOVO: bottone unico ciclico
    if (typeof getAudioMode === 'function' && audioBtn){
      const mode = getAudioMode(); // 0=tutto ON, 1=solo SFX, 2=tutto OFF

      if (mode === 0){
        audioBtn.textContent = '🎵';
        audioBtn.title = 'Audio: music + SFX';
        audioBtn.setAttribute('aria-label','Audio: musica + effetti');
      } else if (mode === 1){
        audioBtn.textContent = '🔊';
        audioBtn.title = 'Audio: SFX only (music OFF)';
        audioBtn.setAttribute('aria-label','Audio: solo effetti (musica OFF)');
      } else {
        audioBtn.textContent = '🔇';
        audioBtn.title = 'Audio: muted';
        audioBtn.setAttribute('aria-label','Audio: spento');
      }
    }
  }

  let pendingCheck = null;
/* --- Tap buffer hardening (epoch/tag) --- */
let tapBuffer = [];
const TAP_BUFFER_MAX = 2;
let boardEpoch = 0;                       // sale quando la board “cambia”

function bumpEpoch(){
  boardEpoch++;
  // scarta eventuali tap rimasti dal “vecchio” layout
  tapBuffer = tapBuffer.filter(e => e.epoch === boardEpoch);
}

function enqueueTap(card){
  // accetta solo target ancora validi e coperti
  if (!card || !card.isConnected || card.classList.contains('placeholder')) return;
  if (card.getAttribute('data-state') !== 'hidden') return;
  // evita duplicati sulla stessa carta/epoca
  if (tapBuffer.find(e => e.el === card && e.epoch === boardEpoch)) return;
  if (tapBuffer.length >= TAP_BUFFER_MAX) return;
  tapBuffer.push({ el: card, epoch: boardEpoch });
}

function drainTapBuffer(){
  while (tapBuffer.length){
    const { el, epoch } = tapBuffer.shift();
    if (epoch !== boardEpoch) continue; // board cambiata → scarta
    if (el && el.isConnected && el.getAttribute('data-state') === 'hidden'){
      onCardClick(el);                   // processa UN solo tap valido
      break;
    }
  }
}

  let progress = LEVELS.map(L => ({
    streak: 0,
    unlocked: false,
    baseTimeMs: L.unlockMs[0],
    postUnlockWins: 0,
    carryBonusMs: 0
  }));

  function setCols(n){ document.documentElement.style.setProperty('--cols', n); }
  function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } return a; }
  function fmt(ms){ const s = Math.max(0, Math.floor(ms/1000)); const mm = Math.floor(s/60), ss = s%60; return `${mm}:${ss.toString().padStart(2,'0')}`; }
  function calcElapsedMs(){
    const now = performance.now();
    return Math.max(0, now - (state.frameStartTs || now));
  }
  function calcZenEfficiency(moves, level){
    const free = freeMovesFor(level);
    if (moves <= free) return 100;
    const over = moves - free;
    return Math.max(50, Math.round(100 - over));
  }
// Da % efficienza a numero stelle (1..5)
function effToStars(eff){
  // Soglie consigliate (tienile pure come vuoi):
  // 96–100 => 5 ⭐, 90–95 => 4 ⭐, 80–89 => 3 ⭐, 70–79 => 2 ⭐, <70 => 1 ⭐
  if (eff >= 96) return 5;
  if (eff >= 90) return 4;
  if (eff >= 80) return 3;
  if (eff >= 70) return 2;
  return 1;
}

// Etichetta testuale carina per il rating
function starsLabel(n){
  return (
    n === 5 ? 'Eccellente! (5/5)' :
    n === 4 ? 'Ottimo! (4/5)' :
    n === 3 ? 'Buono! (3/5)' :
    n === 2 ? 'Discreto (2/5)' :
              'Da ritentare (1/5)'
  );
}
// === Zen: calcolo stelle su 5 con mezze stelle (0.5 step) ===
function computeZenStars(moves, elapsedMs, level){
  const pairs = level.pairs;

  // --- Punteggio MOSSE (più pesante)
  // Perfetto = pairs; "buono" ~2.5×; "ok" ~4× (tarabile)
  const M_best = pairs;
  const M_good = Math.round(pairs * 2.5);
  const M_ok   = Math.round(pairs * 4.0);

  let mScore; // [0..1]
  if (moves <= M_best) mScore = 1;
  else if (moves >= M_ok) mScore = 0;
  else if (moves <= M_good){
    // Degrada da 1 → 0.5
    mScore = 1 - (moves - M_best) / (M_good - M_best) * 0.5;
  } else {
    // Degrada da 0.5 → 0
    mScore = 0.5 - (moves - M_good) / (M_ok - M_good) * 0.5;
  }

  // --- Punteggio TEMPO (più leggero)
  // Scala col numero di coppie: ~6s ottimo, 10s buono, 16s ok per coppia
  const T_best = pairs * 6 * 1000;
  const T_good = pairs * 10 * 1000;
  const T_ok   = pairs * 16 * 1000;

  let tScore; // [0..1]
  if (elapsedMs <= T_best) tScore = 1;
  else if (elapsedMs >= T_ok) tScore = 0;
  else if (elapsedMs <= T_good){
    tScore = 1 - (elapsedMs - T_best) / (T_good - T_best) * 0.5;
  } else {
    tScore = 0.5 - (elapsedMs - T_good) / (T_ok - T_good) * 0.5;
  }

  // Combina: mosse contano di più (70/30)
  const combined = Math.max(0, Math.min(1, 0.7*mScore + 0.3*tScore));

  // Mappa a 1..5 stelle, poi arrotonda a mezze stelle
  const rawStars = 1 + 4*combined;
  const starsHalf = Math.round(rawStars * 2) / 2;
  return starsHalf;
}

// Format tipo "⭐3.5"
function fmtStars(n){
  return '⭐' + (Number.isInteger(n) ? n.toFixed(0) : n.toFixed(1));
}

  function markFrameStart(){ state.frameStartTs = performance.now(); }

  function rotateTheme(){
    themeIndex = themeIndex % 10 + 1;
    const b = document.body;
    b.className = (b.className || '').replace(/\btheme-\d+\b/g, '').trim();
    b.classList.add('theme-' + themeIndex);
  }

  function updateStatusChip(){
    const p = progress[currentLevelIdx];
    const extra = !p.unlocked ? (p.carryBonusMs || 0) : 0;
    const baseSec = Math.max(0, p.baseTimeMs + extra) / 1000 | 0;
    if(!p.unlocked){
      statusChip.textContent = `Unlock ${p.streak}/3 · ${baseSec}s`;
    } else {
      statusChip.textContent = `Grind ${p.postUnlockWins} · ${baseSec}s`;
    }
  }

  function buildDeck(level){
    const pool = EMOJI.slice();
    const unique = shuffle(pool).slice(0, level.pairs);
    const pairs = unique.concat(unique);
    const specials = [ ...Array(level.red).fill(RED), ...Array(level.yellow).fill(YELLOW) ];
    const deck = pairs.concat(specials);
    return shuffle(deck);
  }
  function getActiveCards(){
    return Array.from(grid.querySelectorAll('.card'))
      .filter(c => !c.classList.contains('placeholder'));
  }
  function getCardByIndex(idx){ return grid.querySelector(`.card[data-index="${idx}"]`); }
// Una carta "normale" = non placeholder, non matched, non speciale
function isNormalCard(c){
  return !!(c && c.classList.contains('card') &&
            !c.classList.contains('placeholder') &&
            c.getAttribute('data-state') !== 'matched' &&
            c.dataset.symbol !== RED && c.dataset.symbol !== YELLOW);
}

// Chiudi le eventuali carte normali attualmente aperte (prima/seconda)
function closeOpen(ms = MISMATCH_HOLD_MS){
  if (!state.open || !state.open.length) { state.pivot = null; return; }
  state.open.forEach(c => scheduleHide(c, ms));
  state.open = [];
  state.pivot = null;
}

// Normalizza lo stato “aperto” leggendo il DOM (rete di sicurezza)
function syncOpenFromDom(){
  const open = getActiveCards().filter(
    c => c.getAttribute('data-state') === 'revealed' && isNormalCard(c)
  );
  // Al massimo 2 carte aperte; se di più (stato sporco) chiudi le extra
  if (open.length > 2){
    open.slice(0, open.length - 2).forEach(c => scheduleHide(c, 0));
  }
  state.open = open.slice(-2);
  state.pivot = state.open[0] || null;
}

  // --- MOSSE & PUNTEGGIO ---
  function freeMovesFor(level){ return level.side * level.side; }
  function efficiencyMultiplier(moves, free){
    const delta = moves - free;
    if (delta <= 0){
      const bonus = Math.min(0.30, 0.02 * (-delta));
      return 1 + bonus;
    } else {
      return Math.max(0.5, 1 - 0.05 * delta);
    }
  }
  function roundNearest(n){ return Math.round(n); }
  function updateScoreChip(){ if(scoreChip) scoreChip.textContent = `Score: ${totalScore}`; }

  function canSaveNow(){
  if (state?.isZen) return false; 
    const endOfFrame = overlay.classList.contains('show');
    const freshStart = !state.running && state.moves === 0 && state.matched === 0;
    return endOfFrame || freshStart;
  }
function updateSaveButton(){
  if (!saveBtn) return;

  if (state?.isZen){
    // In modalità Zen non si salva mai
    saveBtn.disabled = true;
    saveBtn.style.opacity = '0.6';
    saveBtn.title = 'Saving is disabled in Zen';
    return;
  }

  const ok = canSaveNow();
  saveBtn.disabled = !ok;
  saveBtn.style.opacity = ok ? '1' : '0.6';
  saveBtn.title = 'Save available only at the end of a board or before starting';
}

function isPreFrame(){
  return !!state && !state.running && state.moves === 0 && state.matched === 0;
}

  function anyOverlayOpen(){
    return overlay.classList.contains('show')
        || restartConfirm.classList.contains('show')
        || saveModal.classList.contains('show')
        || (intro && !intro.classList.contains('hide'));
  }

  function canUsePowersBase(){
    if (state?.isZen) return false;
    return !!state
        && state.running
        && !state.paused
        && !state.lock
        && !anyOverlayOpen()
        && !(sim && sim.active)
        && !document.body.classList.contains('mode-simon');
  }

  function addTimeMs(ms){
    if (state?.isZen) return;
    const now = performance.now();
    state.deadlineTs += ms;
    state.leftMs = Math.max(0, state.deadlineTs - now);
    updateTime();
  }
  function takeTimeMs(ms){ addTimeMs(-Math.max(0, ms)); }

  function refreshPowersUI(){
    if (!powerRevealBtn || !powerPlus10Btn || !powerShiftBtn) return;

    if (state?.isZen){
      [powerRevealBtn, powerPlus10Btn, powerShiftBtn].forEach(b => {
        if (!b) return;
        b.classList.remove('ready');
        b.setAttribute('aria-disabled','true');
      });
      return;
    }

    const base = canUsePowersBase();
    const haveOnePair = state.matched >= 1;
    const skullSeen = state.redFlips >= 1;

    const revealCost = Math.max(4000, Math.floor(state.leftMs * 0.20));
    const safeAfterReveal = (state.leftMs - revealCost) >= 3000;

    const canReveal = base && !state.powerUsed.reveal && haveOnePair && safeAfterReveal;
    const canPlus10 = base && !state.powerUsed.plus10 && haveOnePair;
    const canShift  = base && !state.powerUsed.shift  && skullSeen;

    setPowerState(powerRevealBtn, canReveal);
    setPowerState(powerPlus10Btn, canPlus10);
    setPowerState(powerShiftBtn,  canShift);
  }
  function setPowerState(btn, enabled){
    btn.classList.toggle('ready', !!enabled);
    btn.setAttribute('aria-disabled', String(!enabled));
  }

  function getHiddenNonSpecialCards(){
    return getActiveCards().filter(c =>
      c.getAttribute('data-state') === 'hidden' &&
      c.dataset.symbol !== RED && c.dataset.symbol !== YELLOW
    );
  }
  function getMatchedPairs(){
    const map = new Map();
    getActiveCards().forEach(c => {
      if (c.getAttribute('data-state') === 'matched'){
        const s = c.dataset.symbol;
        if (s === RED || s === YELLOW) return;
        if (!map.has(s)) map.set(s, []);
        map.get(s).push(c);
      }
    });
    return Array.from(map.entries()).filter(([_, arr]) => arr.length === 2);
  }
function chaosSkullPenalty(card){
  // Chiudi eventuali normali aperte e gestisci suoni/UX
  closeOpen(MISMATCH_HOLD_MS);
  try { SFX.play?.('skull', { volume:.95, rate:.98 }); } catch(_) {}

  // Chiudi pivot se era rivelato
  const pivot = state?.pivot;
  if (isValidPivotEl(pivot)) scheduleHide(pivot, MISMATCH_HOLD_MS);
  state.pivot = null;

  // 1) Pulisci riferimenti ai buchi non più nel DOM e leggi i buchi attuali
  state.holesEls = (state.holesEls || []).filter(h => h && h.isConnected && h.classList.contains('hole'));
  const holes = state.holesEls.slice();

  // 2) Calcola un simbolo NUOVO rispetto alle coperte non speciali
  const poolCovered = getHiddenNonSpecialCards(); // carte coperte normali
  const coveredSyms = new Set(poolCovered.map(c => c.dataset.symbol));
  const candidates  = EMOJI.filter(s => !coveredSyms.has(s));
  const newSym = candidates.length
    ? candidates[(Math.random()*candidates.length)|0]
    : EMOJI[(Math.random()*EMOJI.length)|0]; // fallback

  // Helper: crea una carta "nuova" in posizione buco (stesso markup di init)
  function spawnCardInHole(holeEl, symbol){
    const idx  = +holeEl.dataset.index;
    const card = document.createElement('div');
    card.className = 'card';
    card.dataset.index  = String(idx);
    card.dataset.symbol = symbol;
    card.setAttribute('data-state','hidden');
    card.setAttribute('role','button');
    card.setAttribute('tabindex','0');
    card.setAttribute('aria-label','Carta di Skullory');

    const inner = document.createElement('div'); inner.className = 'inner';
    const back  = document.createElement('div'); back.className  = 'face back';
    const front = document.createElement('div'); front.className = 'face front';
    const sym   = document.createElement('div'); sym.className   = 'symbol'; sym.textContent = symbol;
    front.appendChild(sym); inner.append(back, front); card.append(inner);

    card.addEventListener('click',   ()  => onCardClick(card));
    card.addEventListener('keydown', (ev) => { if(ev.key==='Enter'||ev.key===' '){ ev.preventDefault(); onCardClick(card); } });

    grid.replaceChild(card, holeEl);
    return card;
  }

  // 3) Se abbiamo almeno DUE buchi → crea la coppia direttamente nei buchi
  if (holes.length >= 4){
    const i1 = (Math.random()*holes.length | 0);
    let   i2 = (Math.random()*holes.length | 0);
    if (i2 === i1) i2 = (i2 + 1) % holes.length;

spawnCardInHole(holes[i1], newSym);
spawnCardInHole(holes[i2], newSym);

// ✅ aggiorna il target della board
state.level.pairs = (state.level.pairs || 0) + 1;
state._spawnedPairs = (state._spawnedPairs || 0) + 1;

flashMessage('💀 Spawned a new pair in holes!');
try { SFX.play?.('reshuffle', { volume:.9 }); } catch(_) {}

// 🔀 rimescola le coperte non speciali (inclusa la nuova coppia)
setTimeout(() => {
  try { reshuffleHiddenNonSpecial(); } catch(_) {}
  bumpEpoch();  // la board è cambiata di nuovo: invalida i tap precedenti
}, 30);

// richiudi il teschio
scheduleHide(card, MISMATCH_HOLD_MS);
return;
  }

// 4) Fallback (nuova regola): niente nuova coppia; solo reshuffle per non “sprecare” il tocco
flashMessage('💀 🔀');
try { reshuffleHiddenNonSpecial(); } catch(_) {}
scheduleHide(card, MISMATCH_HOLD_MS);
return;

  // 5) Ultimo fallback: non c’è spazio → rimescola solo per non “sprecare” il tocco
  flashMessage('💀 Not enough space… 🔀');
  reshuffleHiddenNonSpecial();
  scheduleHide(card, MISMATCH_HOLD_MS);
}


function isSpecialSymbol(sym){ return sym === RED || sym === YELLOW; }
function isValidPivotEl(el){
  return !!(el
    && el.isConnected
    && !el.classList.contains('placeholder') // niente buchi/placeholder
    && el.getAttribute('data-state') === 'revealed'
    && !isSpecialSymbol(el.dataset.symbol)   // niente ⚡/💀 come pivot
  );
}

  function usePowerReveal(){
    const baseOk = canUsePowersBase();
    if (!baseOk || state.powerUsed.reveal || state.matched < 1){
      if (isPreFrame()) explainPower('reveal');
      return;
    }

    const cost = Math.max(4000, Math.floor(state.leftMs * 0.20));
    if ((state.leftMs - cost) < 3000) { refreshPowersUI(); return; }

    ensureSfx();
    state.powerUsed.reveal = true;
    takeTimeMs(cost);
    flashMessage(`👁️ Reveal all (−${Math.ceil(cost/1000)}s)`);
    SFX.play?.('flip', { volume:.85 });

    const cards = getActiveCards();
    const prev = new Map(cards.map(c => [c, c.getAttribute('data-state')]));

    const prevLock = state.lock;
    state.lock = true;

    cards.forEach(c => c.setAttribute('data-state', 'revealed'));

    setTimeout(() => {
      cards.forEach(c => c.setAttribute('data-state', prev.get(c)));
      state.lock = prevLock;
drainTapBuffer();
      refreshPowersUI();
    }, 1000);
  }

  function usePowerPlus10(){
    const baseOk = canUsePowersBase();
    if (!baseOk || state.powerUsed.plus10 || state.matched < 1){
      if (isPreFrame()) explainPower('plus10');
      return;
    }

    const pairs = getMatchedPairs();
    if (!pairs.length){ refreshPowersUI(); return; }

    ensureSfx();
    state.powerUsed.plus10 = true;

    const [symSac, cardsSac] = pairs[(Math.random() * pairs.length) | 0];

    const pool = getHiddenNonSpecialCards();
    shuffle(pool);

    cardsSac.forEach(c => c.setAttribute('data-state','hidden'));
    state.matched = Math.max(0, state.matched - 1);

    if (pool.length >= 2){
      const t1 = pool[0], t2 = pool[1];
      const t1Sym = t1.dataset.symbol, t2Sym = t2.dataset.symbol;

      t1.dataset.symbol = symSac; t1.querySelector('.symbol').textContent = symSac;
      t2.dataset.symbol = symSac; t2.querySelector('.symbol').textContent = symSac;

      cardsSac[0].dataset.symbol = t1Sym; cardsSac[0].querySelector('.symbol').textContent = t1Sym;
      cardsSac[1].dataset.symbol = t2Sym; cardsSac[1].querySelector('.symbol').textContent = t2Sym;
    }
    addTimeMs(10000);
    flashMessage('+10s • Pair undone');
    SFX.play?.('bonus5', { volume:1.0 });

    refreshPowersUI();
  }

  function usePowerShift(){
    const baseOk = canUsePowersBase();
    if (!baseOk || state.powerUsed.shift || state.redFlips < 1){
      if (isPreFrame()) explainPower('shift');
      return;
    }

    ensureSfx();
    state.powerUsed.shift = true;

    const specials = getActiveCards().filter(c => c.dataset.symbol === RED || c.dataset.symbol === YELLOW);
    let pool = getHiddenNonSpecialCards();
    shuffle(pool);

    for (let i=0; i<specials.length && i<pool.length; i++){
      const s = specials[i];
      const t = pool[i];

      const tSym = t.dataset.symbol;
      const sSym = s.dataset.symbol;

      t.dataset.symbol = sSym; t.querySelector('.symbol').textContent = sSym;
      s.dataset.symbol = tSym; s.querySelector('.symbol').textContent = tSym;
    }

    reshuffleHiddenNonSpecial();

    state.redFlips = 0;

    addTimeMs(15000);
    flashMessage('🌀 Specials moved • +15s');
    SFX.play?.('reshuffle', { volume:.9 });

    refreshPowersUI();
  }

  function startArcade(){ init(currentLevelIdx || 0); }

function startZen(variant = 'zen'){
updateBanners('zen');
  zenVariant = (variant === 'chaos') ? 'chaos' : 'zen';
  const idx5base = LEVELS.findIndex(L => L.side === 5 && (!L.disabled || L.disabled.length === 0));
  const idx5any  = LEVELS.findIndex(L => L.side === 5);
  const target   = (idx5base >= 0) ? idx5base : (idx5any >= 0 ? idx5any : 0);
  init(target);
}
function startDailyChaos(){
updateBanners('chaos');
  // Daily = Zen 'chaos' + deck deterministica del giorno
  zenVariant = 'chaos';
  modeZen = true;

  const daily = getDailyChallenge();
  hideIntro();
  init(daily.level, {
    deckOverride: daily.deck,
    dailyMeta: { id: daily.id, date: daily.date }
  });
}

function init(levelIdx = currentLevelIdx, opts = {}){
  rotateTheme();

  const L = LEVELS[levelIdx];
  currentLevelIdx = levelIdx;
  setCols(L.side);
  levelChip.textContent = `Level: ${levelIdx+1}/${LEVELS.length}`;
  updateStatusChip();

  if (pendingCheck) { clearTimeout(pendingCheck); pendingCheck = null; }
  state = {
    level: L,
    deck: opts.deckOverride || buildDeck(L), // usa la deck della daily se passata
    pivot: null, matched: 0, moves: 0,
    hideTimers: new Map(),
    running: false, startTs: 0,
    leftMs: Math.max(0, progress[levelIdx].baseTimeMs + (!progress[levelIdx].unlocked ? (progress[levelIdx].carryBonusMs || 0) : 0)),
    lock: false,
    redFlips: 0, yellowFlips: 0,
    paused: false, streak: 0, lastMatchTime: 0, totalBonusMs: 0,
    deadlineTs: 0,
    pauseLeftMs: 0,
    powerUsed: { reveal:false, plus10:false, shift:false },
    holesEls: [],
    yellowReveals: new WeakMap(),
    preAppliedBonusMs: 0,
    startBonusMs: 0,
open: [],            // <— elenco carte normali attualmente aperte (max 2)
frameStartTs: 0,     // (già usata altrove, ma teniamola coerente)
    // flag/metadati daily:
    isDaily: !!opts.dailyMeta,
    dailyMeta: opts.dailyMeta || null
  };

  // === UI: nascondi chip e poteri in Zen + CENTRA i 5 bottoni ===
  if (modeZen) {
    if (levelChip)  levelChip.style.display  = 'none';
    if (statusChip) statusChip.style.display = 'none';
    if (scoreChip)  scoreChip.style.display  = 'none';
    if (movesEl)    movesEl.style.display    = 'none';
    if (timerEl)    timerEl.style.display    = 'none';

    const cr = document.querySelector('.controls-right');
    if (cr) cr.style.display = 'none';

    const cb = document.querySelector('.controls-bottom');
    const cl = document.querySelector('.controls-left');
    if (cb) cb.style.justifyContent = 'center';
    if (cl) cl.style.margin = '0 auto';
    if (saveBtn) saveBtn.style.display = 'none';
  } else {
    if (levelChip)  levelChip.style.display  = '';
    if (statusChip) statusChip.style.display = '';
    if (scoreChip)  scoreChip.style.display  = '';
    if (movesEl)    movesEl.style.display    = '';
    if (timerEl)    timerEl.style.display    = '';

    const cr = document.querySelector('.controls-right');
    if (cr) cr.style.display = '';

    const cb = document.querySelector('.controls-bottom');
    const cl = document.querySelector('.controls-left');
    if (cb) cb.style.justifyContent = 'space-between';
    if (cl) cl.style.margin = '';
    if (saveBtn) saveBtn.style.display = '';
  }

  if (modeZen){
    if (timerEl){
      timerEl.textContent = '—';
      timerEl.style.opacity = .65;
    }
    state.isZen = true;
    state.isChaos = (zenVariant === 'chaos');
  } else {
    state.isZen = false;
    state.isChaos = false;
  }

  updateSaveButton?.();
  refreshPowersUI?.();
  markFrameStart?.();

  // === costruzione griglia ===
  grid.innerHTML = '';
  const frag = document.createDocumentFragment();

  const disabled = new Set((L.disabled || []).map(Number));
  let deckPtr = 0;

  for (let i = 0; i < L.side * L.side; i++){
    if (disabled.has(i)){
      const placeholder = document.createElement('div');
      placeholder.className = 'card placeholder';
      placeholder.setAttribute('aria-hidden','true');
      frag.appendChild(placeholder);
      continue;
    }

    const symbol = state.deck[deckPtr++];
    const card = document.createElement('div');
    card.className = 'card';
    card.dataset.index = i;
    card.dataset.symbol = symbol;
    card.setAttribute('data-state','hidden');
    card.setAttribute('role','button');
    card.setAttribute('tabindex','0');
    card.setAttribute('aria-label','Carta di Skullory');

    const inner = document.createElement('div'); inner.className = 'inner';
    const back  = document.createElement('div'); back.className  = 'face back';
    const front = document.createElement('div'); front.className = 'face front';
    const sym   = document.createElement('div'); sym.className   = 'symbol'; sym.textContent = symbol;
    front.appendChild(sym); inner.append(back, front); card.append(inner);

    card.addEventListener('click', () => onCardClick(card));
    card.addEventListener('keydown', (ev) => { if(ev.key==='Enter'||ev.key===' '){ ev.preventDefault(); onCardClick(card); } });

    frag.appendChild(card);
  }

  grid.appendChild(frag);
bumpEpoch(); // NEW: nuova board → invalida tap della precedente
  tapBuffer = [];
  updateHud();
  updateScoreChip();
  hideOverlay();
  updateSaveButton();
  refreshPowersUI();
}

  function startTimer(){
    if(state.paused) return;
    if(state.running) return;

    if (state.isZen){
      state.running = true;
      frameBaseScore = totalScore;
      updateSaveButton();
      return;
    }

    state.running = true;
    frameBaseScore = totalScore;
    const now = performance.now();
    state.startTs = now;

    const p = progress[currentLevelIdx];
    const carry = !p.unlocked ? (p.carryBonusMs || 0) : 0;
    const base = Math.max(0, p.baseTimeMs + carry);

    state.deadlineTs = now + base;
    tick();
    updateSaveButton();
  }

  function tick(){
    if (state?.isZen) return;
    if(!state.running || state.paused) return;
    const now = performance.now();
    state.leftMs = Math.max(0, state.deadlineTs - now);
    updateTime();
    if(state.leftMs<=0){ state.running=false; lose('Time’s up ⏰'); return; }
    requestAnimationFrame(tick);
  }

  function updateTime() {
    if (state?.isZen) return;
    timerEl.textContent = fmt(state.leftMs);
  }

  function updateHud(){
    if (!state?.isZen){
      movesEl.textContent = `Moves: ${state.moves}`;
      timerEl.textContent = fmt(state.leftMs);
    }
    updateStatusChip();
    updateScoreChip();
  }

function onCardClick(card){
  ensureSfx();

  // Simon attivo → stessa gestione di prima
  if (sim && sim.active){ simonOnTap(card); return; }

  SFX.play?.('tap', { volume:.5, rate: 0.98 + Math.random()*0.04 });

  // Pausa/Lock: bufferizza al massimo 2 tocchi utili
  if (state.paused) { flashMessage('Paused ▶'); return; }
if (state.lock){
  enqueueTap(card);
  return;
}


  // Ignora click su rivelate/matched
  // Consenti il tap su special rivelati; blocca solo le normali già rivelate
if (card.dataset.state === 'matched') return;
if (card.dataset.state === 'revealed' && !isSpecialSymbol(card.dataset.symbol)) return;

  // Avvia timer all'effettivo primo gesto di gioco
  startTimer();

  const sym = card.dataset.symbol;
// Safety: se c'è in giro qualche special (⚡/💀) rivelato diverso da quello cliccato, richiudilo
getActiveCards()
  .filter(el => el !== card && el.getAttribute('data-state') === 'revealed' && isSpecialSymbol(el.dataset.symbol))
  .forEach(el => {

    scheduleHide(el, 0); // chiudi subito
  });

  // --- Speciali: ⚡ / 💀 — chiudi l’eventuale carta “prima” aperta e gestisci
  if (sym === RED){
    // Se c'era una normale aperta, chiudila per evitare “singole persistenti”
    closeOpen(MISMATCH_HOLD_MS);

    state.redFlips++;
    refreshPowersUI();
    try { SFX.play('skull', { volume:.9, rate:.98 }); } catch(_) {}
    flip(card, true);

    if (state.isChaos){
      chaosSkullPenalty(card);
      return;
    }

    if (state.redFlips >= 2){
      setTimeout(() => {
        if (state.isZen) showZenSkullLose();
        else lose('Oh no! 💀', 'You revealed the skull twice!'); // fallback modalità arcade
      }, 220);
      return;
    }

    // ⬇️ SOLO ZEN: il teschio si sposta dopo l'attivazione, poi si richiude
    if (state.isZen){
      flashOnce('tip_tp_red', '💀 moved!');
      teleportAfterReveal(card, { kind: 'red' });
      return;
    }

    // altre modalità: comportamento invariato
    scheduleHide(card, MISMATCH_HOLD_MS);
    return;
  }

if (sym === YELLOW){
  // Chiudi eventuali normali aperte per non “sporcare” la mossa
  closeOpen(MISMATCH_HOLD_MS);

  // 🔢 In CHAOS contiamo i tap sullo stesso ⚡ (indipendente da yellowArmed)
  if (state.isChaos){
    state.yellowReveals = state.yellowReveals || new Map();
    const prev = state.yellowReveals.get(card) || 0;
    const now  = prev + 1;
    state.yellowReveals.set(card, now);

    // Rivela e mescola
    flip(card, true);
    flashMessage('Shuffle!');
    reshuffleHiddenNonSpecial();

    if (now >= 2){
      // 2º tap sullo stesso ⚡ → diventa buco (come in "Chaos ok")
      makeHole(card);
      return; // niente scheduleHide: la carta non c’è più
    }

    // 1º tap: richiudi dopo il mescolo
    scheduleHide(card, MISMATCH_HOLD_MS);
    return;
  }

  // --- Arcade / Zen (comportamento attuale, che è già ok) ---
// --- Arcade / Zen — always reshuffle, no arm/disarm ---
  // --- Arcade / Zen — rimescola sempre le coperte non speciali
  flip(card, true);
  flashMessage('Shuffle!');
  reshuffleHiddenNonSpecial();

  // ⬇️ SOLO ZEN: dopo l'attivazione il fulmine si sposta, poi si richiude
  if (state.isZen){
    flashOnce('tip_tp_yellow', '⚡ moved!');
    teleportAfterReveal(card, { kind: 'yellow' });
    return;
  }

  // altre modalità: comportamento invariato
  scheduleHide(card, MISMATCH_HOLD_MS);
  return;

}


  // --- Normale: applichiamo la regola “max 2 aperte” robusta ---
  syncOpenFromDom(); // rete di sicurezza (in caso di stati ereditati da prima)

  // Apri la carta cliccata
  flip(card, true);

  // Caso 1: è la prima normale aperta
  if (state.open.length === 0){
    state.open = [card];
    state.pivot = card;
    return;
  }

  // Caso 2: è la seconda normale aperta → confronto
  if (state.open.length === 1){
    const first = state.open[0];
    const second = card;

    state.moves++;
    if (!state.isZen) movesEl.textContent = `Moves: ${state.moves}`;

    const aSym = first.dataset.symbol;
    const bSym = second.dataset.symbol;
    const isMatch = (aSym === bSym);

    if (isMatch){
  // Cancella eventuali richiuse pendenti
  cancelHide(first); cancelHide(second);

  // Bonus tempo (lascia com'era)
  const now = performance.now();
  if (!state.isZen){
    state.deadlineTs += 1000;            // +1s
    state.leftMs = Math.max(0, state.deadlineTs - now);
    updateTime();
    flashMessage('+1s');
    SFX.play?.('bonus1', { volume:.85, rate: 1.02 });

    if (state.streak >= 1 && (now - state.lastMatchTime) < 5000){
      state.deadlineTs += 5000;          // +5s combo
      state.leftMs = Math.max(0, state.deadlineTs - performance.now());
      updateTime();
      flashMessage('+5s Bonus!');
      SFX.play?.('bonus5', { volume:1 });
    }
    state.lastMatchTime = now;
  }

  // --- Divergenza per modalità ---
  if (state.isChaos){
    // CHAOS: mostra ✨ e poi trasforma entrambe in buchi (come in "Chaos ok")
    spawnMatchStars(first);
    spawnMatchStars(second);
    try { SFX.play?.('ok', { volume:.9, rate: 0.98 }); } catch(_) {}
    setTimeout(() => {
      makeHole(first);
      makeHole(second);
    }, MATCH_HOLD_MS);
  } else {
    // Arcade / Zen: comportati come ora (restano matched)
    first.setAttribute('data-state','matched');
    second.setAttribute('data-state','matched');
    spawnMatchStars(first);
    spawnMatchStars(second);
    SFX.play?.('ok', { volume:.9, rate: 0.98 });
  }

  // Stato logico comune
  state.matched++;
  state.streak++;
  state.open = [];
  state.pivot = null;
  refreshPowersUI();

  // SOLO CHAOS: dopo l’animazione ✨ prova una micro-catena di shift
  if (state.isChaos && state.matched < state.level.pairs){
    setTimeout(() => zenShiftOnce(), 620);
  }

  // Fine quadro?
  if (state.matched >= state.level.pairs){
    win();
    return;
  }
  return;
}



    // Mismatch → micro-lock finché non si richiudono
    state.streak = 0;
    if (!state.isZen){
      const now = performance.now();
      state.deadlineTs = state.deadlineTs - 1000; // -1s
      state.leftMs = Math.max(0, state.deadlineTs - now);
      updateTime();
      flashMessage('-1s');
      SFX.play?.('fail', { volume:.9 });
    }

    state.lock = true;
    scheduleHide(first,  MISMATCH_HOLD_MS);
    scheduleHide(second, MISMATCH_HOLD_MS);

    // Sblocca input e processa eventuali tap bufferizzati
    setTimeout(() => {
      state.lock = false;
      state.open = [];
      state.pivot = null;
drainTapBuffer();
    }, MISMATCH_HOLD_MS + 5);

    return;
  }

  // Caso 3 (difensivo): se per qualche motivo risultavano già 2 aperte, chiudi le extra e riparti
  if (state.open.length >= 2){
    closeOpen(0);
    onCardClick(card);
  }
}


  function flip(card, reveal){ card.setAttribute('data-state', reveal ? 'revealed' : 'hidden'); }
function cancelHide(card){
  const t = state.hideTimers?.get(card);
  if (t){ clearTimeout(t); state.hideTimers.delete(card); }
}

function scheduleHide(card, ms){
  cancelHide(card);
  const t = setTimeout(() => {
if (card.getAttribute('data-state') !== 'matched' &&
    card.getAttribute('data-state') === 'revealed'){

  flip(card, false);
}
    state.hideTimers?.delete(card);
  }, ms);
  state.hideTimers?.set(card, t);
}

function scheduleHidePair(a, b){
  scheduleHide(a, MISMATCH_HOLD_MS);
  scheduleHide(b, MISMATCH_HOLD_MS);
}

// (segue) Annulla TUTTI i timer...
function clearAllHideTimers(){
  if (!state?.hideTimers) return;
  for (const [, t] of state.hideTimers) clearTimeout(t);
  state.hideTimers.clear();
}

function reshuffleHiddenNonSpecial(){
  const cards = Array.from(grid.querySelectorAll('.card'));
  const targets = cards.filter(c =>
    c.getAttribute('data-state') === 'hidden' &&
    c.dataset.symbol !== '💀' &&
    c.dataset.symbol !== '⚡'
  );
  if (targets.length <= 1) return;

  // 🔒 micro-lock durante il rimescolo
  const prevLock = state.lock;
  state.lock = true;

  const symbols = targets.map(c => c.dataset.symbol);
  for (let i = symbols.length - 1; i > 0; i--){
    const j = Math.floor(Math.random() * (i + 1));
    [symbols[i], symbols[j]] = [symbols[j], symbols[i]];
  }
  targets.forEach((c, i) => {
    c.dataset.symbol = symbols[i];
    c.querySelector('.symbol').textContent = symbols[i];
  });

  flashMessage('🔀 Shuffling!');
  SFX.play?.('reshuffle', { volume:.9 });

  // ⬆️ board cambiata → invalida i tap vecchi, sblocca e processa un tap valido
  bumpEpoch();
  state.lock = prevLock;
  drainTapBuffer();
}

// --- utils ---
function randInt(a,b){ return (Math.random()*(b-a+1)|0) + a; }
function swapNodes(a,b){
  const aNext = a.nextSibling, bNext = b.nextSibling, parent = a.parentNode;
  if (!parent || !b.parentNode) return;
  if (aNext === b) parent.insertBefore(b, a);
  else if (bNext === a) parent.insertBefore(a, b);
  else {
    parent.insertBefore(a, bNext);
    parent.insertBefore(b, aNext);
  }
}
function isCoveredCard(el){
  return el && el.classList.contains('card') &&
         !el.classList.contains('placeholder') &&
         el.getAttribute('data-state') === 'hidden';
}
function getNeighbors(idx, side){
  const res = [];
  const r = Math.floor(idx/side), c = idx%side;
  // su
  if (r>0) res.push(idx - side);
  // giù
  if (r<side-1) res.push(idx + side);
  // sin
  if (c>0) res.push(idx - 1);
  // des
  if (c<side-1) res.push(idx + 1);
  return res;
}
/* === ZEN — Teletrasporto speciali (⚡/💀) ============================= */
/* Prende una carta coperta non speciale, diversa da 'exceptEl' */
function getCoveredNormalCards(){
  return getActiveCards().filter(c =>
    isCoveredCard(c) && !isSpecialSymbol(c.dataset.symbol)
  );
}

/* Una sola volta: flash di aiuto */
function flashOnce(key, text){
  try {
    const K = `skullory_${key}`;
    if (!localStorage.getItem(K)) { flashMessage(text); localStorage.setItem(K, '1'); }
  } catch(_) {}
}

/* FLIP swap tra due card: scambia nel DOM, aggiorna data-index, anima entrambe */
function teleportSwap(a, b, { dur=200, kind='yellow' } = {}){
  return new Promise((resolve) => {
    if (!a || !b || !a.isConnected || !b.isConnected) return resolve();

    const aFrom = a.getBoundingClientRect();
    const bFrom = b.getBoundingClientRect();
    const aIdx  = +a.dataset.index;
    const bIdx  = +b.dataset.index;

    // swap in DOM
    swapNodes(a, b);

    // aggiorna gli indici (fondamentale per tutte le query per data-index)
    a.dataset.index = String(bIdx);
    b.dataset.index = String(aIdx);

    // calcola delta
    const aTo = a.getBoundingClientRect();
    const bTo = b.getBoundingClientRect();
    const aDx = aFrom.left - aTo.left, aDy = aFrom.top - aTo.top;
    const bDx = bFrom.left - bTo.left, bDy = bFrom.top - bTo.top;

    // setup animazione
    [a, b].forEach(el => {
      el.classList.add('tp-animating');
      el.style.transform  = `translate(${el===a?aDx:bDx}px, ${el===a?aDy:bDy}px)`;
      el.style.transition = 'transform 0ms';
      if (el === a){
        el.classList.add(kind === 'red' ? 'tp-glow-red' : 'tp-glow-yellow');
      }
    });

    // reflow
    a.getBoundingClientRect();

    requestAnimationFrame(() => {
      [a, b].forEach(el => {
        el.style.transition = `transform ${dur}ms cubic-bezier(.2,.7,.1,1)`;
        el.style.transform  = 'translate(0,0)';
      });
      const cleanup = () => {
        [a, b].forEach(el => {
          el.classList.remove('tp-animating','tp-glow-red','tp-glow-yellow');
          el.style.transition = ''; el.style.transform  = '';
        });
        a.removeEventListener('transitionend', cleanup);
        resolve();
      };
      a.addEventListener('transitionend', cleanup);
    });
  });
}

/* Sposta la carta speciale rivelata verso una posizione coperta casuale, poi richiude */
function teleportAfterReveal(card, { kind='yellow' } = {}){
  if (!state?.isZen || state?.isChaos) { scheduleHide(card, MISMATCH_HOLD_MS); return; }

  const pool = getCoveredNormalCards().filter(c => c !== card);
  if (!pool.length){ scheduleHide(card, MISMATCH_HOLD_MS); return; }

  const target = pool[(Math.random()*pool.length)|0];

  // micro-recinto input (come nei tuoi rimescoli)
  const prevLock = state.lock;
  state.lock = true;
  tapBuffer = [];

  try { SFX.play?.('flip', { volume:.7 }); } catch(_) {}

  teleportSwap(card, target, { dur: 200, kind }).then(() => {
    bumpEpoch();               // la board è cambiata
    scheduleHide(card, MISMATCH_HOLD_MS);
    state.lock = prevLock;
    drainTapBuffer();
  });
}

// Crea un buco nella cella di 'card' (⚡ rivelato 2 volte) — SOLO ZEN
function makeHole(card){
if (!state?.isChaos) return;
  if (!card || !card.classList.contains('card') || card.classList.contains('placeholder')) return;
  

  const idx = +card.dataset.index;
  // mini pop/dissolve
  card.classList.add('pop-out');

  // cancella hide timer e pivot se puntava a questa carta
  try { cancelHide(card); } catch(_) {}
  if (state.pivot === card) state.pivot = null;

  // crea placeholder.hole con lo stesso data-index
  const hole = document.createElement('div');
  hole.className = 'card placeholder hole';
  hole.dataset.index = String(idx);
  hole.setAttribute('aria-hidden','true');

  // sostituisci nel DOM
  grid.replaceChild(hole, card);

  // NEW — ripulisci riferimenti e invalida tap “vecchi”
  if (state.open?.length){
    state.open = state.open.filter(c => c && c.isConnected && c !== card);
    if (state.pivot === card) state.pivot = state.open[0] || null;
  }
  bumpEpoch();

  // registra
  state.holesEls = state.holesEls || [];
  state.holesEls.push(hole);

}

// Trova carte coperte adiacenti al buco (no diagonali, no placeholder/matched/rivelate)
function candidatesAroundHole(holeEl){
  const side = state.level.side;
  const idx = +holeEl.dataset.index;
  const neigh = getNeighbors(idx, side);
  const out = [];
  for (const n of neigh){
    const el = grid.querySelector(`.card[data-index="${n}"]`);
    if (isCoveredCard(el)) out.push(el);
  }
  return out;
}

// Sposta 1 carta coperta adiacente dentro al buco scelto (animazione FLIP)
// Sposta 1 carta coperta adiacente dentro al buco scelto (animazione FLIP) — Promise
function slideCardIntoHole(cardEl, holeEl){
  return new Promise((resolve) => {
    const dur = randInt(HOLE_SHIFT_MS_MIN, HOLE_SHIFT_MS_MAX);
    const from = cardEl.getBoundingClientRect();
    const to   = holeEl.getBoundingClientRect();
    const idxCard = +cardEl.dataset.index;
    const idxHole = +holeEl.dataset.index;

    // swap in DOM
    swapNodes(cardEl, holeEl);

    // aggiorna gli indici (la carta prende l'indice del buco, e viceversa)
    cardEl.dataset.index = String(idxHole);
    holeEl.dataset.index = String(idxCard);

    // FLIP: trasla la carta dalla vecchia posizione alla nuova
    const dx = from.left - to.left;
    const dy = from.top  - to.top;

    cardEl.style.transform = `translate(${dx}px, ${dy}px)`;
    cardEl.style.transition = 'transform 0ms';
    // reflow
    cardEl.getBoundingClientRect();

    requestAnimationFrame(() => {
      cardEl.style.transition = `transform ${dur}ms cubic-bezier(.2,.7,.1,1)`;
      cardEl.style.transform = 'translate(0,0)';
      const cleanup = () => {
        cardEl.style.transition = '';
        cardEl.style.transform = '';
        cardEl.removeEventListener('transitionend', cleanup);
        resolve();
      };
      cardEl.addEventListener('transitionend', cleanup);
    });
  });
}


// Dopo ogni coppia (solo Zen): attiva al massimo uno shift
// Dopo ogni coppia (solo Zen): una *catena* di 1..4 scivolamenti dal buco scelto
async function zenShiftOnce(){
  if (!state?.isChaos) return;
  const holes = (state.holesEls || []).filter(Boolean);
  if (!holes.length) return;

  const withCands = holes
    .map(h => [h, candidatesAroundHole(h)])
    .filter(([_, arr]) => arr.length > 0);

  if (!withCands.length){
    holes.forEach(h => {
      h.classList.add('hole-shake');
      setTimeout(() => h.classList.remove('hole-shake'), 200);
    });
    return;
  }

  const [holeEl] = withCands[(Math.random()*withCands.length)|0];

  // breve telegraph
  holeEl.classList.add('hole-blink');
  setTimeout(() => holeEl.classList.remove('hole-blink'), 120);

  const maxSteps = (Math.random()*4 | 0) + 1;

  let steps = 0;
  let lastCardIdx = null;

  // ⛑️ recinzione input durante la catena
  const prevLock = state.lock;
  state.lock = true;
  tapBuffer = [];

  while (steps < maxSteps){
    let candidates = candidatesAroundHole(holeEl)
      .filter(el => +el.dataset.index !== lastCardIdx);

    if (!candidates.length){
      holeEl.classList.add('hole-shake');
      setTimeout(() => holeEl.classList.remove('hole-shake'), 200);
      break;
    }

    const cardEl = candidates[(Math.random()*candidates.length)|0];
    try { SFX.play?.('flip', { volume: .65 }); } catch(_) {}

    const prevHoleIdx = +holeEl.dataset.index;

    await slideCardIntoHole(cardEl, holeEl);

    // invalida tap vecchi a ogni spostamento
    lastCardIdx = prevHoleIdx;
    bumpEpoch();
    steps++;
  }

  state.lock = prevLock;
  drainTapBuffer(); // processa il primo tap valido post-catena
}


  function startSimonIntermezzo(){
    ensureSfx();
 clearAllHideTimers(); // ← NEW: niente “timer zombie” durante il reset
    document.body.classList.add('mode-simon');
    refreshPowersUI();

    document.body.classList.add('no-flip');
    getActiveCards().forEach(c => c.setAttribute('data-state', 'hidden'));

    requestAnimationFrame(() => {
      document.body.classList.remove('no-flip');

      const activeIdx = getActiveCards().map(c => +c.dataset.index);
      const order = shuffle(activeIdx.slice());
      const maxLen   = order.length;
      const startLen = Math.min(SIMON_CFG.startLen, maxLen);

      sim = { active: true, busy: false, order, round: startLen - 1, pos: 0, maxLen };

      if (pauseBtn) pauseBtn.disabled = true;
      flashMessage('👻 Simon: repeat the sequence');
      simNextRound();
    });
  }

  function simNextRound(){
    if (!sim || !sim.active) return;
    if (sim.round >= sim.maxLen){
      endSimon(sim.round);
      return;
    }
    sim.round++;
    simShowSequence();
  }

  async function simShowSequence(){
    sim.pos = 0;
    sim.busy = true;

    await new Promise(r => setTimeout(r, 350));

    for (let i = 0; i < sim.round; i++){
      await simFlash(sim.order[i]);
      await new Promise(r => setTimeout(r, SIMON_CFG.gapMs));
    }

    sim.busy = false;
  }

  function simFlash(idx){
    return new Promise(res => {
      const card = getCardByIndex(idx);
      if (!card){ res(); return; }

      const ghost = document.createElement('div');
      ghost.className = 'simon-ghost';
      ghost.textContent = GHOST;
      ghost.style.animationDuration = SIMON_CFG.previewMs + 'ms';

      card.appendChild(ghost);

      SFX.play?.('tap', { volume:.6, rate: 1.05 });
      setTimeout(() => { ghost.remove(); res(); }, SIMON_CFG.previewMs);
    });
  }

  function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }

  async function simonRevealTemp(card, symbol, holdMs){
    const ghost = document.createElement('div');
    ghost.className = 'simon-ghost';
    ghost.style.animationDuration = holdMs + 'ms';
    ghost.textContent = symbol;

    card.appendChild(ghost);
    if (symbol === '💀') {
      SFX.play?.('skull', { volume:.95 });
    } else {
      SFX.play?.('flip', { volume:.75 });
    }

    await sleep(holdMs);
    ghost.remove();
  }
  async function simonRevealSkull(card, holdMs){ return simonRevealTemp(card, '💀', holdMs); }

  async function simonOnTap(card){
    if (!sim || !sim.active) return;
    if (sim.busy) return;

    const idx = +card.dataset.index;
    const expected = sim.order[sim.pos];

    if (idx !== expected){
      sim.busy = true;
      await simonRevealSkull(card, SIMON_CFG.wrongHoldMs);
      sim.busy = false;
      endSimon(Math.max(0, sim.round - 1));
      return;
    }

    sim.busy = true;
    sim.pos++;
    SFX.play?.('ok', { volume:.8 });
    await simonRevealTemp(card, GHOST, SIMON_CFG.inputRevealMs);
    sim.busy = false;

    if (sim.pos === sim.round){
      flashMessage('✓');
      setTimeout(() => simNextRound(), 350);
    }
  }

  function endSimon(completedLen){
    document.body.classList.remove('mode-simon');
    refreshPowersUI();

    const bonusSec = Math.max(0, Math.min(completedLen, sim?.maxLen || 0));
    sim.active = false;
    sim = null;

    if (pauseBtn) pauseBtn.disabled = false;

    const bonusMs = bonusSec * 1000;
    const next = currentLevelIdx + 1;

    if (next < LEVELS.length && !progress[next].unlocked) {
      progress[next].carryBonusMs = (progress[next].carryBonusMs || 0) + bonusMs;
    }

    const finalMsg = bonusSec > 0
      ? `You earned <b>+${bonusSec}s</b> for the next level!`
      : 'No bonus earned.';

    showOverlay('Bonus interlude over', `${finalMsg}`);
    ovBtn.textContent = 'Go to next level';
    ovBtn.onclick = () => { hideOverlay(); init(next); };
mapCloseTo(ovBtn);
  }

  function spawnMatchStars(card){
    const wrap = document.createElement('div');
    wrap.className = 'match-stars';
    card.appendChild(wrap);

    const N = 6;
    for(let i=0;i<N;i++){
      const s = document.createElement('span');
      s.className = 'star';
      s.textContent = '✨';
      const r = 26 + Math.random()*18;
      const ang = (Math.PI*2/N)*i + Math.random()*0.7;
      const dx = Math.cos(ang)*r;
      const dy = Math.sin(ang)*r;
      s.style.setProperty('--dx', `${dx}px`);
      s.style.setProperty('--dy', `${dy}px`);
      wrap.appendChild(s);
    }
    setTimeout(() => wrap.remove(), 650);
  }
// ===== Condivisione testuale Zen =====
function buildZenShareText(){
  const elapsedMs = state?.finalElapsedMs ?? calcElapsedMs();
  const moves = state?.moves || 0;
  const level = LEVELS[currentLevelIdx];
  const stars = computeZenStars(moves, elapsedMs, level);

  // articolo/etichetta della modalità nel testo condiviso
  const modeLabel = state?.isChaos ? 'la Chaos' : 'la Zen';
  // in alternativa, più neutro: const modeLabel = `la modalità ${state?.isChaos ? 'Chaos' : 'Zen'}`;

  return `I finished ${modeLabel} in Skullory with:
Moves: ${moves}
Time: ${fmt(elapsedMs)}
Rating: ${fmtStars(stars)}/5

Beat my score!
${GAME_URL}`;
}



async function shareZen(){
  const text = buildZenShareText();
  try{
    if (navigator.share){
      await navigator.share({
        title: 'Skullory — Zen',
        text
        // ❌ niente 'url' qui: molti target (WhatsApp) ignorano 'text' se 'url' è presente
      });
      return;
    }
  }catch(e){
    // utente ha annullato: ignora
  }

  // Fallback: copia negli appunti
  try{
    if (navigator.clipboard && window.isSecureContext){
      await navigator.clipboard.writeText(text);
      flashMessage('✅ Copied — paste anywhere!');
      return;
    }
  }catch(_) {}

  // Ultimo fallback: mailto
  const mailto = `mailto:?subject=${encodeURIComponent('My Zen result on Skullory')}&body=${encodeURIComponent(text)}`;
  window.location.href = mailto;
}

function showZenEnd(){
  // Congela il tempo al momento della vittoria
  state.finalElapsedMs = calcElapsedMs();
  const elapsedMs = state.finalElapsedMs;
  const moves = state.moves || 0;

  const level = LEVELS[currentLevelIdx];
  const stars = computeZenStars(moves, elapsedMs, level);

  ovTitle.textContent = 'Grid complete!';

  // Header daily (se applicabile)
  let header = '';
  if (state.isDaily){
    const d = state.dailyMeta?.date || todayStr();
    header = `🗓️ Daily Challenge <small>(${d})</small><br/>`;
  }

  // Ordine mostrato: mosse → tempo → stelle
  ovSub.innerHTML =
    `${header}` +
    `🎯 Moves: <b>${moves}</b><br/>` +
    `⏱️ Time: <b>${fmt(elapsedMs)}</b><br/>` +
    `⭐ Rating: <b>${fmtStars(stars)}/5</b>`;

  // Record della daily (locale)
  if (state.isDaily){
    const date = state.dailyMeta?.date || todayStr();
    const prev = readDailyRecord(date);
    const nowRec = { moves, timeMs: elapsedMs, stars, ts: Date.now() };
    const better = isRunBetter(nowRec, prev);

    if (better){
      writeDailyRecord(date, nowRec);
      ovSub.innerHTML += `<br/><br/>🏆 <b>New daily record!</b>`;
      try { SFX.play?.('win', { volume: 0.9 }); } catch(_){}
    } else if (prev){
      let msg = 'Record invariato';
      if (moves > prev.moves){
        const need = moves - prev.moves;
        msg = `Record unchanged (you need −${need} moves)`;
      } else if (moves === prev.moves && elapsedMs > prev.timeMs){
        const need = fmtShortSecDiff(elapsedMs - prev.timeMs);
        msg = `Record unchanged (you need −${need})`;
      } else if (moves === prev.moves && elapsedMs === prev.timeMs && stars < prev.stars){
        msg = `Record unchanged (you need +⭐)`;
      }
      ovSub.innerHTML += `<br/><br/>${msg}`;
    }
  }

  // Bottoni
ovBtn.textContent = 'Play again';
ovBtn.onclick = async () => {
  hideOverlay();
  // 👇 prova a mostrare un interstitial (se non è pronto, ignora e continua)
  try { await window.NativeAds?.showInterstitialSafe?.(); } catch(e) {}
  if (state.isDaily) {
    startDailyChaos(); // rigioca la stessa daily (stessa griglia del giorno)
  } else {
    startZen(state.isChaos ? 'chaos' : 'zen');
  }
};


  showSkip(true);
  ovBtnSkip.textContent = 'Back to menu';
  ovBtnSkip.onclick = () => { hideOverlay(); showIntro(); };
mapCloseTo(ovBtnSkip);

  // Pulsante Condividi
  const actions = document.querySelector('.ov-actions');
  if (actions) {
    document.getElementById('shareTextBtn')?.remove();
    const shareBtn = document.createElement('button');
    shareBtn.id = 'shareTextBtn';
    shareBtn.className = 'primary outline-btn';
    shareBtn.textContent = 'Share';
    shareBtn.onclick = () => shareZen();
    actions.appendChild(shareBtn);
  }
const xbtn = document.getElementById('ov-close');
if (xbtn) xbtn.style.display = 'none';
  overlay.classList.add('show');
  updateSaveButton();
}

  function win(){
    if (state?.isZen){ showZenEnd(); return; }
    state.running = false;
    SFX.play?.('win', { volume:1.0 });
  try { window.NativeAds?.maybeShowArcadeAd?.(); } catch(e) {}


    const secondsLeft = Math.floor(state.leftMs/1000);
    const free = freeMovesFor(state.level);
    const mult = efficiencyMultiplier(state.moves, free);
    const frameScore = roundNearest(secondsLeft * mult);
    totalScore = frameBaseScore + frameScore;
    updateScoreChip();

    const L = LEVELS[currentLevelIdx];
    const p = progress[currentLevelIdx];

    const detailRow = `Time: ${secondsLeft}s · Moves: ${state.moves}<br>
Board points = <b>${frameScore}</b><br>
Partial score: <b>${totalScore}</b>`;

    if(!p.unlocked){
      p.streak += 1;
      if(p.streak < 3){
        p.baseTimeMs = L.unlockMs[p.streak];
        showOverlay('Board complete ✔️', `Unlock: ${p.streak}/3<br>${detailRow}<br><small>Next attempt: base time ${Math.floor(p.baseTimeMs/1000)}s</small>`);
        ovBtn.textContent = 'Keep playing';
        ovBtn.onclick = () => { hideOverlay(); init(currentLevelIdx); };
mapCloseTo(ovBtn);
      } else {
        p.unlocked = true;
        p.postUnlockWins = 0;
        p.carryBonusMs = 0;

        const next = currentLevelIdx + 1;

        showOverlay(
          'Unlock achieved! 🏆',
          `You cleared 3 boards in a row!<br>
           ${detailRow}<br><br>
           <b>What do you want to do now?</b>`
        );

        ovBtn.textContent = 'Continue here (score more)';
        ovBtn.onclick = () => {
          hideOverlay();
          init(currentLevelIdx);
        };
mapCloseTo(ovBtn);
        if (next < LEVELS.length){
          showSkip(true);
          ovBtnSkip.textContent = 'Next level';
          ovBtnSkip.onclick = () => { openSimonChoice(next); };
        } else {
          showSkip(false);
        }
      }
    } else {
      p.postUnlockWins += 1;
      p.baseTimeMs = Math.max(0, p.baseTimeMs - L.postDeltaSec*1000);
      showOverlay('Board complete ✔️', `Post-unlock: ${p.postUnlockWins} completati<br>${detailRow}<br><small>Next attempt: base time ${Math.floor(p.baseTimeMs/1000)}s</small>`);
      ovBtn.textContent = 'Keep playing';
      ovBtn.onclick = () => { hideOverlay(); init(currentLevelIdx); };
mapCloseTo(ovBtn);
    }

if (activeSaveName) {
  if (upsertSave(activeSaveName, buildPayload())) {
    flashMessage('💾 Autosaved: ' + activeSaveName);
  }
}
}

  function lose(title, sub){
    const L = LEVELS[currentLevelIdx];
    const p = progress[currentLevelIdx];
    state.running = false;
    SFX.play?.('lose', { volume:1.0 });

    if (p.unlocked){
      const next = currentLevelIdx + 1;
      openSimonChoice(next);
      return;
    } else {
      p.streak = 0;
      p.baseTimeMs = L.unlockMs[0];

      totalScore = 0;
      frameBaseScore = 0;
      updateScoreChip();

      showOverlay(
        title || 'You lost!',
        (sub || 'Try again!') +
        `<br><small>Unlock: ${p.streak}/3 – base time reset to ${Math.floor(p.baseTimeMs/1000)}s</small>`
      );
      ovBtn.textContent = 'Retry this level';
      ovBtn.onclick = () => { hideOverlay(); init(currentLevelIdx); };
mapCloseTo(ovBtn);
    }
    updateSaveButton();
  }
// === Modal focus-trap & ESC ===
const MODAL_STACK = [];

function openModal(overlayEl, initialSelector){
  const dialog = overlayEl.querySelector('.dialog') || overlayEl;
  dialog.setAttribute('role','dialog');
  dialog.setAttribute('aria-modal','true');

  overlayEl.__opener = document.activeElement;        // chi ha aperto
  overlayEl.classList.add('show');
  overlayEl.setAttribute('aria-hidden','false');

  // focus iniziale
  const focusables = overlayEl.querySelectorAll(
    'button,[href],input,select,textarea,[tabindex]:not([tabindex="-1"])'
  );
  const first = initialSelector ? overlayEl.querySelector(initialSelector) : focusables[0];
  (first || dialog).focus();

  // trap del TAB
  function onKey(e){
    if (e.key !== 'Tab') return;
    const items = Array.from(overlayEl.querySelectorAll(
      'button,[href],input,select,textarea,[tabindex]:not([tabindex="-1"])'
    )).filter(el => !el.disabled && el.offsetParent !== null);
    if (!items.length) return;
    const i = items.indexOf(document.activeElement);
    if (e.shiftKey && (i <= 0)){ e.preventDefault(); items[items.length-1].focus(); }
    else if (!e.shiftKey && (i === items.length-1)){ e.preventDefault(); items[0].focus(); }
  }
  overlayEl.__trap = onKey;
  overlayEl.addEventListener('keydown', onKey);
  MODAL_STACK.push(overlayEl);
}

function closeModal(overlayEl){
  overlayEl.classList.remove('show');
  overlayEl.setAttribute('aria-hidden','true');
  if (overlayEl.__trap) overlayEl.removeEventListener('keydown', overlayEl.__trap);
  overlayEl.__trap = null;
  MODAL_STACK.pop();
  // ripristina focus a chi ha aperto
  overlayEl.__opener?.focus?.();
  overlayEl.__opener = null;
}

// ESC chiude il modale più in alto (su mobile in pratica non si usa, ma è ok)
document.addEventListener('keydown', (e) => {
  if (e.key !== 'Escape') return;
  const top = MODAL_STACK[MODAL_STACK.length - 1];
  if (top){ e.preventDefault(); closeModal(top); }
});

function showOverlay(title, sub){
  clearAllHideTimers(); // ⬅️ difensivo: cancella richiuse pendenti

  ovTitle.textContent = title;
  ovSub.innerHTML = sub;

  const x = document.querySelector('#overlay .tutorial-close, #ov-close');
  if (x) x.onclick = () => { hideOverlay(); };
const xbtn = document.getElementById('ov-close');
if (xbtn) xbtn.style.display = '';
  openModal(overlay);
  showSkip(false);
  updateSaveButton();
  refreshPowersUI();
}
// Helper: fa sì che la X (in alto a destra) esegua la stessa azione del bottone passato
function mapCloseTo(btnEl){
  const x = document.querySelector('#ov-close, #overlay .tutorial-close');
  if (x && btnEl && typeof btnEl.onclick === 'function'){
    x.onclick = btnEl.onclick;
  }
}
function hideOverlay(){
  closeModal(overlay);         // ⬅️ invece di togliere la classe a mano
  overlay.setAttribute('aria-hidden','true');
  showSkip(false);
  updateSaveButton?.();
  refreshPowersUI?.();
}

function showZenSkullLose(){
  // ferma la manche corrente
  state.running = false;
  tapBuffer = [];
  state.lock = false;

  try { SFX.play('lose', { volume: 1.0 }); } catch(_) {}

  // Mostra il popup (qui la X viene mappata di default a hideOverlay)
  showOverlay('Oh no! 💀', 'You revealed the skull twice.');

  // Rendi il bottone principale: rigioca subito la Zen
  ovBtn.textContent = 'Play Zen again';
  ovBtn.onclick = () => { hideOverlay(); modeZen = true; startZen(); };

  // Nessun secondo bottone
  showSkip(false);

  // 👇 Sovrascrivi il comportamento della X SOLO per questo popup:
  // torna al menu (Arcade/Zen)
  const x = document.querySelector('#ov-close, #overlay .tutorial-close');
  if (x) x.onclick = () => { hideOverlay(); showIntro(); };
}

  function openSimonChoice(next){
    showOverlay(
      'Time bonus interlude 👻',
      '<b>Nice! Before the next level you can earn bonus seconds with a mini-game: click the little ghosts in the right order.<br><br>' +
      '<small>Each correct step = +1s for the next level. Revealing the skull ends the mini-game.</small>'
    );

    ovBtn.textContent = 'Try the bonus';
    ovBtn.onclick = () => {
      hideOverlay();
      startSimonIntermezzo();
    };

    showSkip(true);
    if (ovBtnSkip) {
      ovBtnSkip.textContent = 'Continue without bonus';
      ovBtnSkip.onclick = () => {
        hideOverlay();
        if (next < LEVELS.length) {
          init(next);
        } else {
          init(currentLevelIdx);
        }
      };
    }
  }
mapCloseTo(ovBtnSkip);
  function explainPower(which){
    let title = '', desc = '', avail = '';

    if (which === 'reveal'){
      title = '👁️ Peek!';
      desc  = 'Reveal all cards for 1s at the cost of 20% remaining time.';
      avail = 'Available after at least one match.';
    } else if (which === 'plus10'){
      title = '🦇 +10s!';
      desc  = '+10s, but one matched pair is hidden again and relocated.';
      avail = 'Available after at least one match.';
    } else if (which === 'shift'){
      title = '🌀 +15s!!';
      desc  = '+15s, but reshuffles everything, including 💀 and ⚡.';
      avail = 'Available after revealing at least one 💀.';
    }

    const html = `${desc}<br><small>${avail}</small><br><small>Usable only during the round.</small>`;
    showOverlay(title, html);
    ovBtn.textContent = 'Ok';
    ovBtn.onclick = () => { hideOverlay(); };
    showSkip(false);
  }

function openRestartConfirm(){
  openModal(restartConfirm);
  refreshPowersUI();
}
function closeRestartConfirm(){
  closeModal(restartConfirm);
  refreshPowersUI();
}


function flashMessage(text){
  const msg = document.createElement('div');
  msg.className = 'flash-msg';
  msg.textContent = text;
  document.body.appendChild(msg);
  setTimeout(() => msg.remove(), 1500);

  // annuncio per screen reader
  const live = document.getElementById('live');
  if (live){
    live.textContent = ''; // reset veloce per riannunciare lo stesso messaggio
    setTimeout(() => { live.textContent = text; }, 10);
  }
}

  // ===== Multi-slot Saves =====
  function readSaves(){
    try{ const raw = localStorage.getItem(SAVES_KEY); return raw ? JSON.parse(raw) : []; }catch(e){ return []; }
  }
  function writeSaves(list){
  try{
    localStorage.setItem(SAVES_KEY, JSON.stringify(list));
    return true;
  }catch(e){
    if (isQuotaExceeded(e)){
      flashMessage('Save limit reached: delete a slot');
    }else{
      flashMessage('Can’t save: storage disabled or full');
    }
    return false;
  }
}

function upsertSave(name, payload){
  let list = readSaves();
  const idx = list.findIndex(s => s && s.name === name);
  const entry = { name, when: Date.now(), data: payload };
  if (idx >= 0) list[idx] = entry; else list.push(entry);

  // Applica il limite soft: tieni solo i più recenti
  if (list.length > MAX_SAVES){
    list = list.sort((a,b)=> (b.when||0)-(a.when||0)).slice(0, MAX_SAVES);
  }

  if (writeSaves(list)) return true;

  // Se fallisce comunque, prova a liberare 1 slot vecchio e ripeti una volta
  try{
    const trimmed = list.sort((a,b)=> (b.when||0)-(a.when||0)).slice(0, Math.max(0, list.length - 1));
    if (trimmed.length && writeSaves(trimmed)){
      flashMessage('Low space: removed one old slot automatically');
      return true;
    }
  }catch(_){}

  // Niente da fare (Safari privato, storage off, ecc.)
  return false;
}

  function deleteSave(name){ writeSaves(readSaves().filter(s => s && s.name !== name)); }

  function buildPayload(){
    return {
      version: 3,
      when: Date.now(),
      themeIndex,
      totalScore,
      currentLevelIdx,
      progress
    };
  }
  function loadPayload(data){
    if(!data) return false;
    themeIndex = data.themeIndex ?? themeIndex;
    totalScore = data.totalScore ?? 0;
    currentLevelIdx = data.currentLevelIdx ?? 0;
    if (Array.isArray(data.progress)) progress = data.progress;

    init(currentLevelIdx);
    frameBaseScore = totalScore;
    const b = document.body;
    b.className = (b.className || '').split(' ').filter(c => !c.startsWith('theme-')).join(' ');
    b.classList.add('theme-' + themeIndex);

    state.paused = false;
    state.running = false;
    pauseBtn.textContent = '⏸️';
    updateHud();
    updateSaveButton();
    return true;
  }

function openSaveManager(){
  if (state?.isZen) {
    flashMessage('Can’t save in Zen 😊');
    return;
  }
  if(!canSaveNow()){
    flashMessage('💾 Save only at the end of a board or before starting');
    return;
  }
  renderSaveList();
  const sc = document.getElementById('saveControls');
  if (sc) sc.style.display = '';

  openModal(saveModal, '#saveName'); // focus sull’input
  saveNameInput.value = '';
}
function closeSaveManager(){
  closeModal(saveModal);
}

  function renderSaveList(){
    const list = readSaves().sort((a,b)=> (b.when||0)-(a.when||0));
    if(!list.length){ saveList.innerHTML = '<div style="color:var(--muted)">No saves.</div>'; return; }
    saveList.innerHTML = '';
    list.forEach(entry => {
      const row = document.createElement('div');
      row.className = 'save-row';
      row.style.display = 'grid';
      row.style.gridTemplateColumns = '1fr auto auto';
      row.style.gap = '8px';
      row.style.alignItems = 'center';
      row.style.padding = '6px 0';

      const name = document.createElement('div');
      const d = new Date(entry.when||Date.now());
      const title = document.createElement('b');  title.textContent = entry.name;
      const small = document.createElement('small'); small.textContent = d.toLocaleString();
      name.append(title, document.createElement('br'), small);

      const loadBtn = document.createElement('button');
      loadBtn.className = 'icon-btn';
      loadBtn.innerHTML = '📤';
      loadBtn.title = 'Load this save';
      loadBtn.setAttribute('aria-label','Carica questo salvataggio');

      const delBtn = document.createElement('button');
      delBtn.className = 'icon-btn';
      delBtn.innerHTML = '🗑️';
      delBtn.title = 'Delete this save';
      delBtn.setAttribute('aria-label','Elimina questo salvataggio');

      loadBtn.onclick = () => {
        loadPayload(entry.data);
        setActiveSaveName(entry.name);
        closeSaveManager();
        flashMessage('📂 Loaded: ' + entry.name);
      };
      delBtn.onclick = () => {
        document.querySelectorAll('.inline-confirm').forEach(el => el.remove());
        const rows = saveList.querySelectorAll('.save-row');
        rows.forEach(r => { if (r !== row) r.style.display = 'none'; });

        const toolbar = doSaveBtn ? doSaveBtn.parentElement : null;
        const restoreToolbar = () => { if (toolbar) toolbar.style.display = ''; };
        if (toolbar) toolbar.style.display = 'none';

        const wrap = document.createElement('div');
        wrap.className = 'inline-confirm';
        wrap.style.display = 'flex';
        wrap.style.gap = '8px';
        wrap.style.alignItems = 'center';
        wrap.style.gridColumn = '1 / -1';
        wrap.style.marginTop = '6px';
        wrap.style.padding = '8px 10px';
        wrap.style.border = '1px solid var(--panel-border)';
        wrap.style.borderRadius = '10px';
        wrap.style.background = 'linear-gradient(180deg,var(--panel-1),var(--panel-2))';
const span = document.createElement('span');
span.append('Delete ');
const b = document.createElement('b');
b.textContent = entry.name; // ← sicuro: solo testo
span.append(b, '?');

const btnsDiv = document.createElement('div');
btnsDiv.style.marginLeft = 'auto';
btnsDiv.style.display = 'flex';
btnsDiv.style.gap = '8px';

const yesBtn = document.createElement('button');
yesBtn.className = 'primary';
yesBtn.textContent = 'Yes, delete';

const noBtn = document.createElement('button');
noBtn.className = 'primary';
noBtn.style.background = 'var(--bad)';
noBtn.style.color = '#fff';
noBtn.textContent = 'Cancel';

btnsDiv.append(yesBtn, noBtn);
wrap.append(span, btnsDiv);
row.after(wrap);

yesBtn.onclick = () => {
  deleteSave(entry.name);
  renderSaveList();
  restoreToolbar();
};
noBtn.onclick = () => {
  wrap.remove();
  rows.forEach(r => { r.style.display = ''; });
  restoreToolbar();
};
      };

      row.append(name, loadBtn, delBtn);
      saveList.appendChild(row);
    });
  }

  if (introBtn){ /* handler impostato da setTutorialMode() */ }

  restartBtn.addEventListener('click', () => { openRestartConfirm(); });
if (restartYes) {
  restartYes.addEventListener('click', async () => {
    closeRestartConfirm();
    hideOverlay();
    // 👇 prova a mostrare un interstitial (se non è pronto, ignora e continua)
    try { await window.NativeAds?.showInterstitialSafe?.(); } catch(e) {}
    currentLevelIdx = 0;
    showIntro();
  });
}
  if (restartNo) {
    restartNo.addEventListener('click', () => { closeRestartConfirm(); });
  }

  pauseBtn.addEventListener('click', togglePause);
  if(saveBtn){ saveBtn.addEventListener('click', openSaveManager); }
  if (powerRevealBtn) powerRevealBtn.addEventListener('click', usePowerReveal);
  if (powerPlus10Btn) powerPlus10Btn.addEventListener('click', usePowerPlus10);
  if (powerShiftBtn)  powerShiftBtn.addEventListener('click', usePowerShift);

  if (doSaveBtn) {
    let overwritePrompt = null;

    doSaveBtn.addEventListener('click', () => {
      const nm = (saveNameInput.value || '').trim();
      if (!nm) { flashMessage('Enter a name'); return; }
      if (!canSaveNow()) { flashMessage('You can save only at the end of a board or before starting'); return; }

      const exists = readSaves().some(s => s && s.name === nm);

if (exists && !overwritePrompt) {
  overwritePrompt = document.createElement('div');
  overwritePrompt.setAttribute('role', 'dialog');
  overwritePrompt.setAttribute('aria-label', 'Confirm save overwrite');
  overwritePrompt.style.marginTop = '8px';
  overwritePrompt.style.padding = '10px';
  overwritePrompt.style.background = 'var(--panel-1)';
  overwritePrompt.style.border = '1px solid var(--panel-border)';
  overwritePrompt.style.borderRadius = '12px';

  // "Overwrite <b>{nm}</b>?" — senza innerHTML
  const msg = document.createElement('div');
  msg.style.marginBottom = '8px';
  msg.style.color = 'var(--muted)';
  msg.append('Overwrite ');
  const b = document.createElement('b');
  b.textContent = nm;               // ✅ sicuro
  msg.append(b, '?');

  const bar = document.createElement('div');
  bar.style.display = 'flex';
  bar.style.gap = '8px';
  bar.style.justifyContent = 'flex-end';

  const yesBtn = document.createElement('button');
  yesBtn.className = 'primary';
  yesBtn.textContent = 'Yes';
  yesBtn.tabIndex = 0;

  const noBtn = document.createElement('button');
  noBtn.className = 'primary';
  noBtn.style.background = 'var(--bad)';
  noBtn.style.color = '#fff';
  noBtn.textContent = 'No';

  bar.append(yesBtn, noBtn);
  overwritePrompt.append(msg, bar);

  // Inserisci nel DOM come prima
  saveNameInput.parentElement.parentElement.appendChild(overwritePrompt);

  // Focus iniziale
  requestAnimationFrame(() => yesBtn && yesBtn.focus());

  // Handler (stessa logica di prima)
  yesBtn.onclick = () => {
const ok = upsertSave(nm, buildPayload());
if (ok) {
  setActiveSaveName(nm);
  flashMessage('💾 Overwritten: ' + nm);
  renderSaveList();
  saveNameInput.value = '';
}
overwritePrompt.remove();
overwritePrompt = null;

  };

  noBtn.onclick = () => {
    overwritePrompt.remove();
    overwritePrompt = null;
  };

  // Auto-chiusura dopo 5s
  setTimeout(() => {
    if (overwritePrompt) {
      overwritePrompt.remove();
      overwritePrompt = null;
    }
  }, 5000);

  return;
}


      if (upsertSave(nm, buildPayload())) {
        setActiveSaveName(nm);
        flashMessage('💾 Saved ' + nm);
        renderSaveList();
        saveNameInput.value = '';
      }
    });
  }

  if (saveClose){ saveClose.addEventListener('click', closeSaveManager); }

  // scorciatoia Ctrl/⌘+S
  window.addEventListener('keydown', (e)=>{
    const sKey = (e.key||'').toLowerCase()==='s';
    if(sKey && (e.ctrlKey || e.metaKey)){
      e.preventDefault();
      if (!state?.isZen) openSaveManager();
    }
  });

  // ===== Pausa / Resume =====
function togglePause(){
  if (!state) return;

  // ✅ Gestione dedicata per la Zen: niente timer, solo blocco/sblocco input
  if (state.isZen){
    state.paused = !state.paused;
    pauseBtn.textContent = state.paused ? '▶' : '⏸️';
    if (state.paused) {
      // svuota tocchi in coda e blocca il gioco
      tapBuffer = [];
    }
    refreshPowersUI();
    return;
  }

  // 🕹️ Arcade (logica esistente)
  if(!state.running && state.pauseLeftMs > 0){
    state.paused = false;
    state.running = true;
    state.deadlineTs = performance.now() + state.pauseLeftMs;
    state.pauseLeftMs = 0;
    pauseBtn.textContent = '⏸️';
    tick();
    refreshPowersUI();
    return;
  }
  if(state.running){
    state.paused = true;
    const now = performance.now();
    state.pauseLeftMs = Math.max(0, state.deadlineTs - now);
    state.running = false;
    pauseBtn.textContent = '▶';
    tapBuffer = [];
    refreshPowersUI();
    return;
  }
}


  // --- S P L A S H ---
  document.addEventListener('DOMContentLoaded', () => {
    const splash = document.getElementById('splash');
    let splashTimer = null;

    function showSplash(){
      if (!splash) return;
      splash.classList.remove('hide');
      splash.classList.add('show');
    }
    function hideSplash(){
      if (!splash) return;
      splash.classList.add('hide');
      splash.classList.remove('show');
    }
    function skipSplash(){
      if (splashTimer) { clearTimeout(splashTimer); splashTimer = null; }
      ensureSfx();
      hideSplash();
      showIntro();
    }

    if (splash){
      splash.addEventListener('click', skipSplash);
      window.addEventListener('keydown', (e) => {
        if (!splash || splash.classList.contains('hide')) return;
        if (e.key === 'Enter' || e.key === ' ' || e.key === 'Escape') skipSplash();
      });
    }

    init(0);
    showSplash();
    splashTimer = setTimeout(() => {
      hideSplash();
      showIntro();
    }, 3000);
  });

  // Migrazione legacy → slot "Ultimo"
  try{
    if(localStorage.getItem(STORAGE_KEY)){
      const raw = localStorage.getItem(STORAGE_KEY);
      const data = raw ? JSON.parse(raw) : null;
      if(data) upsertSave('Ultimo', { version:3, themeIndex, totalScore:0, currentLevelIdx:0, progress });
      localStorage.removeItem(STORAGE_KEY);
      flashMessage('Imported legacy save into “Last”');
    }
  }catch(e){}
})();
</script>
<!-- Area live per screen reader (invisibile a schermo) -->
<div id="live" aria-live="polite" class="sr-only"></div>
<script>
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('sw.js').catch(console.error);
  });
}
</script>
<!-- === Native Ads bridge (Capacitor) === -->
<script type="module">
  const isNative = typeof window.Capacitor !== 'undefined';

  async function call(plugin, method, args = {}) {
    if (!isNative) throw new Error('Not native');
    return window.Capacitor.Plugins[plugin][method](args);
  }

  // ID interstitial reale: lo imposterai solo quando vai in produzione
  async function setInterstitialUnitId(id) {
    if (!isNative) return;
    try { await call('Ads','setUnitId',{ id }); } catch(e){}
  }

  // Mostra interstitial, ma se non è pronto non blocca il gioco
  async function showInterstitialSafe() {
    if (!isNative) return;
    try {
      await call('Ads','preload').catch(()=>{});
      await call('Ads','show');
    } catch(e) {
      /* nessun ad disponibile → ignora */
    }
  }

  // Contatore Arcade: 1 ad ogni 2 vittorie
  window.__arcadeWins = 0;
  async function maybeShowArcadeAd() {
    if (!isNative) return;
    window.__arcadeWins++;
    if (window.__arcadeWins % 2 === 0) {
      try { await showInterstitialSafe(); } catch(e){}
    }
  }

  // Espongo in window per usarle nel tuo codice
  window.NativeAds = { setInterstitialUnitId, showInterstitialSafe, maybeShowArcadeAd };
</script>
<!-- === /Native Ads bridge === -->
<!-- DEBUG: pulsante per testare l'interstitial -->
<style>
  #testAdBtn {
    position: fixed; right: 12px; bottom: 12px; z-index: 99999;
    padding: 10px 14px; border-radius: 8px; border: 1px solid #999;
    background:#fff; font: 14px system-ui; box-shadow: 0 2px 8px rgba(0,0,0,.15);
  }
</style>
<button id="testAdBtn" type="button">Test Ad</button>
<script>
  (function(){
    const btn = document.getElementById('testAdBtn');
    btn.addEventListener('click', async () => {
      try {
        if (!window.Capacitor) { alert('Capacitor NON presente'); return; }

        // 🔑 crea il proxy JS del plugin nativo (nome: "Ads")
        const Ads = (window.Capacitor.registerPlugin
          ? window.Capacitor.registerPlugin('Ads')
          : (window.Capacitor.Plugins && window.Capacitor.Plugins.Ads));

        if (!Ads) { alert('Plugin Ads NON registrato lato JS'); return; }

        // opzionale: mostra i plugin web già visibili
        const keys = Object.keys(window.Capacitor.Plugins || {});
        console.log('Plugins noti:', keys.join(', '));

        // prova preload + show
        try { await Ads.preload({}); } catch(e) {}
        await Ads.show({});
        alert('Ad mostrato / chiuso');
      } catch(e) {
        alert('Errore show: ' + (e?.message || e));
      }
    });
  })();
</script>


<!-- /DEBUG -->

</body>
</html>







