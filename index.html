<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Skullory ‚Äì 4 livelli</title>
<style>
  :root{
    --bg-1:#141724; --bg-2:#232a46; --bg-3:#2b335c; --bg-4:#28315a;
    --panel:#0f1322; --panel-1:#12162a; --panel-2:#0d1120; --panel-border:#2b3357;
    --grid-1:#101429; --grid-2:#0c1020; --grid-border:#2b3357;
    --card-back:#2a3157; --card-front:#171b2d; --card-border:#394275; --card-pattern:#3b4479;
    --accent:#7484ff; --ok:#52ce89; --bad:#f4606c; --text:#f5f5f8; --muted:#c8cde0;
    --gap:12px; --radius:16px; --shadow:0 10px 30px rgba(0,0,0,.35);
    --flip-ms:380ms; --cols:4;
  }
  /* THEME CLASSES (override variables) */
  body.theme-1{ --card-pattern:#3b4479;  --bg-1:#141724; --bg-2:#232a46; --bg-3:#2b335c; --bg-4:#28315a; --panel:#0f1322; --panel-1:#12162a; --panel-2:#0d1120; --panel-border:#2b3357; --grid-1:#101429; --grid-2:#0c1020; --grid-border:#2b3357; --card-back:#2a3157; --card-front:#171b2d; --card-border:#394275; --card-pattern:#3b4479; --accent:#7484ff; --ok:#52ce89; --bad:#f4606c; --text:#f5f5f8; --muted:#c8cde0; }
  body.theme-2{ --card-pattern:#5d3a78;  --bg-1:#2b1838; --bg-2:#401b3f; --bg-3:#52234f; --bg-4:#5a2558; --panel:#1a0f24; --panel-1:#2a1536; --panel-2:#1c0f29; --panel-border:#4e2b6b; --grid-1:#261433; --grid-2:#1a0e26; --grid-border:#4e2b6b; --card-back:#3b2648; --card-front:#23142e; --card-border:#5d3a78; --accent:#ff7a59; --ok:#56df9a; --bad:#ff5c7a; --text:#fff3f5; --muted:#e0c9d6; }
  body.theme-3{ --card-pattern:#2c6a4c;  --bg-1:#0f1a14; --bg-2:#163024; --bg-3:#1c3d2c; --bg-4:#214736; --panel:#0b1913; --panel-1:#0f221a; --panel-2:#0c1b14; --panel-border:#2a5a43; --grid-1:#13261e; --grid-2:#0e1f18; --grid-border:#2a5a43; --card-back:#183b2b; --card-front:#0f221a; --card-border:#2c6a4c; --accent:#9be564; --ok:#4fe39c; --bad:#ff6b6b; --text:#eaf7ef; --muted:#b4d7c7; }
  body.theme-4{ --card-pattern:#7a5f44;  --bg-1:#2a241d; --bg-2:#3a2f23; --bg-3:#4a3b2b; --bg-4:#5a4a35; --panel:#1c1712; --panel-1:#251e17; --panel-2:#19140f; --panel-border:#6c553d; --grid-1:#211b15; --grid-2:#1a150f; --grid-border:#6c553d; --card-back:#4b3b2b; --card-front:#2a2119; --card-border:#7a5f44; --accent:#ffb84d; --ok:#7adf8a; --bad:#ff7f66; --text:#fff6e9; --muted:#e6d2b8; }
  body.theme-5{ --card-pattern:#2f5f80;  --bg-1:#0f1e2a; --bg-2:#123346; --bg-3:#17425a; --bg-4:#1a4b66; --panel:#0a1722; --panel-1:#0d2130; --panel-2:#0a1a26; --panel-border:#2b5574; --grid-1:#0f2736; --grid-2:#0b1f2a; --grid-border:#2b5574; --card-back:#163b52; --card-front:#0d2330; --card-border:#2f5f80; --accent:#4fd1ff; --ok:#6ae6b5; --bad:#ff6a7a; --text:#e6f7ff; --muted:#bdd8e7; }
  body.theme-6{ --card-pattern:#7a3535;  --bg-1:#1b1212; --bg-2:#2a1717; --bg-3:#3a1e1e; --bg-4:#4a2525; --panel:#140d0d; --panel-1:#1c1212; --panel-2:#110a0a; --panel-border:#6b2f2f; --grid-1:#1f1414; --grid-2:#170f0f; --grid-border:#6b2f2f; --card-back:#3a1e1e; --card-front:#241212; --card-border:#7a3535; --accent:#ff5e3a; --ok:#50e3a4; --bad:#ff4d4d; --text:#ffeceb; --muted:#e0b3b3; }
  body.theme-7{ --card-pattern:#415082;  --bg-1:#0f1116; --bg-2:#191d2b; --bg-3:#1f2640; --bg-4:#232b48; --panel:#0a0c12; --panel-1:#111521; --panel-2:#0d1019; --panel-border:#384064; --grid-1:#131827; --grid-2:#0f1320; --grid-border:#384064; --card-back:#1d2336; --card-front:#0f1522; --card-border:#415082; --accent:#ff3fb4; --ok:#50e3c2; --bad:#ff6b8b; --text:#f7f7ff; --muted:#c8cbe6; }
  body.theme-8{ --card-pattern:#2e6a73;  --bg-1:#0e1a1c; --bg-2:#14333a; --bg-3:#184249; --bg-4:#1d4e57; --panel:#0a1618; --panel-1:#0d2023; --panel-2:#0a1a1d; --panel-border:#2b5861; --grid-1:#10282d; --grid-2:#0c2024; --grid-border:#2b5861; --card-back:#15454d; --card-front:#0e262c; --card-border:#2e6a73; --accent:#42d6c5; --ok:#60e8a8; --bad:#ff6f7c; --text:#e8fffb; --muted:#bfe2de; }
  body.theme-9{ --card-pattern:#44684a;  --bg-1:#111a12; --bg-2:#1b2a1c; --bg-3:#223826; --bg-4:#284330; --panel:#0c140d; --panel-1:#111c13; --panel-2:#0d160f; --panel-border:#3b5f41; --grid-1:#162418; --grid-2:#111d13; --grid-border:#3b5f41; --card-back:#223b25; --card-front:#142018; --card-border:#44684a; --accent:#7bd88f; --ok:#6ee7b7; --bad:#ef6464; --text:#eaf6ee; --muted:#c7dccb; }
  body.theme-10{ --card-pattern:#57459a;  --bg-1:#1e1630; --bg-2:#2a1e46; --bg-3:#34285a; --bg-4:#3f306d; --panel:#150f22; --panel-1:#1e1733; --panel-2:#17102a; --panel-border:#4b3a7a; --grid-1:#221a3a; --grid-2:#1a1430; --grid-border:#4b3a7a; --card-back:#2f2759; --card-front:#1b1533; --card-border:#57459a; --accent:#00e0ff; --ok:#66f0a6; --bad:#ff7aa2; --text:#f4f2ff; --muted:#cdc6ff; }

  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; color:var(--text); font:16px/1.45 system-ui,Segoe UI,Roboto,Helvetica,Arial;
    background:
      radial-gradient(1200px 800px at 20% -10%, var(--bg-3), transparent),
      radial-gradient(900px 600px at 110% 20%, var(--bg-4), transparent),
      linear-gradient(180deg, var(--bg-1), var(--bg-2));
    display:flex; align-items:center; justify-content:center; padding:18px;
    -webkit-font-smoothing: antialiased; min-height:100dvh;
  }
  .wrap{ width:min(1100px, 98vw); margin:0 auto }
  .top{
    display:flex; align-items:center; justify-content:space-between; gap:12px;
    padding:18px 20px; background:linear-gradient(180deg,var(--panel-1),var(--panel-2));
    border:1px solid var(--panel-border); border-radius:20px; box-shadow:var(--shadow);
  }
  .brand{font-size:28px; font-weight:700; letter-spacing:.3px}
  button.primary{background:var(--accent); color:#0b0f1e; border:none; padding:10px 16px; border-radius:12px; font-weight:700; cursor:pointer}
  button.primary:active{transform:translateY(1px)}
  .stats-container{ display:flex; justify-content:center; margin:12px 0 8px; gap:12px; flex-wrap:wrap }
  .stats{ display:flex; align-items:center; gap:12px; flex-wrap:wrap; justify-content:center }
  .chip{ padding:8px 12px; border-radius:999px; background:#1a1f37; border:1px solid var(--panel-border); color:#c8cde0; white-space:nowrap }
  .level-chip{ padding:6px 10px; border-radius:999px; background:#1a1f37; border:1px solid var(--panel-border); color:#c8cde0; font-size:14px; white-space:nowrap }
  .timer{ font-size:26px; font-weight:700 }
  .grid{
    margin-top:18px; display:grid; grid-template-columns:repeat(var(--cols), minmax(0,1fr));
    gap:var(--gap); padding:18px; background:linear-gradient(180deg,var(--grid-1),var(--grid-2));
    border:1px solid var(--grid-border); border-radius:24px; box-shadow:var(--shadow);
  }
  .card{
    position:relative; aspect-ratio:1/1; perspective:900px;
    cursor:pointer; border-radius:var(--radius); -webkit-tap-highlight-color:transparent; touch-action:manipulation;
  }
  .face{ pointer-events:none; }
  .face{
    position:absolute; inset:0; display:grid; place-items:center; border-radius:var(--radius); border:1px solid var(--card-border);
    backface-visibility:hidden;
  }
  .front{ background:var(--card-front); transform:rotateY(180deg) }
  .back{ background:var(--card-back) }
  .back::before{
    content:""; position:absolute; inset:10px; border-radius:12px;
    background:
      linear-gradient(45deg,
        var(--card-pattern) 0 12%,
        transparent 12% 25%,
        var(--card-pattern) 25% 37%,
        transparent 37% 50%,
        var(--card-pattern) 50% 62%,
        transparent 62% 75%,
        var(--card-pattern) 75% 87%,
        transparent 87% 100%
      );
    opacity:.35;
  }
  .inner{
    position:absolute; inset:0; border-radius:var(--radius);
    transform-style:preserve-3d; transition: transform var(--flip-ms) cubic-bezier(.2,.7,.1,1);
    box-shadow: 0 12px 24px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.03);
  }
  .card[data-state="revealed"] .inner,
  .card[data-state="matched"] .inner{ transform:rotateY(180deg) }
  .symbol{ font-size:clamp(28px, 7.2vw, 64px); filter:drop-shadow(0 4px 10px rgba(0,0,0,.45)) }
  .card[data-state="matched"] .front{ outline:3px solid var(--ok); box-shadow:0 0 18px rgba(82,206,137,.45) inset }
  .card[data-state="locked"]{ pointer-events:none }
  /* Special effects for üíÄ and ‚ö° */
  .card[data-symbol="üíÄ"] .front .symbol{ text-shadow: 0 0 10px rgba(244,96,108,.6) }
  .card[data-symbol="üíÄ"][data-state="revealed"] .front{ outline:3px solid var(--bad); box-shadow:0 0 22px rgba(244,96,108,.45) inset }
  .card[data-symbol="‚ö°"] .front .symbol{ text-shadow: 0 0 10px rgba(255,213,79,.6) }
  .card[data-symbol="‚ö°"][data-state="revealed"] .front{ outline:3px solid #ffd54f; box-shadow:0 0 22px rgba(255,213,79,.4) inset }
  .flash-msg{
    position:fixed; top:20%; left:50%; transform:translateX(-50%);
    background:rgba(0,0,0,.8); color:#fff; padding:8px 14px; border-radius:10px; font-weight:700;
    z-index:9999; animation:flashUp .9s ease forwards; pointer-events:none
  }
  @keyframes flashUp{
    0%{opacity:0; transform:translate(-50%, 8px)} 15%{opacity:1; transform:translate(-50%, 0)} 100%{opacity:0; transform:translate(-50%, -8px)}
  }
  .overlay{ position:fixed; inset:0; display:none; place-items:center; background:rgba(0,0,0,.5) }
  .overlay.show{ display:grid }
  .overlay.hide{ display:none !important }
  .dialog{ width:min(520px, 92vw); background:linear-gradient(180deg,var(--panel-1),var(--panel-2)); border:1px solid var(--panel-border);
    border-radius:20px; padding:24px; text-align:center; box-shadow:var(--shadow) }
  .dialog h2{ margin:6px 0 8px; font-size:28px }
  .dialog p{ margin:0 0 14px; color:var(--muted) }
  @media (max-width: 600px){
    .wrap{ width:min(520px, 96vw) }
    .top, .grid{ width:100% }
  }
</style>
</head>
<body class="theme-1">
<div class="wrap">
  <div class="top">
    <div class="brand">Skullory</div>
    <div>
      <button class="primary" id="pause">‚è∏</button>
      <button class="primary" id="restart"> ‚Ü∫ </button>
    </div>
  </div>

  <div class="stats-container">
    <div class="stats">
      <span class="level-chip" id="levelChip">Livello: ‚Äî</span>
      <span class="level-chip" id="statusChip">Stato: ‚Äî</span>
      <span class="chip" id="moves" aria-live="polite">Mosse: 0</span>
      <span class="chip timer" id="timer" aria-live="polite">0:30</span>
      <span class="chip" id="score" aria-live="polite">Punti: 0</span>
    </div>
  </div>

  <div class="grid" id="grid" aria-label="Griglia Slapmory"></div>
</div>

<!-- Intro / Tutorial -->
<div class="overlay hide" id="intro">
  <div class="dialog">
    <h2>Come si gioca</h2>
    <div class="tutorial" style="text-align:left; margin-top:10px; color:var(--muted)">
      <ul style="margin:10px 0 0 18px; padding:0">
        <li>Trova tutte le coppie ribaltando le carte.</li>
        <li>4 livelli: 3√ó3 (30"), 4√ó4 (60"), 5√ó5 (90"), 6√ó6 (120").</li>
        <li><b>Sblocco livello</b>: completa lo stesso livello <b>3 volte di fila</b> per sbloccare il passaggio al livello successivo.</li>
        <li>Dopo lo sblocco resti sul livello: a ogni quadro riuscito il tempo base cala. Al primo errore, sali al livello successivo.</li>
        <li>‚ö° rimescola subito tutte le carte coperte (tranne üíÄ e ‚ö°).</li>
        <li>üíÄ se rivelato due volte: sconfitta.</li>
        <li><b>Bonus 1</b>: Ogni coppia trovata = +1".</li>
        <li><b>Bonus 2</b>: 2+ coppie di fila entro 5" = +5".</li>
        <li><b>Penalit√†</b>: ogni errore ‚àí2".</li>
        <li><b>Punteggio</b>: somma dei <b>secondi rimasti</b> a fine quadro, <b>moltiplicati</b> per l‚Äôefficienza mosse (meno mosse = pi√π punti).</li>
      </ul>
    </div>
    <div class="actions" style="margin-top:16px; display:flex; justify-content:center; gap:10px">
      <button class="primary" id="intro-play">Gioca</button>
    </div>
  </div>
</div>

<!-- Overlay di fine quadro -->
<div class="overlay" id="overlay">
  <div class="dialog">
    <h2 id="ov-title">Hai vinto!</h2>
    <p id="ov-sub">Tempo rimasto: ‚Äî</p>
    <button class="primary" id="ov-btn">Continua</button>
  </div>
</div>

<script>
(() => {
  const RED = 'üíÄ';
  const YELLOW = '‚ö°';
  const LEVELS = [
    { name: '3√ó3', pairs: 4,  red: 0, yellow: 1, side: 3, timeMs: 30000, unlockMs:[30000,20000,15000], postDeltaSec: 1 },
    { name: '4√ó4', pairs: 7,  red: 1, yellow: 1, side: 4, timeMs: 60000, unlockMs:[60000,50000,45000], postDeltaSec: 2 },
    { name: '5√ó5', pairs: 11, red: 1, yellow: 2, side: 5, timeMs: 90000, unlockMs:[90000,80000,70000], postDeltaSec: 3 },
    { name: '6√ó6', pairs: 16, red: 1, yellow: 3, side: 6, timeMs: 120000, unlockMs:[120000,115000,110000], postDeltaSec: 4 },
  ];

  const EMOJI = ['üê∂','üê±','ü¶ä','üêº','üêµ','üêØ','ü¶Å','üê∏','üê®','ü¶Ñ','üê∑','üêπ','üêô','ü¶â','ü¶ã','üêù','üê¢','üê†','üçé','üçâ','üçá','üçí','üçì','üçë','ü•ë','üåΩ','ü•ï','üç©','üç™','üç∞','üçî','üçï','üç£','üç§','üçú','üçø','üêã','ü¶≠','ü¶Ä','üêû','üêç','ü¶ú','ü¶¢','üêé','üê´','ü¶í','üêø','ü¶î','ü¶©','üê¨','üê≥','ü¶¶','üê°','üêå','üçã','üçä','ü´ê','ü••','ü•≠','ü•í','ü´ë','ü•î','üå∂','üçÑ','üßÑ','üßÖ','üßÄ','ü•®','ü•Ø','ü•û','ü•™','ü•ô','ü•ó','ü•ò','ü•ü','üçÆ','üç´','üçπ','üßã','üç∫','‚òï','ü•õ','üç∑','üçµ'];

  const grid = document.getElementById('grid');
  const movesEl = document.getElementById('moves');
  const timerEl = document.getElementById('timer');
  const restartBtn = document.getElementById('restart');
  const overlay = document.getElementById('overlay');
  const ovTitle = document.getElementById('ov-title');
  const ovSub = document.getElementById('ov-sub');
  const ovBtn = document.getElementById('ov-btn');
  const pauseBtn = document.getElementById('pause');
  const levelChip = document.getElementById('levelChip');
  const statusChip = document.getElementById('statusChip');
  const scoreChip = document.getElementById('score');

  const intro = document.getElementById('intro');
  const introBtn = document.getElementById('intro-play');
  function showIntro(){ intro.classList.remove('hide'); intro.classList.add('show'); }
  function hideIntro(){ intro.classList.add('hide'); intro.classList.remove('show'); }

  let state;
  let currentLevelIdx = 0;
  let totalScore = 0;
  let themeIndex = 1;

  let progress = LEVELS.map(L => ({ streak: 0, unlocked: false, baseTimeMs: L.unlockMs[0], postUnlockWins: 0 }));

  function setCols(n){ document.documentElement.style.setProperty('--cols', n); }
  function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } return a; }
  function fmt(ms){ const s = Math.max(0, Math.floor(ms/1000)); const mm = Math.floor(s/60), ss = s%60; return `${mm}:${ss.toString().padStart(2,'0')}`; }

  function rotateTheme(){
    themeIndex = themeIndex % 10 + 1; // 1..10
    const b = document.body;
    b.className = (b.className || '').replace(/\btheme-\d+\b/g, '').trim();
    b.classList.add('theme-' + themeIndex);
  }

  function updateStatusChip(){
    const p = progress[currentLevelIdx];
    const baseSec = Math.max(0, p.baseTimeMs) / 1000 | 0;
    if(!p.unlocked){
      statusChip.textContent = `Sbloc ${p.streak}/3 ¬∑ ${baseSec}s`;
    } else {
      statusChip.textContent = `Grind ${p.postUnlockWins} ¬∑ ${baseSec}s`;
    }
  }

  function buildDeck(level){
    const pool = EMOJI.slice();
    const unique = shuffle(pool).slice(0, level.pairs);
    const pairs = unique.concat(unique);
    const specials = [ ...Array(level.red).fill(RED), ...Array(level.yellow).fill(YELLOW) ];
    const deck = pairs.concat(specials);
    return shuffle(deck);
  }

  // --- MOSSE & PUNTEGGIO: funzioni helper ---
  function freeMovesFor(level){ return level.side * level.side; } // 9,16,25,36
  function efficiencyMultiplier(moves, free){
    const delta = moves - free;
    if (delta <= 0){
      // +2% per mossa risparmiata, massimo +30%
      const bonus = Math.min(0.30, 0.02 * (-delta));
      return 1 + bonus;
    } else {
      // -5% per mossa extra, minimo x0.5
      return Math.max(0.5, 1 - 0.05 * delta);
    }
  }
  function roundNearest(n){ return Math.round(n); } // arrotonda al pi√π vicino
  function updateScoreChip(){ if(scoreChip) scoreChip.textContent = `Punti: ${totalScore}`; }

  function init(levelIdx = currentLevelIdx){
    rotateTheme();

    const L = LEVELS[levelIdx];
    currentLevelIdx = levelIdx;
    setCols(L.side);
    levelChip.textContent = `Livello: ${L.name} (${levelIdx+1}/${LEVELS.length})`;
    updateStatusChip();

    state = {
      level: L,
      deck: buildDeck(L),
      flipped: [], matched: 0, moves: 0,
      running: false, startTs: 0,
      leftMs: Math.max(0, progress[levelIdx].baseTimeMs),
      lock: false,
      redFlips: 0, yellowFlips: 0,
      paused: false, streak: 0, lastMatchTime: 0, totalBonusMs: 0
    };

    grid.innerHTML = '';
    const frag = document.createDocumentFragment();
    for(let i=0;i<L.side*L.side;i++){
      const symbol = state.deck[i];
      const card = document.createElement('div');
      card.className = 'card';
      card.dataset.index = i;
      card.dataset.symbol = symbol;
      card.setAttribute('data-state','hidden');
      card.setAttribute('role','button');
      card.setAttribute('tabindex','0');
      card.setAttribute('aria-label','Carta di Slapmory');

      const inner = document.createElement('div'); inner.className = 'inner';
      const back  = document.createElement('div'); back.className  = 'face back';
      const front = document.createElement('div'); front.className = 'face front';
      const sym   = document.createElement('div'); sym.className   = 'symbol'; sym.textContent = symbol;
      front.appendChild(sym); inner.append(back, front); card.append(inner);

      card.addEventListener('click', () => onCardClick(card));
      card.addEventListener('keydown', (ev) => { if(ev.key==='Enter'||ev.key===' '){ ev.preventDefault(); onCardClick(card); } });

      frag.appendChild(card);
    }
    grid.appendChild(frag);
    updateHud();
    updateScoreChip();
    hideOverlay();
  }

  function startTimer(){ if(state.paused) return; if(state.running) return; state.running = true; state.startTs = performance.now(); tick(); }
  function tick(){
    if(!state.running || state.paused) return;
    const elapsed = performance.now()-state.startTs;
    state.leftMs = Math.max(0, Math.max(0, progress[currentLevelIdx].baseTimeMs) - elapsed);
    updateTime();
    if(state.leftMs<=0){ state.running=false; lose('Tempo scaduto ‚è∞'); return; }
    requestAnimationFrame(tick);
  }
  function updateTime(){ timerEl.textContent = fmt(state.leftMs); }
  function updateHud(){
    movesEl.textContent = `Mosse: ${state.moves}`;
    timerEl.textContent = fmt(state.leftMs);
    updateStatusChip();
    updateScoreChip(); // mostra sempre i punti effettivi
  }

  function onCardClick(card){
    if(state.lock) return;
    if(card.dataset.state === 'matched' || card.dataset.state === 'revealed') return;
    startTimer();

    flip(card, true);
    state.flipped.push(card);

    if(card.dataset.symbol === RED){
      state.redFlips++;
      if(state.redFlips >= 2){
        setTimeout(() => lose('Oh no! üíÄ', 'Hai rivelato il teschio due volte.'), 220);
        return;
      }
    }
    if(card.dataset.symbol === YELLOW){
      state.yellowFlips++;
      flashMessage('Shuffle!');
      reshuffleHiddenNonSpecial();
    }

    if(state.flipped.length === 2){
      state.moves++;
      movesEl.textContent = `Mosse: ${state.moves}`;
      checkPair();
    }
  }

  function flip(card, reveal){ card.setAttribute('data-state', reveal ? 'revealed' : 'hidden'); }

  function checkPair(){
    const [a, b] = state.flipped;
    if(!a || !b) return;
    const specialInvolved = (s => s===RED || s===YELLOW);
    const match = !specialInvolved(a.dataset.symbol) && !specialInvolved(b.dataset.symbol) && (a.dataset.symbol === b.dataset.symbol);
    state.lock = true;

    setTimeout(() => {
      if(match){
        state.streak++;
        const now = performance.now();

        // --- BONUS +1s per ogni coppia trovata ---
        {
          const cap = Math.max(0, progress[currentLevelIdx].baseTimeMs);
          state.leftMs = Math.min(cap, state.leftMs + 1000);
          updateTime();
          flashMessage('+1s');
        }
        // --- BONUS +5s combo se entro 5s dalla precedente ---
        if(state.streak >= 2 && (now - state.lastMatchTime) < 5000){
          const cap = Math.max(0, progress[currentLevelIdx].baseTimeMs);
          state.leftMs = Math.min(cap, state.leftMs + 5000);
          updateTime();
          flashMessage('+5s Bonus!');
        }
        state.lastMatchTime = now;

        a.setAttribute('data-state','matched');
        b.setAttribute('data-state','matched');
        state.matched++;
        if(state.matched >= state.level.pairs){ win(); }
      } else {
        state.streak = 0;
        state.leftMs = Math.max(0, state.leftMs - 2000);
        updateTime();
        flashMessage('-2s');
        flip(a,false); flip(b,false);
      }
      state.flipped.length = 0;
      state.lock = false;
    }, match ? 180 : 650);
  }

  function reshuffleHiddenNonSpecial(){
    const cards = Array.from(grid.querySelectorAll('.card'));
    const targets = cards.filter(c => c.getAttribute('data-state') === 'hidden' && c.dataset.symbol !== 'üíÄ' && c.dataset.symbol !== '‚ö°');
    if(targets.length <= 1) return;
    const symbols = targets.map(c => c.dataset.symbol);
    for(let i=symbols.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [symbols[i],symbols[j]]=[symbols[j],symbols[i]]; }
    targets.forEach((c,i) => {
      c.dataset.symbol = symbols[i];
      c.querySelector('.symbol').textContent = symbols[i];
    });
    flashMessage('üîÄ Rimescolo!');
  }

  function win(){
    state.running = false;

    const secondsLeft = Math.floor(state.leftMs/1000);
    const free = freeMovesFor(state.level);
    const mult = efficiencyMultiplier(state.moves, free);
    const frameScore = roundNearest(secondsLeft * mult);
    totalScore += frameScore;
    updateScoreChip();

    const L = LEVELS[currentLevelIdx];
    const p = progress[currentLevelIdx];

    const multTxt = `√ó${mult.toFixed(2)}`;
    const detailRow = `Tempo: ${secondsLeft}s ¬∑ Mosse: ${state.moves} (gratis ${free}) ¬∑ Efficienza: <b>${multTxt}</b><br>Punti quadro: <b>${secondsLeft} √ó ${multTxt} = ${frameScore}</b><br>Punteggio parziale: <b>${totalScore}</b>`;

    if(!p.unlocked){
      p.streak += 1;
      if(p.streak < 3){
        p.baseTimeMs = L.unlockMs[p.streak];
        showOverlay('Quadro completato ‚úîÔ∏è', `Sblocco: ${p.streak}/3<br>${detailRow}<br><small>Prossimo tentativo: tempo base ${Math.floor(p.baseTimeMs/1000)}s</small>`);
        ovBtn.textContent = 'Riprova questo livello';
        ovBtn.onclick = () => { hideOverlay(); init(currentLevelIdx); };
      } else {
        p.unlocked = true;
        p.postUnlockWins = 0;
        showOverlay('Sblocco conquistato! üèÜ', `Hai completato 3 quadri di fila.<br>Ora resta su questo livello e fai punti!<br>${detailRow}`);
        ovBtn.textContent = 'Continua su questo livello';
        ovBtn.onclick = () => { hideOverlay(); init(currentLevelIdx); };
      }
    } else {
      p.postUnlockWins += 1;
      p.baseTimeMs = Math.max(0, p.baseTimeMs - L.postDeltaSec*1000);
      showOverlay('Quadro completato ‚úîÔ∏è', `Post-sblocco: ${p.postUnlockWins} completati<br>${detailRow}<br><small>Prossimo tentativo: tempo base ${Math.floor(p.baseTimeMs/1000)}s</small>`);
      ovBtn.textContent = 'Continua su questo livello';
      ovBtn.onclick = () => { hideOverlay(); init(currentLevelIdx); };
    }
  }

  function lose(title, sub){
    const L = LEVELS[currentLevelIdx];
    const p = progress[currentLevelIdx];
    state.running = false;
    if(p.unlocked){
      const next = currentLevelIdx + 1;
      if(next < LEVELS.length){
        showOverlay('Passi al livello successivo ‚ÜóÔ∏è', (sub || 'Hai perso questo quadro, ma il passaggio era gi√† conquistato.') + `<br><small>Punteggio parziale: ${totalScore}</small>`);
        ovBtn.textContent = 'Vai al prossimo livello';
        ovBtn.onclick = () => { hideOverlay(); init(next); };
      } else {
        showOverlay('Fine partita', (sub || 'Hai terminato l‚Äôultimo livello.') + `<br><b>Punteggio finale: ${totalScore} punti</b>`);
        ovBtn.textContent = 'Gioca ancora';
        ovBtn.onclick = () => { totalScore=0; progress = LEVELS.map(L => ({ streak:0, unlocked:false, baseTimeMs:L.unlockMs[0], postUnlockWins:0 })); hideOverlay(); init(0); updateScoreChip(); };
      }
    } else {
      p.streak = 0;
      p.baseTimeMs = L.unlockMs[0];
      showOverlay(title || 'Hai perso', (sub || 'Ritenta!') + `<br><small>Sblocco: ${p.streak}/3 ‚Äì tempo base ripristinato a ${Math.floor(p.baseTimeMs/1000)}s</small>`);
      ovBtn.textContent = 'Riprova questo livello';
      ovBtn.onclick = () => { hideOverlay(); init(currentLevelIdx); };
    }
  }

  function showOverlay(title, sub){ ovTitle.textContent = title; ovSub.innerHTML = sub; overlay.classList.add('show'); }
  function hideOverlay(){ overlay.classList.remove('show'); }

  function flashMessage(text){
    const msg = document.createElement('div');
    msg.className = 'flash-msg';
    msg.textContent = text;
    document.body.appendChild(msg);
    setTimeout(() => msg.remove(), 900);
  }

  if(introBtn){
    introBtn.addEventListener('click', () => {
      hideIntro();
      state.paused = false;
    });
  }
  restartBtn.addEventListener('click', () => {
    totalScore = 0;
    updateScoreChip();
    progress = LEVELS.map(L => ({ streak:0, unlocked:false, baseTimeMs:L.unlockMs[0], postUnlockWins:0 }));
    hideOverlay(); init(0);
  });
  pauseBtn.addEventListener('click', () => {
    if(!state.running) return;
    state.paused = true; state.running = false;
  });

  init(0);
  showIntro();
})();
</script>
</body>
</html>
