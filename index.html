<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Skullory</title>
<style>
  :root{
    --bg-1:#141724; --bg-2:#232a46; --bg-3:#2b335c; --bg-4:#28315a;
    --panel:#0f1322; --panel-1:#12162a; --panel-2:#0d1120; --panel-border:#2b3357;
    --grid-1:#101429; --grid-2:#0c1020; --grid-border:#2b3357;
    --card-back:#2a3157; --card-front:#171b2d; --card-border:#394275; --card-pattern:#3b4479;
    --accent:#7484ff; --ok:#52ce89; --bad:#f4606c; --text:#f5f5f8; --muted:#c8cde0;
    --gap:12px; --radius:16px; --shadow:0 10px 30px rgba(0,0,0,.35);
    --flip-ms:380ms; --cols:4;
  }
  /* THEME CLASSES (override variables) */
  body.theme-1{ --card-pattern:#3b4479;  --bg-1:#141724; --bg-2:#232a46; --bg-3:#2b335c; --bg-4:#28315a; --panel:#0f1322; --panel-1:#12162a; --panel-2:#0d1120; --panel-border:#2b3357; --grid-1:#101429; --grid-2:#0c1020; --grid-border:#2b3357; --card-back:#2a3157; --card-front:#171b2d; --card-border:#394275; --card-pattern:#3b4479; --accent:#7484ff; --ok:#52ce89; --bad:#f4606c; --text:#f5f5f8; --muted:#c8cde0; }
  body.theme-2{ --card-pattern:#5d3a78;  --bg-1:#2b1838; --bg-2:#401b3f; --bg-3:#52234f; --bg-4:#5a2558; --panel:#1a0f24; --panel-1:#2a1536; --panel-2:#0c1b29; --panel-border:#4e2b6b; --grid-1:#261433; --grid-2:#0c1020; --grid-border:#4e2b6b; --card-back:#3b2648; --card-front:#23142e; --card-border:#5d3a78; --accent:#ff7a59; --ok:#56df9a; --bad:#ff5c7a; --text:#fff3f5; --muted:#e0c9d6; }
  body.theme-3{ --card-pattern:#2c6a4c;  --bg-1:#0f1a14; --bg-2:#163024; --bg-3:#1c3d2c; --bg-4:#214736; --panel:#0b1913; --panel-1:#0f221a; --panel-2:#0c1b14; --panel-border:#2a5a43; --grid-1:#13261e; --grid-2:#0e1f18; --grid-border:#2a5a43; --card-back:#183b2b; --card-front:#0f221a; --card-border:#2c6a4c; --accent:#9be564; --ok:#4fe39c; --bad:#ff6b6b; --text:#eaf7ef; --muted:#b4d7c7; }
  body.theme-4{ --card-pattern:#7a5f44;  --bg-1:#2a241d; --bg-2:#3a2f23; --bg-3:#4a3b2b; --bg-4:#5a4a35; --panel:#1c1712; --panel-1:#251e17; --panel-2:#19140f; --panel-border:#6c553d; --grid-1:#211b15; --grid-2:#1a150f; --grid-border:#6c553d; --card-back:#4b3b2b; --card-front:#2a2119; --card-border:#7a5f44; --accent:#ffb84d; --ok:#7adf8a; --bad:#ff7f66; --text:#fff6e9; --muted:#e6d2b8; }
  body.theme-5{ --card-pattern:#2f5f80;  --bg-1:#0f1e2a; --bg-2:#123346; --bg-3:#17425a; --bg-4:#1a4b66; --panel:#0a1722; --panel-1:#0d2130; --panel-2:#0a1a26; --panel-border:#2b5574; --grid-1:#0f2736; --grid-2:#0b1f2a; --grid-border:#2b5574; --card-back:#163b52; --card-front:#0d2330; --card-border:#2f5f80; --accent:#4fd1ff; --ok:#6ae6b5; --bad:#ff6a7a; --text:#e6f7ff; --muted:#bdd8e7; }
  body.theme-6{ --card-pattern:#7a3535;  --bg-1:#1b1212; --bg-2:#2a1717; --bg-3:#3a1e1e; --bg-4:#4a2525; --panel:#140d0d; --panel-1:#1c1212; --panel-2:#110a0a; --panel-border:#6b2f2b; --grid-1:#1f1414; --grid-2:#170f0f; --grid-border:#6b2f2b; --card-back:#3a1e1e; --card-front:#241212; --card-border:#7a3535; --accent:#ff5e3a; --ok:#50e3a4; --bad:#ff4d4d; --text:#ffeceb; --muted:#e0b3b3; }
  body.theme-7{ --card-pattern:#415082;  --bg-1:#0f1116; --bg-2:#191d2b; --bg-3:#1f2640; --bg-4:#232b48; --panel:#0a0c12; --panel-1:#111521; --panel-2:#0d1019; --panel-border:#384064; --grid-1:#131827; --grid-2:#0f1320; --grid-border:#384064; --card-back:#1d2336; --card-front:#0f1522; --card-border:#415082; --accent:#ff3fb4; --ok:#50e3c2; --bad:#ff6b8b; --text:#f7f7ff; --muted:#c8cbe6; }
  body.theme-8{ --card-pattern:#2e6a73;  --bg-1:#0e1a1c; --bg-2:#14333a; --bg-3:#184249; --bg-4:#1d4e57; --panel:#0a1618; --panel-1:#0d2023; --panel-2:#0a1a1d; --panel-border:#2b5861; --grid-1:#10282d; --grid-2:#0c2024; --grid-border:#2b5861; --card-back:#15454d; --card-front:#0e262c; --card-border:#2e6a73; --accent:#42d6c5; --ok:#60e8a8; --bad:#ff6f7c; --text:#e8fffb; --muted:#bfe2de; }
  body.theme-9{ --card-pattern:#44684a;  --bg-1:#111a12; --bg-2:#1b2a1c; --bg-3:#223826; --bg-4:#284330; --panel:#0c140d; --panel-1:#111c13; --panel-2:#0d160f; --panel-border:#3b5f41; --grid-1:#162418; --grid-2:#111d13; --grid-border:#3b5f41; --card-back:#223b25; --card-front:#142018; --card-border:#44684a; --accent:#7bd88f; --ok:#6ee7b7; --bad:#ef6464; --text:#eaf6ee; --muted:#c7dccb; }
  body.theme-10{ --card-pattern:#57459a;  --bg-1:#1e1630; --bg-2:#2a1e46; --bg-3:#34285a; --bg-4:#3f306d; --panel:#150f22; --panel-1:#1e1733; --panel-2:#17102a; --panel-border:#4b3a7a; --grid-1:#221a3a; --grid-2:#1a1430; --grid-border:#4b3a7a; --card-back:#2f2759; --card-front:#1b1533; --card-border:#57459a; --accent:#00e0ff; --ok:#66f0a6; --bad:#ff7aa2; --text:#f4f2ff; --muted:#cdc6ff; }

  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; color:var(--text); font:16px/1.45 system-ui,Segoe UI,Roboto,Helvetica,Arial;
    background:
      radial-gradient(1200px 800px at 20% -10%, var(--bg-3), transparent),
      radial-gradient(900px 600px at 110% 20%, var(--bg-4), transparent),
      linear-gradient(180deg, var(--bg-1), var(--bg-2));
    display:flex; 
    align-items:flex-start;
    justify-content:center; 
    padding:10px 18px 18px;
    -webkit-font-smoothing: antialiased; 
    min-height:100dvh;
  }
  .wrap{ width:min(1100px, 98vw); margin: 30px auto 0; }
  .top{
    display:block;
    padding: 0;
  }

  .brand{ width:100%; }

  .brand img{
    display:block;
    width:100%;
    height:auto;
    max-height: 70px;
  }

  .controls { display: flex; gap: 6px; }
  .controls-bottom{
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 8px;
    width: 100%;
    margin-top: 14px;
  }
  .controls-left, .controls-right{
    display: flex;
    align-items: center;
    gap: 8px;
  }

  /* Riduci la larghezza SOLO dei tre bottoni in alto a destra */
  .controls-bottom .outline-btn{
    padding: 8px 8px;
    min-width: 40px;
  }

  /* Stato visivo disabilitato, ma cliccabile per mostrare lâ€™help */
  .controls-right .power-btn[aria-disabled="true"]{
    filter: grayscale(100%);
    opacity: .35;
    cursor: not-allowed;
    box-shadow: none;
    border-color: #3a4168;
  }
  .controls-right .power-btn[aria-disabled="true"]:hover{
    transform: none;
    box-shadow: none;
  }

  button.primary{background:var(--accent); color:#0b0f1e; border:none; padding:10px 16px; border-radius:12px; font-weight:700; cursor:pointer}
  button.primary:active{transform:translateY(1px)}
  .stats-container{ display:flex; justify-content:center; margin:12px 0 8px; gap:12px; flex-wrap:wrap }
  .stats{ display:flex; align-items:center; gap:12px; flex-wrap:wrap; justify-content:center }
  .chip{ padding:8px 12px; border-radius:999px; background:#1a1f37; border:1px solid var(--panel-border); color:#c8cde0; white-space:nowrap }
  .level-chip{ padding:6px 10px; border-radius:999px; background:#1a1f37; border:1px solid var(--panel-border); color:#c8cde0; font-size:14px; white-space:nowrap }
  .timer{ font-size:26px; font-weight:700 }
  .grid{
    margin-top:18px; display:grid; grid-template-columns:repeat(var(--cols), minmax(0,1fr));
    gap:var(--gap); padding:18px; background:linear-gradient(180deg,var(--grid-1),var(--grid-2));
    border:1px solid var(--grid-border); border-radius:24px; box-shadow:var(--shadow);
  }
  .card{
    position:relative; aspect-ratio:1/1; perspective:900px;
    cursor:pointer; border-radius:var(--radius); -webkit-tap-highlight-color:transparent; touch-action:manipulation;
    container-type: inline-size;
  }
  .face{
    position:absolute; inset:0; display:grid; place-items:center; border-radius:var(--radius); border:1px solid var(--card-border);
    backface-visibility:hidden;
    pointer-events:none; /* unita qui */
  }
  .front{ background:var(--card-front); transform:rotateY(180deg) }
  .back{ background:var(--card-back) }
  .back::before{
    content:""; position:absolute; inset:10px; border-radius:12px;
    background:
      linear-gradient(45deg,
        var(--card-pattern) 0 12%,
        transparent 12% 25%,
        var(--card-pattern) 25% 37%,
        transparent 37% 50%,
        var(--card-pattern) 50% 62%,
        transparent 62% 75%,
        var(--card-pattern) 75% 87%,
        transparent 87% 100%
      );
    opacity:.35;
  }
  .inner{
    position:absolute; inset:0; border-radius:var(--radius);
    transform-style:preserve-3d; transition: transform var(--flip-ms) cubic-bezier(.2,.7,.1,1);
    box-shadow: 0 12px 24px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.03);
  }
  .card[data-state="revealed"] .inner,
  .card[data-state="matched"] .inner{ transform:rotateY(180deg) }
  .symbol{
    font-size: clamp(28px, 50cqi, 86px);
    line-height: 1;
    filter: drop-shadow(0 4px 10px rgba(0,0,0,.45));
  }
  .card[data-state="matched"] .front{ outline:3px solid var(--ok); box-shadow:0 0 18px rgba(82,206,137,.45) inset }
  .card[data-state="locked"]{ pointer-events:none }

  /* Placeholder per slot vuoto nei livelli senza angoli */
  .card.placeholder{
    background:transparent;
    border:none;
    box-shadow:none;
    pointer-events:none;
  }

  /* Special effects for ğŸ’€ e âš¡ */
  .card[data-symbol="ğŸ’€"] .front .symbol{ text-shadow: 0 0 10px rgba(244,96,108,.6) }
  .card[data-symbol="ğŸ’€"][data-state="revealed"] .front{ outline:3px solid var(--bad); box-shadow:0 0 22px rgba(244,96,108,.45) inset }
  .card[data-symbol="âš¡"] .front .symbol{ text-shadow: 0 0 10px rgba(255,213,79,.6) }
  .card[data-symbol="âš¡"][data-state="revealed"] .front{ outline:3px solid #ffd54f; box-shadow:0 0 22px rgba(255,213,79,.4) inset }

  .flash-msg{
    position:fixed;
    top:20%;
    left:50%;
    transform:translateX(-50%);
    background:rgba(0,0,0,.8);
    color:#fff;
    padding:12px 20px;
    border-radius:12px;
    font-weight:700;
    font-size:1.3em;
    z-index:9999;
    pointer-events:none;
    animation:flashUp 1.5s ease forwards;
  }
  /* Stelline match */
  .match-stars { 
    position: absolute; inset: 0; pointer-events: none; 
    display: grid; place-items: center; 
  }
  .match-stars .star {
    position: absolute;
    font-size: 18px;
    opacity: 0;
    animation: starPop 600ms ease-out forwards;
    will-change: transform, opacity;
    filter: drop-shadow(0 6px 10px rgba(0,0,0,.35));
  }
  @keyframes starPop {
    0%   { transform: translate(0,0) scale(.4) rotate(0deg);   opacity: 0; }
    20%  { opacity: 1; }
    100% { transform: translate(var(--dx), var(--dy)) scale(1.2) rotate(35deg); opacity: 0; }
  }
  /* Anellino â€œpulseâ€ sulla carta matched */
  .card[data-state="matched"] .front { animation: ringPulse 420ms ease-out; }
  @keyframes ringPulse {
    0%   { box-shadow: 0 0 0 0 rgba(82,206,137,.45) inset; }
    100% { box-shadow: 0 0 18px rgba(82,206,137,.45) inset; }
  }

  /* AccessibilitÃ : niente animazioni se lâ€™utente le riduce */
  @media (prefers-reduced-motion: reduce){
    .match-stars .star, .card[data-state="matched"] .front { animation: none !important; }
  }

  @keyframes flashUp{
    0%{opacity:0; transform:translate(-50%, 8px)}
    15%{opacity:1; transform:translate(-50%, 0)}
    100%{opacity:0; transform:translate(-50%, -8px)}
  }

  /* Overlay unificato */
  .overlay{
    position:fixed;
    inset:0;
    display:none;
    place-items:center;
    background: rgba(10,12,22,.45);
    -webkit-backdrop-filter: blur(10px) saturate(110%);
    backdrop-filter: blur(10px) saturate(110%);
    z-index:1000;
  }
  .overlay.show{ display:grid }

  .dialog{ width:min(640px, 92vw); background:linear-gradient(180deg,var(--panel-1),var(--panel-2)); border:1px solid var(--panel-border);
    border-radius:20px; padding:24px; text-align:center; box-shadow:var(--shadow) }
  .dialog h2{ margin:6px 0 8px; font-size:28px }
  .dialog p{ margin:0 0 14px; color:var(--muted) }

  @media (max-width: 600px){
    .wrap{ width:min(520px, 96vw) }
    .top, .grid{ width:100% }
  }

  /* Disabilita il flip animato quando vogliamo richiudere le carte di colpo */
  .no-flip .inner { transition: none !important; }
  .simon-ghost { z-index: 30; }

  /* Quando Ã¨ attivo il Simon, impedisci ogni flip e nascondi la faccia front */
  body.mode-simon .card .inner{ transform: none !important; transition: none !important; }
  body.mode-simon .card .front{ visibility: hidden !important; }

  /* Pulsanti Pausa, Salva, Ricomincia in versione outline */
  .outline-btn { background: transparent !important; color: var(--accent) !important; border: 2px solid var(--accent) !important; }
  .outline-btn:hover { background: rgba(255, 255, 255, 0.05); }
  .outline-btn:active { background: rgba(255, 255, 255, 0.12); }

  /* Splash pre-tutorial */
  .splash{
    position: fixed;
    inset: 0;
    z-index: 2000;
    display: grid;
    place-items: center;
    background: linear-gradient(180deg, var(--bg-1), var(--bg-2));
    transition: opacity 280ms ease, visibility 280ms ease;
    opacity: 1;
    visibility: visible;
    cursor: pointer;
  }
  .splash.hide{ opacity: 0; visibility: hidden; pointer-events: none; }
  .splash .splash-art{
    width: min(70vmin, 900px);
    max-width: 92vw;
    height: auto;
    filter: drop-shadow(0 24px 50px rgba(0,0,0,.45));
  }
  .splash .splash-skip{
    position: absolute;
    bottom: 28px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0,0,0,.35);
    border: 1px solid var(--panel-border);
    color: var(--muted);
    padding: 8px 12px;
    border-radius: 999px;
    font-size: 14px;
    user-select: none;
  }

  /* Tutorial a slide */
  .tutorial-dialog{ position:relative; overflow:hidden; }
  .tutorial-carousel{ position:relative; min-height: 140px; }
  .tutorial-slide[hidden]{ display:none !important; }

  .tutorial-arrow{
    position:absolute;
    bottom: 20px;
    width:38px; height:38px;
    display:grid; place-items:center;
    border-radius:999px;
    border:1px solid var(--panel-border);
    background:linear-gradient(180deg, var(--panel-1), var(--panel-2));
    color:var(--text);
    cursor:pointer;
    box-shadow: var(--shadow);
    user-select:none;
  }
  .tutorial-arrow.prev{ left:10px; }
  .tutorial-arrow.next{ right:10px; }
  .tutorial-arrow:disabled{ opacity:.5; cursor:default; }

  .tutorial-dots{
    display:flex; gap:8px; justify-content:center; align-items:center;
    margin-top:12px;
  }
  .tutorial-dots button{
    width:8px; height:8px; border-radius:999px; border:none;
    background:#3a4168; cursor:pointer;
  }
  .tutorial-dots button[aria-current="true"]{
    width:22px; height:8px; border-radius:999px; background:var(--accent);
  }

  .big-symbol{
    font-size: clamp(42px, 10vw, 72px);
    line-height: 1;
    filter: drop-shadow(0 6px 16px rgba(0,0,0,.35));
  }

  /* X in alto a destra */
  .tutorial-close{
    position:absolute; top:10px; right:10px;
    width:34px; height:34px; display:grid; place-items:center;
    border-radius:10px;
    border:1px solid var(--panel-border);
    background:linear-gradient(180deg, var(--panel-1), var(--panel-2));
    color:var(--muted);
    cursor:pointer;
  }

  /* --- Testo centrato e niente pallini nelle slide del tutorial --- */
  #intro .tutorial-slide { text-align: center; }
  #intro .tutorial-slide ul { list-style: none; padding: 0; margin: 10px 0 0; }
  #intro .tutorial-slide li { margin: 8px 0; }
  #intro .tutorial-slide h3{ margin: 6px 0 10px; font-size: 22px; }

  /* Close del popup Salvataggi (stile coerente col tutorial) */
  .save-close{
    position:absolute; top:10px; right:10px;
    width:34px; height:34px; display:grid; place-items:center;
    border-radius:10px;
    border:1px solid var(--panel-border);
    background:linear-gradient(180deg,var(--panel-1),var(--panel-2));
    color:var(--muted);
    cursor:pointer;
  }

  /* Bottoni icona (Upload, Cestino) */
  .icon-btn{
    width:36px; height:36px;
    display:grid; place-items:center;
    border-radius:10px;
    border:1px solid var(--panel-border);
    background:linear-gradient(180deg,var(--panel-1),var(--panel-2));
    color:var(--text);
    cursor:pointer;
    box-shadow:var(--shadow);
    font-size:18px; line-height:1;
  }
  .icon-btn:hover{ filter:brightness(1.05) }
  .icon-btn:active{ transform:translateY(1px) }

  /* --- SIMON (flash del fantasmino) --- */
  .simon-ghost{
    position:absolute; inset:0;
    display:grid; place-items:center;
    font-size: clamp(36px, 50cqi, 90px);
    border:2px solid var(--accent);
    border-radius: var(--radius);
    background: rgba(255,255,255,.05);
    animation: simonFlash .55s ease-out;
    filter: drop-shadow(0 10px 24px rgba(0,0,0,.35));
    pointer-events: none;
    backface-visibility: hidden;
    transform: translateZ(0);
    will-change: transform, opacity;
  }
  @keyframes simonFlash{
    0%{ opacity:.15; transform:scale(.92) }
    50%{ opacity:1; transform:scale(1.02) }
    100%{ opacity:0; transform:scale(1) }
  }
  .no-flip .card[data-state="hidden"] .front { visibility: hidden; }

  /* --- Poteri: stile dedicato --- */
  .controls-right .power-btn{
    width: 46px; height: 46px;
    padding: 0;
    border-radius: 999px;
    display: grid; place-items: center;
    border: 2px solid var(--accent);
    background: linear-gradient(180deg, var(--panel-1), var(--panel-2));
    box-shadow: var(--shadow);
    font-size: 20px;
    transition:
      filter .18s ease, opacity .18s ease,
      transform .12s ease, box-shadow .18s ease, border-color .18s ease;
  }
  .controls-right .power-btn:not(:disabled):hover{
    transform: translateY(-1px);
    box-shadow: 0 14px 28px rgba(0,0,0,.45);
  }
  .controls-right .power-btn:not(:disabled):active{ transform: translateY(0); }

  /* Stato â€œprontoâ€ (abilitato): leggero bagliore/pulse */
  @keyframes powerPulse {
    0%   { box-shadow: 0 0 0 0 rgba(116,132,255,.25); }
    70%  { box-shadow: 0 0 0 8px rgba(116,132,255,0); }
    100% { box-shadow: 0 0 0 0 rgba(116,132,255,0); }
  }
  .controls-right .power-btn.ready{ animation: powerPulse 1.2s ease-out infinite; }
  #powerReveal.ready { border-color: #ffd54f; }
  #powerPlus10.ready { border-color: #60e8a8; }
  #powerShift.ready  { border-color: #ff7aa2; }
/* --- Zen: BUCHI (âš¡â†’ buco) --- */
.card.placeholder.hole{
  position: relative;
  border: 1px dashed var(--panel-border);
  background: transparent;
  box-shadow: none;
  pointer-events: none;
}
.card.placeholder.hole::after{
  content:"";
  position:absolute; inset:10px;
  border-radius:12px;
  background: radial-gradient(closest-side, rgba(255,255,255,.08), transparent 70%);
  animation: holePulse 1.8s ease-in-out infinite;
}
@keyframes holePulse { 0%{opacity:.5} 50%{opacity:.75} 100%{opacity:.5} }

/* telegraph prima dello shift */
.hole-blink::after{
  animation: holeBlink .12s ease-out 1, holePulse 1.8s ease-in-out infinite .12s;
}
@keyframes holeBlink {
  0%{ box-shadow:0 0 0 0 rgba(255,255,255,.35) }
  100%{ box-shadow:0 0 0 14px rgba(255,255,255,0) }
}

/* feedback se bloccato */
.hole-shake{ animation: holeShake .2s ease; }
@keyframes holeShake {
  0%,100%{ transform: translateX(0); }
  25%{ transform: translateX(-2px); }
  75%{ transform: translateX(2px); }
}

/* mini pop/dissolve del âš¡ quando diventa buco */
.card.pop-out .front{ animation: popOut .16s ease-out forwards; }
@keyframes popOut { to { transform: scale(.85); opacity: 0; } }
/* --- Tutorial: contatore, progress bar, hint --- */
.tutorial-title{
  display:flex; align-items:center; justify-content:center; gap:10px;
  margin-bottom: 8px;
}
.tutorial-count{
  display:inline-flex; align-items:center; justify-content:center;
  min-width: 38px; padding: 3px 8px; border-radius: 999px;
  font-size: 13px; color: var(--muted);
  border:1px solid var(--panel-border);
  background: linear-gradient(180deg, var(--panel-1), var(--panel-2));
}
.tutorial-progress{
  height: 4px; width: 100%; border-radius: 999px;
  background: rgba(255,255,255,.06);
  overflow: hidden; margin: 8px 0 4px;
}
.tutorial-progress-bar{
  height: 100%; width: 0%;
  background: var(--accent);
  transition: width .25s ease;
}
.tutorial-hint{
  text-align:center; color: var(--muted); font-size: 13px;
  margin-top: 8px; user-select: none;
}
/* Nascondi del tutto la progress bar quando inutilizzata */
.tutorial-progress[aria-hidden="true"],
.tutorial-progress[hidden]{
  display: none;
}

</style>
</head>
<body class="theme-1">
<!-- â¬‡ï¸ AGGIUNGI QUESTA RIGA PRIMA DEL TUO <script> PRINCIPALE -->
<script src="sfx.js?v=6"></script>
<div class="wrap">
  <div class="top">
    <div class="brand">
      <img src="skullory-logo.svg" alt="Skullory">
    </div>
    <div class="stats-container">
      <div class="stats">
        <span class="level-chip" id="levelChip">Livello: â€”</span>
        <span class="level-chip" id="statusChip">Stato: â€”</span>
        <span class="level-chip" id="moves" aria-live="polite">Mosse: 0</span>
        <span class="chip timer" id="timer" aria-live="polite">0:30</span>
        <span class="chip" id="score" aria-live="polite" style="color:#FFF44F">Punti: 0</span>
      </div>
    </div>

    <div class="grid" id="grid" aria-label="Griglia Skullory"></div>

    <div class="controls controls-bottom">
      <div class="controls-left">
        <button class="primary outline-btn" id="pause">â¸ï¸</button>
        <button class="primary outline-btn" id="save">ğŸ’¾</button>
        <button class="primary outline-btn" id="restart" title="Home" aria-label="Home">ğŸ </button>
        <button class="primary outline-btn" id="audioCycle" title="Audio">ğŸµ</button>
      </div>

      <div class="controls-right">
        <button class="primary outline-btn power-btn" id="powerReveal"
          title="ğŸ‘ï¸ Svela per 1s (âˆ’20% tempo, min âˆ’4s, non sotto 3s) Â· 1Ã—">ğŸ‘ï¸</button>
        <button class="primary outline-btn power-btn" id="powerPlus10"
          title="ğŸ¦‡ +10s (sacrifica 1 coppia a caso, rilocalizzata) Â· 1Ã—">ğŸ¦‡</button>
        <button class="primary outline-btn power-btn" id="powerShift"
          title="ğŸŒ€ Sposta ğŸ’€ e âš¡, rimescola (come âš¡), +15s Â· 1Ã—">ğŸŒ€</button>
      </div>
    </div>

    <!-- Intro / Tutorial (carousel a 3 slide) -->
    <div class="overlay hide" id="intro">
      <div class="dialog tutorial-dialog">
        <button class="tutorial-close" id="intro-close" aria-label="Chiudi tutorial">âœ•</button>
        <div class="tutorial-title">
  <h2 id="intro-title" style="margin-bottom:8px">Come si gioca</h2>
  <span id="intro-count" class="tutorial-count" hidden>1/3</span>
</div>


        <div class="tutorial-carousel" aria-live="polite">
<div class="tutorial-progress" id="intro-progress-wrap" aria-hidden="true">
  <div class="tutorial-progress-bar" id="intro-progress"></div>
</div>

  <!-- Slide 0 (scelta modalitÃ ) -->
<div class="tutorial-slide" data-mode="root">
  <h3 style="color:#FFF44F">Scegli come giocare</h3>

  <div style="
    display:flex; flex-direction:column; gap:10px; align-items:center;
    margin-top:12px; width:100%; max-width:420px; margin-left:auto; margin-right:auto;
  ">
    <button class="primary" id="intro-chaos-main"  style="width:100%">ğŸ§ª Chaos â€” Sfida del giorno!</button>
    <button class="primary outline-btn" id="intro-arcade-main" style="width:100%">ğŸ® Arcade â€” Scala i livelli!</button>
    <button class="primary outline-btn" id="intro-zen-main"    style="width:100%">ğŸ§˜ Zen â€” Allenati!</button>
  </div>

  <p style="color:var(--muted); margin-top:12px; max-width:520px; margin-left:auto; margin-right:auto;">
    <b>Chaos</b>: la stessa griglia per tutti ogni giorno.<br/>
    <b>Arcade</b>: livelli, timer, bonus, poteri.<br/>
    <b>Zen</b>: puro allenamento e rating finale.
  </p>
</div>

  <!-- Slide Arcade 1 -->
  <div class="tutorial-slide" data-mode="arcade">
    <h3 style="color:#FFF44F">Obiettivo</h3>
    <ul>
      <li>Trova tutte le <b>coppie</b> ribaltando le carte, ma <b>occhio al tempo!</b></li>
      <li><b>Sblocco livello</b>: completa lo stesso livello <b>3 volte di fila</b>!</li>
      <li>Dopo lo sblocco resti sul livello <b>per fare punti</b>.</li>
      <li><b>Al primo errore</b>, sali al livello successivo.</li>
    </ul>
  </div>

  <!-- Slide Arcade 2 -->
  <div class="tutorial-slide" data-mode="arcade" hidden>
    <h3 style="color:#FFF44F">Carte speciali</h3>
    <div style="display:flex; gap:18px; align-items:center; justify-content:center; margin:10px 0 6px">
      <div class="big-symbol" aria-hidden="true">âš¡</div>
      <div class="big-symbol" aria-hidden="true">ğŸ’€</div>
    </div>
    <ul>
      <li>âš¡ rimescola tutte le carte coperte (tranne ğŸ’€ e âš¡).</li>
      <li>ğŸ’€ se rivelato due volte: <b>sconfitta!</b></li>
    </ul>
  </div>

  <!-- Slide Arcade 3 -->
  <div class="tutorial-slide" data-mode="arcade" hidden>
    <h3 style="color:#FFF44F">Bonus, penalitÃ  e punteggio</h3>
    <ul>
      <li><b>Bonus 1</b>: ogni coppia trovata = <b>+1s</b></li>
      <li><b>Bonus 2</b>: 2 coppie di fila entro 5s = <b>+5s</b></li>
      <li><b>PenalitÃ </b>: ogni errore <b>âˆ’1s</b></li>
      <li><b>Punteggio</b>: secondi risparmiati <b>x</b> efficienza mosse.</li>
    </ul>
  </div>

  <!-- Slide Zen -->
  <div class="tutorial-slide" data-mode="zen" hidden>
    <h3 style="color:#FFF44F">Gioca in relax!</h3>
    <ul>
      <li>Nessun timer, nessun punteggio a schermo.</li>
      <li>Giochi tranquillo: niente poteri, niente carte speciali.</li>
      <li>Alla fine vedi il report: <b>tempo</b>, <b>mosse</b>, <b>efficienza</b> e â­.</li>
    </ul>
  </div>

<!-- Slide Chaos -->
<div class="tutorial-slide" data-mode="chaos" hidden>
  <h3 style="color:#FFF44F">Sfida gli amici a fare meglio!</h3>
  <ul>
    <li>Ogni giorno una griglia identica per tutti!.</li>
    <li>Condividi il tuo punteggio migliore!</li>
    <li>âš¡ : rimescola le coperte; ma <b>se lo clicchi 2 volte</b> diventa un <b>buco</b>!</li>
    <li><b>ğŸ’€ </b>: annulla una <b>coppia trovata</b> (se câ€™Ã¨) e <b>rimescola le carte coperte</b>!</li>
    <li>Quando fai una coppia, il buco attira <b>1â€“4 carte coperte</b> adiacenti!</li>
  </ul>
</div>

</div>


        <button class="tutorial-arrow prev" id="intro-prev" aria-label="Slide precedente">â€¹</button>
        <button class="tutorial-arrow next" id="intro-next" aria-label="Slide successiva">â€º</button>

        <div class="tutorial-dots" id="intro-dots" role="tablist" aria-label="Pagine tutorial"></div>
<div class="tutorial-hint" id="intro-hint" hidden>3 pagine â€” scorri o usa le frecce â€º</div>


        <div class="actions" style="margin-top:14px; display:flex; justify-content:center; gap:10px">
          <button class="primary" id="intro-play">Gioca</button>
        </div>
      </div>
    </div>

    <!-- Gestore Salvataggi (Modal) -->
    <!-- Conferma Ricomincia -->
    <div class="overlay" id="restartConfirm" aria-hidden="true">
      <div class="dialog">
        <h2>Vuoi ricominciare ?</h2>
        <p style="margin-top:4px; color:var(--muted)">Perderai lo stato del quadro corrente.</p>
        <div style="display:flex; gap:10px; justify-content:center; margin-top:8px">
          <button class="primary" id="restart-yes">SÃ¬, ricomincia</button>
          <button class="primary" id="restart-no" style="background:var(--bad); color:#fff">Annulla</button>
        </div>
      </div>
    </div>

    <div class="overlay" id="saveModal" aria-hidden="true">
      <div class="dialog" style="text-align:left; position:relative">
        <button class="save-close" id="save-close" aria-label="Chiudi salvataggi">âœ•</button>
        <h2 style="text-align:center; margin-top:2px">Salvataggi</h2>
        <div id="saveList" style="max-height:46vh; overflow:auto; margin:8px 0 12px"></div>

        <div id="saveControls" style="display:flex; gap:8px; align-items:center; margin-top:6px">
          <input id="saveName" placeholder="Nome partitaâ€¦"
            style="width:150px; padding:10px 12px; border-radius:10px;
                   border:1px solid var(--panel-border); background:var(--panel-2);
                   color:var(--text)"/>
          <button class="primary" id="doSave">Salva</button>
        </div>

        <p style="color:var(--muted); margin-top:10px">
          I salvataggi sono consentiti <b>solo a fine quadro</b> o <b>prima di iniziare</b> il prossimo.
        </p>
      </div>
    </div>

    <!-- Overlay di fine quadro -->
<div class="overlay" id="overlay">
  <div class="dialog" style="position:relative">
    <button class="tutorial-close" id="ov-close" aria-label="Chiudi">âœ•</button>
    <h2 id="ov-title">Hai vinto!</h2>

        <p id="ov-sub">Tempo rimasto: â€”</p>

        <div class="ov-actions" style="display:flex;gap:10px;justify-content:center;flex-wrap:wrap">
          <button class="primary" id="ov-btn">Continua</button>
          <button class="primary outline-btn" id="ov-btn-skip" style="display:none">Salta</button>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  const RED = 'ğŸ’€';
  const YELLOW = 'âš¡';
// Durate identiche a quelle giÃ  percepite (mismatch ~420ms)
const MISMATCH_HOLD_MS = 420;
const MATCH_HOLD_MS = 120; // per coerenza (non serve bloccare lâ€™input)

  // --- SIMON: manopole per le durate ---
  const SIMON_CFG = {
    previewMs: 700,
    gapMs: 140,
    inputRevealMs: 520,
    wrongHoldMs: 850,
    startLen: 3
  };

  const GHOST = 'ğŸ‘»';
  let sim = null;
  let modeZen = false;
let zenVariant = 'zen'; // 'zen' | 'chaos'


  const STORAGE_KEY = 'skullory_save_v1';
  const SAVES_KEY = 'skullory_saves_v2';

  const LEVELS = [
    { name: '3Ã—3 (no centro)', side: 3, disabled: [4], pairs: 3, red: 0, yellow: 2, timeMs: 20000, unlockMs: [20000, 15000, 10000], postDeltaSec: 1 },
    { name: '3Ã—3', side: 3, disabled: [], pairs: 4, red: 1, yellow: 0, timeMs: 40000, unlockMs: [40000, 35000, 30000], postDeltaSec: 2 },
    { name: '4Ã—4 (â€“angoli)', side: 4, disabled: [0,3,12,15], pairs: 5, red: 1, yellow: 1, timeMs: 45000, unlockMs: [45000, 40000, 35000], postDeltaSec: 2 },
    { name: '4Ã—4', side: 4, disabled: [], pairs: 7, red: 1, yellow: 1, timeMs: 60000, unlockMs: [60000, 55000, 50000], postDeltaSec: 2 },
    { name: '5Ã—5 (caotico simm.)', side: 5, disabled: [1,3,5,9,12,15,19,21,23], pairs: 6, red: 1, yellow: 3, timeMs: 65000, unlockMs: [65000, 60000, 55000], postDeltaSec: 3 },
    { name: '5Ã—5 (cornice)', side: 5, disabled: [0,4,12,20,24], pairs: 9, red: 1, yellow: 1, timeMs: 70000, unlockMs: [70000, 65000, 60000], postDeltaSec: 3 },
    { name: '5Ã—5 (â€“angoli)', side: 5, disabled: [0,4,20,24], pairs: 9, red: 1, yellow: 2, timeMs: 70000, unlockMs: [70000, 65000, 60000], postDeltaSec: 3 },
    { name: '5Ã—5', side: 5, disabled: [], pairs: 11, red: 1, yellow: 2, timeMs: 80000, unlockMs: [80000, 75000, 70000], postDeltaSec: 3 },
    { name: '6Ã—6 (croce)', side: 6, disabled: [0,1,4,5,6,11,24,29,30,31,34,35], pairs: 10, red: 1, yellow: 3, timeMs: 90000, unlockMs: [90000, 85000, 80000], postDeltaSec: 3 },
    { name: '6Ã—6 (cornici+centro)', side: 6, disabled: [0, 5, 30, 35, 14, 15, 20, 21], pairs: 12, red: 1, yellow: 3, timeMs: 112000, unlockMs: [112000, 108000, 104000], postDeltaSec: 4 },
    { name: '6Ã—6 (â€“angoli)', side: 6, disabled: [0,5,30,35], pairs: 14, red: 1, yellow: 3, timeMs: 95000, unlockMs: [95000, 90000, 85000], postDeltaSec: 3 },
    { name: '6Ã—6', side: 6, disabled: [], pairs: 16, red: 1, yellow: 3, timeMs: 100000, unlockMs: [100000, 95000, 90000], postDeltaSec: 3 }
  ];

  const EMOJI = ['ğŸ¶','ğŸ±','ğŸ¦Š','ğŸ¼','ğŸµ','ğŸ¯','ğŸ¦','ğŸ¸','ğŸ¨','ğŸ¦„','ğŸ·','ğŸ¹','ğŸ™','ğŸ¦‰','ğŸ¦‹','ğŸ','ğŸ¢','ğŸ ','ğŸ','ğŸ‰','ğŸ‡','ğŸ’','ğŸ“','ğŸ‘','ğŸ¥‘','ğŸŒ½','ğŸ¥•','ğŸ©','ğŸª','ğŸ°','ğŸ”','ğŸ•','ğŸ£','ğŸ¤','ğŸœ','ğŸ¿','ğŸ‹','ğŸ¦­','ğŸ¦€','ğŸ','ğŸ','ğŸ¦œ','ğŸ¦¢','ğŸ','ğŸ«','ğŸ¦’','ğŸ¿','ğŸ¦”','ğŸ¦©','ğŸ¬','ğŸ³','ğŸ¦¦','ğŸ¡','ğŸŒ','ğŸ‹','ğŸŠ','ğŸ«','ğŸ¥¥','ğŸ¥­','ğŸ¥’','ğŸ«‘','ğŸ¥”','ğŸŒ¶','ğŸ„','ğŸ§„','ğŸ§…','ğŸ§€','ğŸ¥¨','ğŸ¥¯','ğŸ¥','ğŸ¥ª','ğŸ¥™','ğŸ¥—','ğŸ¥˜','ğŸ¥Ÿ','ğŸ®','ğŸ«','ğŸ¹','ğŸ§‹','ğŸº','â˜•','ğŸ¥›','ğŸ·','ğŸµ'];

const GAME_URL = 'https://dadegames.github.io/Skullory/';
// --- Zen: buchi (fulmineâ†’buco)
const HOLE_SHIFT_MS_MIN = 140;
const HOLE_SHIFT_MS_MAX = 180;
// === DAILY (seed-based) ===============================================
// Hash deterministico 32 bit
function hashString(str){
  let hash = 0;
  for (let i = 0; i < str.length; i++){
    hash = ((hash << 5) - hash) + str.charCodeAt(i);
    hash |= 0; // 32-bit
  }
  return hash >>> 0; // unsigned
}

// PRNG deterministic (Mulberry32)
function mulberry32(a){
  let t = a >>> 0;
  return function(){
    t += 0x6D2B79F5;
    t = Math.imul(t ^ (t >>> 15), t | 1);
    t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
  };
}

// Shuffle con RNG passato
function shuffleWithRng(arr, rng){
  const a = arr.slice();
  for (let i = a.length - 1; i > 0; i--){
    const j = Math.floor(rng() * (i + 1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}

// buildDeck deterministica
function buildDeckWithRng(level, rng){
  const pool = shuffleWithRng(EMOJI, rng);
  const unique = pool.slice(0, level.pairs);
  const pairs = unique.concat(unique);
  const specials = [
    ...Array(level.red).fill(RED),
    ...Array(level.yellow).fill(YELLOW)
  ];
  const deck = pairs.concat(specials);
  return shuffleWithRng(deck, rng);
}

function todayStr(){
  const d = new Date();
  const y = d.getFullYear();
  const m = String(d.getMonth()+1).padStart(2,'0');
  const day = String(d.getDate()).padStart(2,'0');
  return `${y}-${m}-${day}`;
}

function getDailyChallenge(){
  const today = todayStr();
  const seed = hashString(`skullory_daily_${today}`);
  const rng  = mulberry32(seed);

  // Fissa la daily sul livello 5Ã—5 piena (nessuna cella disabilitata)
  let levelIndex = LEVELS.findIndex(L => L.side === 5 && (!L.disabled || L.disabled.length === 0));
  if (levelIndex < 0) levelIndex = 7; // fallback sicuro se cambi ordine in futuro

  const deck = buildDeckWithRng(LEVELS[levelIndex], rng);
  return { level: levelIndex, deck, date: today, id: `daily_${today}` };
}


// === Record giornaliero (localStorage) ================================
// Ordine: mosse < tempo < stelle; in paritÃ  totale vince la PRIMA run.
function isRunBetter(a, b){
  if (!b) return true;
  if (a.moves !== b.moves) return a.moves < b.moves;
  if (a.timeMs !== b.timeMs) return a.timeMs < b.timeMs;
  if (a.stars !== b.stars)   return a.stars > b.stars;
  return (a.ts || 0) < (b.ts || 0);
}
function dailyKey(date){ return `skullory_daily_record_${date}`; }
function readDailyRecord(date){
  try{
    const raw = localStorage.getItem(dailyKey(date));
    return raw ? JSON.parse(raw) : null;
  }catch(_){ return null; }
}
function writeDailyRecord(date, rec){
  try{ localStorage.setItem(dailyKey(date), JSON.stringify(rec)); }catch(_){}
}
function fmtShortSecDiff(ms){
  const sec = Math.max(0, Math.ceil(Math.abs(ms) / 1000));
  return (sec < 10 ? '0' + sec : '' + sec) + 's';
}

  // --- SFX: inizializza al primo gesto utente ---
  function ensureSfx(){
    if (window.__sfxReady) return;
    window.__sfxReady = true;

    try {
      SFX.init();

      if (window.BGM){
        BGM._markInteracted();
        BGM.start();
        BGM.updateUi?.();
      }

      if (!SFX.__wrapped){
        const origPlay = SFX.play.bind(SFX);
        SFX.play = (name, opts = {}) => {
          if (name === 'bgm') {
            if (musicMuted) return null;
            if (opts.volume == null) opts.volume = 0.18;
            opts.loop = (opts.loop !== false);
          } else {
            if (sfxMuted) return null;
          }
          return origPlay(name, opts);
        };
        SFX.__wrapped = true;
      }

      setMusicMuted(musicMuted);
      setSfxMuted(sfxMuted);
      refreshAudioButtons();

    } catch(e){
      window.__sfxReady = false;
    }
  }

  function setMusicMuted(v){
    musicMuted = !!v;
    localStorage.setItem('skullory.musicMuted', JSON.stringify(musicMuted));

    if (window.BGM) {
      if (musicMuted) {
        try { BGM.setEnabled(false); } catch(_) {}
        try { BGM.stop(); } catch(_) {}
      } else {
        try { BGM.setEnabled(true); } catch(_) {}
        try { BGM.start(); } catch(_) {}
      }
    }
    refreshAudioButtons();
  }

  function setSfxMuted(v){
    sfxMuted = !!v;
    localStorage.setItem('skullory.sfxMuted', JSON.stringify(sfxMuted));
    if (window.SFX && SFX.setSfxMuted) SFX.setSfxMuted(sfxMuted);
    refreshAudioButtons();
  }

  // 0 = musica+SFX, 1 = solo SFX, 2 = tutto OFF
  function getAudioMode(){
    if (!musicMuted && !sfxMuted) return 0;
    if (musicMuted && !sfxMuted)  return 1;
    return 2;
  }
  function setAudioMode(mode){
    if (mode === 0){ setMusicMuted(false); setSfxMuted(false); }
    else if (mode === 1){ setMusicMuted(true); setSfxMuted(false); }
    else { setMusicMuted(true); setSfxMuted(true); }
  }
  function cycleAudioMode(){
    const next = (getAudioMode() + 1) % 3;
    setAudioMode(next);
    if (next === 0)      flashMessage('Audio: musica + effetti');
    else if (next === 1) flashMessage('Audio: solo effetti');
    else                 flashMessage('Audio: spento');
    refreshAudioButtons();
  }

  const grid = document.getElementById('grid');
  const movesEl = document.getElementById('moves');
  const timerEl = document.getElementById('timer');
  const restartBtn = document.getElementById('restart');
  const overlay = document.getElementById('overlay');
  const ovTitle = document.getElementById('ov-title');
  const ovSub = document.getElementById('ov-sub');
  const ovBtn = document.getElementById('ov-btn');
  const ovBtnSkip = document.getElementById('ov-btn-skip');
  function showSkip(v){ if (ovBtnSkip) ovBtnSkip.style.display = v ? '' : 'none'; }
  const pauseBtn = document.getElementById('pause');
  const saveBtn = document.getElementById('save');
  const levelChip = document.getElementById('levelChip');
  const statusChip = document.getElementById('statusChip');
  const scoreChip = document.getElementById('score');

  const powerRevealBtn = document.getElementById('powerReveal');
  const powerPlus10Btn = document.getElementById('powerPlus10');
  const powerShiftBtn  = document.getElementById('powerShift');

  // ğŸ”Š Bottone unico audio (ğŸµ â†’ ğŸ”Š â†’ ğŸ”‡)
  const audioBtn = document.getElementById('audioCycle');
  if (audioBtn) {
    audioBtn.addEventListener('click', () => {
      ensureSfx();
      cycleAudioMode();
    });
  }

  let musicMuted = JSON.parse(localStorage.getItem('skullory.musicMuted') || 'false');
  let sfxMuted   = JSON.parse(localStorage.getItem('skullory.sfxMuted')   || 'false');
  refreshAudioButtons();

  const restartConfirm = document.getElementById('restartConfirm');
  const restartYes = document.getElementById('restart-yes');
  const restartNo = document.getElementById('restart-no');

  const saveModal = document.getElementById('saveModal');
  const saveList = document.getElementById('saveList');
  const saveNameInput = document.getElementById('saveName');
  const doSaveBtn = document.getElementById('doSave');
  const saveClose = document.getElementById('save-close');

  const intro = document.getElementById('intro');
  const introBtn = document.getElementById('intro-play');

  // ===== TUTORIAL =====
  let currentSlide = 0;
  const slides = [];
  let dotsWrap, prevBtn, nextBtn, closeBtn;
  let allSlides = [];
  let tutorialMode = 'root';
let countBadge, progressWrap, progressBar, hintEl;
  function rebuildDots(){
    dotsWrap.innerHTML = '';
    slides.length = 0;
    const active = allSlides.filter(s => s.dataset.mode === tutorialMode);
    active.forEach(s => slides.push(s));

    allSlides.forEach(s => s.setAttribute('hidden',''));
    slides.forEach(s => s.removeAttribute('hidden'));

    slides.forEach((_, i) => {
      const d = document.createElement('button');
      d.setAttribute('aria-label', `Vai alla slide ${i+1}`);
      d.addEventListener('click', () => goToSlide(i));
      dotsWrap.appendChild(d);
    });

    const multi = slides.length > 1;
    if (prevBtn)  prevBtn.style.display  = multi ? '' : 'none';
    if (nextBtn)  nextBtn.style.display  = multi ? '' : 'none';
    if (dotsWrap) dotsWrap.style.display = multi ? '' : 'none';
  }

  function setTutorialMode(mode){
  tutorialMode = mode;
  rebuildDots();
  goToSlide(0);

  const introTitle = document.getElementById('intro-title');
  if (introTitle){
    if (mode === 'root') {
      introTitle.style.display = 'none';
    } else {
      introTitle.style.display = '';
    introTitle.textContent =
      mode === 'arcade' ? 'Arcade - Scala i livelli' :
      mode === 'zen'    ? 'Zen - Allenamento' :
      mode === 'chaos'  ? 'Chaos - Sfida del Giorno' :
                           '';

    }
  }

  // usa la variabile globale giÃ  definita in alto: const introBtn = document.getElementById('intro-play');
  if (introBtn){
    if (mode === 'arcade'){
      introBtn.textContent = 'Gioca (Arcade)';
      introBtn.onclick = () => { ensureSfx(); modeZen = false; currentLevelIdx = 0; hideIntro(); startArcade(); };
      introBtn.style.display = '';
    } else if (mode === 'zen'){
      introBtn.textContent = 'Gioca (Zen)';
      introBtn.onclick = () => { ensureSfx(); modeZen = true; hideIntro(); startZen('zen'); };
      introBtn.style.display = '';
   } else if (mode === 'chaos'){
  introBtn.textContent = 'Gioca (Sfida del giorno)';
  introBtn.onclick = () => { ensureSfx(); startDailyChaos(); };
  introBtn.style.display = '';
    } else {
      // root e zen-choose: niente tasto play centrale (si usano i bottoni nella slide)
      introBtn.textContent = 'Gioca';
      introBtn.onclick = () => {};
      introBtn.style.display = 'none';
    }
  }
}


function buildTutorialRefs(){
  dotsWrap = document.getElementById('intro-dots');
  prevBtn  = document.getElementById('intro-prev');
  nextBtn  = document.getElementById('intro-next');
  closeBtn = document.getElementById('intro-close');
countBadge   = document.getElementById('intro-count');
progressWrap = document.getElementById('intro-progress-wrap');
progressBar  = document.getElementById('intro-progress');
hintEl       = document.getElementById('intro-hint');


  allSlides = Array.from(document.querySelectorAll('#intro .tutorial-slide'));

  // Frecce
  prevBtn.addEventListener('click', () => goToSlide(currentSlide - 1));
  nextBtn.addEventListener('click', () => goToSlide(currentSlide + 1));

  // X in alto a destra: se sei giÃ  nella root, chiudi; altrimenti torna alla root
  closeBtn.onclick = () => {
    if (tutorialMode === 'root') hideIntro();
    else setTutorialMode('root');
  };

  // Tastiera
  document.addEventListener('keydown', (e) => {
    if (intro.classList.contains('hide')) return;
    if (e.key === 'ArrowLeft')  goToSlide(currentSlide - 1);
    if (e.key === 'ArrowRight') goToSlide(currentSlide + 1);
  });

  // Bottoni della slide root (menu unico)
  const btnChaosMain  = document.getElementById('intro-chaos-main');
  const btnArcadeMain = document.getElementById('intro-arcade-main');
  const btnZenMain    = document.getElementById('intro-zen-main');

  if (btnChaosMain)  btnChaosMain.addEventListener('click',  () => setTutorialMode('chaos'));
  if (btnArcadeMain) btnArcadeMain.addEventListener('click', () => setTutorialMode('arcade'));
  if (btnZenMain)    btnZenMain.addEventListener('click',    () => setTutorialMode('zen'));


  // Mostra la root allâ€™apertura
  setTutorialMode('root');
}


  function goToSlide(i){
    currentSlide = Math.max(0, Math.min(slides.length - 1, i));
    slides.forEach((el, idx) => {
      if (idx === currentSlide) el.removeAttribute('hidden');
      else el.setAttribute('hidden', '');
    });

    Array.from(dotsWrap.children).forEach((dot, idx) => {
      dot.setAttribute('aria-current', idx === currentSlide ? 'true' : 'false');
    });

    prevBtn.disabled = (currentSlide === 0);
    nextBtn.disabled = (currentSlide === slides.length - 1);
updateTutorialUI();

  }
function updateTutorialUI(){
  const total = slides.length || 1;
  const n = Math.min(total, Math.max(1, currentSlide + 1));
  const multi = total > 1;

  // Mostra UI di avanzamento SOLO per Arcade con piÃ¹ di 1 slide
  const showUi = (tutorialMode === 'arcade' && multi);

  // Badge 1/3
  if (countBadge){
    countBadge.textContent = `${n}/${total}`;
    countBadge.hidden = !showUi;
  }

  // Progress bar
  if (progressWrap){
    progressWrap.hidden = !showUi;
    progressWrap.setAttribute('aria-hidden', showUi ? 'false' : 'true');
  }
  if (progressBar && showUi){
    progressBar.style.width = `${(n/total)*100}%`;
  }

  // Micro-hint: solo prima visita Arcade, solo se multi e sulla 1Âª slide
  if (hintEl){
    const KEY = 'skullory.arcadeHintShown';
    const shouldShow = showUi && currentSlide === 0 && !localStorage.getItem(KEY);
    hintEl.hidden = !shouldShow;
    if (shouldShow){
      setTimeout(() => {
        hintEl.hidden = true;
        localStorage.setItem(KEY, '1');
      }, 3500);
    }
  }
}


  function showIntro(){
    intro.classList.remove('hide');
    intro.classList.add('show');
    if (slides.length === 0) buildTutorialRefs();
    setTutorialMode('root');
  }
  function hideIntro(){ intro.classList.add('hide'); intro.classList.remove('show'); }

  let state;
  let currentLevelIdx = 0;
  let totalScore = 0;
  let themeIndex = 1;
  let frameBaseScore = 0;
  let activeSaveName = localStorage.getItem('skullory_active_save') || '';

  function setActiveSaveName(name){
    activeSaveName = name || '';
    try {
      if (activeSaveName) localStorage.setItem('skullory_active_save', activeSaveName);
      else localStorage.removeItem('skullory_active_save');
    } catch(_) {}
  }

  function refreshAudioButtons(){
    // NUOVO: bottone unico ciclico
    if (typeof getAudioMode === 'function' && audioBtn){
      const mode = getAudioMode(); // 0=tutto ON, 1=solo SFX, 2=tutto OFF

      if (mode === 0){
        audioBtn.textContent = 'ğŸµ';
        audioBtn.title = 'Audio: musica + effetti';
        audioBtn.setAttribute('aria-label','Audio: musica + effetti');
      } else if (mode === 1){
        audioBtn.textContent = 'ğŸ”Š';
        audioBtn.title = 'Audio: solo effetti (musica OFF)';
        audioBtn.setAttribute('aria-label','Audio: solo effetti (musica OFF)');
      } else {
        audioBtn.textContent = 'ğŸ”‡';
        audioBtn.title = 'Audio: spento';
        audioBtn.setAttribute('aria-label','Audio: spento');
      }
    }
  }

  let pendingCheck = null;
  let tapBuffer = [];
  const TAP_BUFFER_MAX = 2;
  let progress = LEVELS.map(L => ({
    streak: 0,
    unlocked: false,
    baseTimeMs: L.unlockMs[0],
    postUnlockWins: 0,
    carryBonusMs: 0
  }));

  function setCols(n){ document.documentElement.style.setProperty('--cols', n); }
  function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } return a; }
  function fmt(ms){ const s = Math.max(0, Math.floor(ms/1000)); const mm = Math.floor(s/60), ss = s%60; return `${mm}:${ss.toString().padStart(2,'0')}`; }
  function calcElapsedMs(){
    const now = performance.now();
    return Math.max(0, now - (state.frameStartTs || now));
  }
  function calcZenEfficiency(moves, level){
    const free = freeMovesFor(level);
    if (moves <= free) return 100;
    const over = moves - free;
    return Math.max(50, Math.round(100 - over));
  }
// Da % efficienza a numero stelle (1..5)
function effToStars(eff){
  // Soglie consigliate (tienile pure come vuoi):
  // 96â€“100 => 5 â­, 90â€“95 => 4 â­, 80â€“89 => 3 â­, 70â€“79 => 2 â­, <70 => 1 â­
  if (eff >= 96) return 5;
  if (eff >= 90) return 4;
  if (eff >= 80) return 3;
  if (eff >= 70) return 2;
  return 1;
}

// Etichetta testuale carina per il rating
function starsLabel(n){
  return (
    n === 5 ? 'Eccellente! (5/5)' :
    n === 4 ? 'Ottimo! (4/5)' :
    n === 3 ? 'Buono! (3/5)' :
    n === 2 ? 'Discreto (2/5)' :
              'Da ritentare (1/5)'
  );
}
// === Zen: calcolo stelle su 5 con mezze stelle (0.5 step) ===
function computeZenStars(moves, elapsedMs, level){
  const pairs = level.pairs;

  // --- Punteggio MOSSE (piÃ¹ pesante)
  // Perfetto = pairs; "buono" ~2.5Ã—; "ok" ~4Ã— (tarabile)
  const M_best = pairs;
  const M_good = Math.round(pairs * 2.5);
  const M_ok   = Math.round(pairs * 4.0);

  let mScore; // [0..1]
  if (moves <= M_best) mScore = 1;
  else if (moves >= M_ok) mScore = 0;
  else if (moves <= M_good){
    // Degrada da 1 â†’ 0.5
    mScore = 1 - (moves - M_best) / (M_good - M_best) * 0.5;
  } else {
    // Degrada da 0.5 â†’ 0
    mScore = 0.5 - (moves - M_good) / (M_ok - M_good) * 0.5;
  }

  // --- Punteggio TEMPO (piÃ¹ leggero)
  // Scala col numero di coppie: ~6s ottimo, 10s buono, 16s ok per coppia
  const T_best = pairs * 6 * 1000;
  const T_good = pairs * 10 * 1000;
  const T_ok   = pairs * 16 * 1000;

  let tScore; // [0..1]
  if (elapsedMs <= T_best) tScore = 1;
  else if (elapsedMs >= T_ok) tScore = 0;
  else if (elapsedMs <= T_good){
    tScore = 1 - (elapsedMs - T_best) / (T_good - T_best) * 0.5;
  } else {
    tScore = 0.5 - (elapsedMs - T_good) / (T_ok - T_good) * 0.5;
  }

  // Combina: mosse contano di piÃ¹ (70/30)
  const combined = Math.max(0, Math.min(1, 0.7*mScore + 0.3*tScore));

  // Mappa a 1..5 stelle, poi arrotonda a mezze stelle
  const rawStars = 1 + 4*combined;
  const starsHalf = Math.round(rawStars * 2) / 2;
  return starsHalf;
}

// Format tipo "â­3.5"
function fmtStars(n){
  return 'â­' + (Number.isInteger(n) ? n.toFixed(0) : n.toFixed(1));
}

  function markFrameStart(){ state.frameStartTs = performance.now(); }

  function rotateTheme(){
    themeIndex = themeIndex % 10 + 1;
    const b = document.body;
    b.className = (b.className || '').replace(/\btheme-\d+\b/g, '').trim();
    b.classList.add('theme-' + themeIndex);
  }

  function updateStatusChip(){
    const p = progress[currentLevelIdx];
    const extra = !p.unlocked ? (p.carryBonusMs || 0) : 0;
    const baseSec = Math.max(0, p.baseTimeMs + extra) / 1000 | 0;
    if(!p.unlocked){
      statusChip.textContent = `Sbloc ${p.streak}/3 Â· ${baseSec}s`;
    } else {
      statusChip.textContent = `Grind ${p.postUnlockWins} Â· ${baseSec}s`;
    }
  }

  function buildDeck(level){
    const pool = EMOJI.slice();
    const unique = shuffle(pool).slice(0, level.pairs);
    const pairs = unique.concat(unique);
    const specials = [ ...Array(level.red).fill(RED), ...Array(level.yellow).fill(YELLOW) ];
    const deck = pairs.concat(specials);
    return shuffle(deck);
  }
  function getActiveCards(){
    return Array.from(grid.querySelectorAll('.card'))
      .filter(c => !c.classList.contains('placeholder'));
  }
  function getCardByIndex(idx){ return grid.querySelector(`.card[data-index="${idx}"]`); }

  // --- MOSSE & PUNTEGGIO ---
  function freeMovesFor(level){ return level.side * level.side; }
  function efficiencyMultiplier(moves, free){
    const delta = moves - free;
    if (delta <= 0){
      const bonus = Math.min(0.30, 0.02 * (-delta));
      return 1 + bonus;
    } else {
      return Math.max(0.5, 1 - 0.05 * delta);
    }
  }
  function roundNearest(n){ return Math.round(n); }
  function updateScoreChip(){ if(scoreChip) scoreChip.textContent = `Punti: ${totalScore}`; }

  function canSaveNow(){
  if (state?.isZen) return false; 
    const endOfFrame = overlay.classList.contains('show');
    const freshStart = !state.running && state.moves === 0 && state.matched === 0;
    return endOfFrame || freshStart;
  }
function updateSaveButton(){
  if (!saveBtn) return;

  if (state?.isZen){
    // In modalitÃ  Zen non si salva mai
    saveBtn.disabled = true;
    saveBtn.style.opacity = '0.6';
    saveBtn.title = 'In Zen non si salva';
    return;
  }

  const ok = canSaveNow();
  saveBtn.disabled = !ok;
  saveBtn.style.opacity = ok ? '1' : '0.6';
  saveBtn.title = ok ? 'Salva' : 'Salva disponibile solo a fine quadro o prima di iniziare';
}

function isPreFrame(){
  return !!state && !state.running && state.moves === 0 && state.matched === 0;
}

  function anyOverlayOpen(){
    return overlay.classList.contains('show')
        || restartConfirm.classList.contains('show')
        || saveModal.classList.contains('show')
        || (intro && !intro.classList.contains('hide'));
  }

  function canUsePowersBase(){
    if (state?.isZen) return false;
    return !!state
        && state.running
        && !state.paused
        && !state.lock
        && !anyOverlayOpen()
        && !(sim && sim.active)
        && !document.body.classList.contains('mode-simon');
  }

  function addTimeMs(ms){
    if (state?.isZen) return;
    const now = performance.now();
    state.deadlineTs += ms;
    state.leftMs = Math.max(0, state.deadlineTs - now);
    updateTime();
  }
  function takeTimeMs(ms){ addTimeMs(-Math.max(0, ms)); }

  function refreshPowersUI(){
    if (!powerRevealBtn || !powerPlus10Btn || !powerShiftBtn) return;

    if (state?.isZen){
      [powerRevealBtn, powerPlus10Btn, powerShiftBtn].forEach(b => {
        if (!b) return;
        b.classList.remove('ready');
        b.setAttribute('aria-disabled','true');
      });
      return;
    }

    const base = canUsePowersBase();
    const haveOnePair = state.matched >= 1;
    const skullSeen = state.redFlips >= 1;

    const revealCost = Math.max(4000, Math.floor(state.leftMs * 0.20));
    const safeAfterReveal = (state.leftMs - revealCost) >= 3000;

    const canReveal = base && !state.powerUsed.reveal && haveOnePair && safeAfterReveal;
    const canPlus10 = base && !state.powerUsed.plus10 && haveOnePair;
    const canShift  = base && !state.powerUsed.shift  && skullSeen;

    setPowerState(powerRevealBtn, canReveal);
    setPowerState(powerPlus10Btn, canPlus10);
    setPowerState(powerShiftBtn,  canShift);
  }
  function setPowerState(btn, enabled){
    btn.classList.toggle('ready', !!enabled);
    btn.setAttribute('aria-disabled', String(!enabled));
  }

  function getHiddenNonSpecialCards(){
    return getActiveCards().filter(c =>
      c.getAttribute('data-state') === 'hidden' &&
      c.dataset.symbol !== RED && c.dataset.symbol !== YELLOW
    );
  }
  function getMatchedPairs(){
    const map = new Map();
    getActiveCards().forEach(c => {
      if (c.getAttribute('data-state') === 'matched'){
        const s = c.dataset.symbol;
        if (s === RED || s === YELLOW) return;
        if (!map.has(s)) map.set(s, []);
        map.get(s).push(c);
      }
    });
    return Array.from(map.entries()).filter(([_, arr]) => arr.length === 2);
  }
function chaosSkullPenalty(card){
  try { SFX.play?.('skull', { volume:.95, rate:.98 }); } catch(_) {}

  // âœ… CHIUDI EVENTUALE PIVOT RIVELATO
  const pivot = state?.pivot;
  if (isValidPivotEl(pivot)) {
    scheduleHide(pivot, MISMATCH_HOLD_MS);
  }
  state.pivot = null;

  const pairs = getMatchedPairs(); // [[symbol,[card1,card2]], ...]
  if (pairs.length){
    const [, cards] = pairs[(Math.random()*pairs.length)|0];
    cards.forEach(c => c.setAttribute('data-state','hidden'));
    state.matched = Math.max(0, state.matched - 1);
    flashMessage('ğŸ’€ âˆ’1 coppia â€¢ ğŸ”€');
  } else {
    flashMessage('ğŸ”€ Chaos!');
  }

  reshuffleHiddenNonSpecial();
  scheduleHide(card, MISMATCH_HOLD_MS); // richiudi il teschio
  // state.pivot rimane null
}
function isSpecialSymbol(sym){ return sym === RED || sym === YELLOW; }
function isValidPivotEl(el){
  return !!(el
    && el.isConnected
    && !el.classList.contains('placeholder') // niente buchi/placeholder
    && el.getAttribute('data-state') === 'revealed'
    && !isSpecialSymbol(el.dataset.symbol)   // niente âš¡/ğŸ’€ come pivot
  );
}

  function usePowerReveal(){
    const baseOk = canUsePowersBase();
    if (!baseOk || state.powerUsed.reveal || state.matched < 1){
      if (isPreFrame()) explainPower('reveal');
      return;
    }

    const cost = Math.max(4000, Math.floor(state.leftMs * 0.20));
    if ((state.leftMs - cost) < 3000) { refreshPowersUI(); return; }

    ensureSfx();
    state.powerUsed.reveal = true;
    takeTimeMs(cost);
    flashMessage(`ğŸ‘ï¸ Svela tutto (âˆ’${Math.ceil(cost/1000)}s)`);
    SFX.play?.('flip', { volume:.85 });

    const cards = getActiveCards();
    const prev = new Map(cards.map(c => [c, c.getAttribute('data-state')]));

    const prevLock = state.lock;
    state.lock = true;

    cards.forEach(c => c.setAttribute('data-state', 'revealed'));

    setTimeout(() => {
      cards.forEach(c => c.setAttribute('data-state', prev.get(c)));
      state.lock = prevLock;
      if (tapBuffer.length){
        const next = tapBuffer.shift();
        setTimeout(() => onCardClick(next), 0);
      }
      refreshPowersUI();
    }, 1000);
  }

  function usePowerPlus10(){
    const baseOk = canUsePowersBase();
    if (!baseOk || state.powerUsed.plus10 || state.matched < 1){
      if (isPreFrame()) explainPower('plus10');
      return;
    }

    const pairs = getMatchedPairs();
    if (!pairs.length){ refreshPowersUI(); return; }

    ensureSfx();
    state.powerUsed.plus10 = true;

    const [symSac, cardsSac] = pairs[(Math.random() * pairs.length) | 0];

    const pool = getHiddenNonSpecialCards();
    shuffle(pool);

    cardsSac.forEach(c => c.setAttribute('data-state','hidden'));
    state.matched = Math.max(0, state.matched - 1);

    if (pool.length >= 2){
      const t1 = pool[0], t2 = pool[1];
      const t1Sym = t1.dataset.symbol, t2Sym = t2.dataset.symbol;

      t1.dataset.symbol = symSac; t1.querySelector('.symbol').textContent = symSac;
      t2.dataset.symbol = symSac; t2.querySelector('.symbol').textContent = symSac;

      cardsSac[0].dataset.symbol = t1Sym; cardsSac[0].querySelector('.symbol').textContent = t1Sym;
      cardsSac[1].dataset.symbol = t2Sym; cardsSac[1].querySelector('.symbol').textContent = t2Sym;
    }
    addTimeMs(10000);
    flashMessage('+10s â€¢ Coppia annullata');
    SFX.play?.('bonus5', { volume:1.0 });

    refreshPowersUI();
  }

  function usePowerShift(){
    const baseOk = canUsePowersBase();
    if (!baseOk || state.powerUsed.shift || state.redFlips < 1){
      if (isPreFrame()) explainPower('shift');
      return;
    }

    ensureSfx();
    state.powerUsed.shift = true;

    const specials = getActiveCards().filter(c => c.dataset.symbol === RED || c.dataset.symbol === YELLOW);
    let pool = getHiddenNonSpecialCards();
    shuffle(pool);

    for (let i=0; i<specials.length && i<pool.length; i++){
      const s = specials[i];
      const t = pool[i];

      const tSym = t.dataset.symbol;
      const sSym = s.dataset.symbol;

      t.dataset.symbol = sSym; t.querySelector('.symbol').textContent = sSym;
      s.dataset.symbol = tSym; s.querySelector('.symbol').textContent = tSym;
    }

    reshuffleHiddenNonSpecial();

    state.redFlips = 0;

    addTimeMs(15000);
    flashMessage('ğŸŒ€ Speciali spostate â€¢ +15s');
    SFX.play?.('reshuffle', { volume:.9 });

    refreshPowersUI();
  }

  function startArcade(){ init(currentLevelIdx || 0); }

function startZen(variant = 'zen'){
  zenVariant = (variant === 'chaos') ? 'chaos' : 'zen';
  const idx5base = LEVELS.findIndex(L => L.side === 5 && (!L.disabled || L.disabled.length === 0));
  const idx5any  = LEVELS.findIndex(L => L.side === 5);
  const target   = (idx5base >= 0) ? idx5base : (idx5any >= 0 ? idx5any : 0);
  init(target);
}
function startDailyChaos(){
  // Daily = Zen 'chaos' + deck deterministica del giorno
  zenVariant = 'chaos';
  modeZen = true;

  const daily = getDailyChallenge();
  hideIntro();
  init(daily.level, {
    deckOverride: daily.deck,
    dailyMeta: { id: daily.id, date: daily.date }
  });
}

function init(levelIdx = currentLevelIdx, opts = {}){
  rotateTheme();

  const L = LEVELS[levelIdx];
  currentLevelIdx = levelIdx;
  setCols(L.side);
  levelChip.textContent = `Livello: ${levelIdx+1}/${LEVELS.length}`;
  updateStatusChip();

  if (pendingCheck) { clearTimeout(pendingCheck); pendingCheck = null; }
  state = {
    level: L,
    deck: opts.deckOverride || buildDeck(L), // usa la deck della daily se passata
    pivot: null, matched: 0, moves: 0,
    hideTimers: new Map(),
    running: false, startTs: 0,
    leftMs: Math.max(0, progress[levelIdx].baseTimeMs + (!progress[levelIdx].unlocked ? (progress[levelIdx].carryBonusMs || 0) : 0)),
    lock: false,
    redFlips: 0, yellowFlips: 0,
    paused: false, streak: 0, lastMatchTime: 0, totalBonusMs: 0,
    deadlineTs: 0,
    pauseLeftMs: 0,
    powerUsed: { reveal:false, plus10:false, shift:false },
    holesEls: [],
    yellowReveals: new WeakMap(),
    preAppliedBonusMs: 0,
    startBonusMs: 0,
    // flag/metadati daily:
    isDaily: !!opts.dailyMeta,
    dailyMeta: opts.dailyMeta || null
  };

  // === UI: nascondi chip e poteri in Zen + CENTRA i 5 bottoni ===
  if (modeZen) {
    if (levelChip)  levelChip.style.display  = 'none';
    if (statusChip) statusChip.style.display = 'none';
    if (scoreChip)  scoreChip.style.display  = 'none';
    if (movesEl)    movesEl.style.display    = 'none';
    if (timerEl)    timerEl.style.display    = 'none';

    const cr = document.querySelector('.controls-right');
    if (cr) cr.style.display = 'none';

    const cb = document.querySelector('.controls-bottom');
    const cl = document.querySelector('.controls-left');
    if (cb) cb.style.justifyContent = 'center';
    if (cl) cl.style.margin = '0 auto';
    if (saveBtn) saveBtn.style.display = 'none';
  } else {
    if (levelChip)  levelChip.style.display  = '';
    if (statusChip) statusChip.style.display = '';
    if (scoreChip)  scoreChip.style.display  = '';
    if (movesEl)    movesEl.style.display    = '';
    if (timerEl)    timerEl.style.display    = '';

    const cr = document.querySelector('.controls-right');
    if (cr) cr.style.display = '';

    const cb = document.querySelector('.controls-bottom');
    const cl = document.querySelector('.controls-left');
    if (cb) cb.style.justifyContent = 'space-between';
    if (cl) cl.style.margin = '';
    if (saveBtn) saveBtn.style.display = '';
  }

  if (modeZen){
    if (timerEl){
      timerEl.textContent = 'â€”';
      timerEl.style.opacity = .65;
    }
    state.isZen = true;
    state.isChaos = (zenVariant === 'chaos');
  } else {
    state.isZen = false;
    state.isChaos = false;
  }

  updateSaveButton?.();
  refreshPowersUI?.();
  markFrameStart?.();

  // === costruzione griglia ===
  grid.innerHTML = '';
  const frag = document.createDocumentFragment();

  const disabled = new Set((L.disabled || []).map(Number));
  let deckPtr = 0;

  for (let i = 0; i < L.side * L.side; i++){
    if (disabled.has(i)){
      const placeholder = document.createElement('div');
      placeholder.className = 'card placeholder';
      placeholder.setAttribute('aria-hidden','true');
      frag.appendChild(placeholder);
      continue;
    }

    const symbol = state.deck[deckPtr++];
    const card = document.createElement('div');
    card.className = 'card';
    card.dataset.index = i;
    card.dataset.symbol = symbol;
    card.setAttribute('data-state','hidden');
    card.setAttribute('role','button');
    card.setAttribute('tabindex','0');
    card.setAttribute('aria-label','Carta di Slapmory');

    const inner = document.createElement('div'); inner.className = 'inner';
    const back  = document.createElement('div'); back.className  = 'face back';
    const front = document.createElement('div'); front.className = 'face front';
    const sym   = document.createElement('div'); sym.className   = 'symbol'; sym.textContent = symbol;
    front.appendChild(sym); inner.append(back, front); card.append(inner);

    card.addEventListener('click', () => onCardClick(card));
    card.addEventListener('keydown', (ev) => { if(ev.key==='Enter'||ev.key===' '){ ev.preventDefault(); onCardClick(card); } });

    frag.appendChild(card);
  }

  grid.appendChild(frag);
  tapBuffer = [];
  updateHud();
  updateScoreChip();
  hideOverlay();
  updateSaveButton();
  refreshPowersUI();
}

  function startTimer(){
    if(state.paused) return;
    if(state.running) return;

    if (state.isZen){
      state.running = true;
      frameBaseScore = totalScore;
      updateSaveButton();
      return;
    }

    state.running = true;
    frameBaseScore = totalScore;
    const now = performance.now();
    state.startTs = now;

    const p = progress[currentLevelIdx];
    const carry = !p.unlocked ? (p.carryBonusMs || 0) : 0;
    const base = Math.max(0, p.baseTimeMs + carry);

    state.deadlineTs = now + base;
    tick();
    updateSaveButton();
  }

  function tick(){
    if (state?.isZen) return;
    if(!state.running || state.paused) return;
    const now = performance.now();
    state.leftMs = Math.max(0, state.deadlineTs - now);
    updateTime();
    if(state.leftMs<=0){ state.running=false; lose('Tempo scaduto â°'); return; }
    requestAnimationFrame(tick);
  }

  function updateTime() {
    if (state?.isZen) return;
    timerEl.textContent = fmt(state.leftMs);
  }

  function updateHud(){
    if (!state?.isZen){
      movesEl.textContent = `Mosse: ${state.moves}`;
      timerEl.textContent = fmt(state.leftMs);
    }
    updateStatusChip();
    updateScoreChip();
  }

function onCardClick(card){
  ensureSfx();

  // SIMON attivo â†’ comportamento invariato
  if (sim && sim.active){
    simonOnTap(card);
    return;
  }

  SFX.play('tap', { volume:.5, rate: 0.98 + Math.random()*0.04 });

  // Pausa / lock (da overlay o potere ğŸ‘ï¸) â†’ comportamento invariato
  if (state.paused) { flashMessage('In pausa â–¶'); return; }
  if (state.lock) {
    if (tapBuffer.length < TAP_BUFFER_MAX &&
        card.dataset.state !== 'matched' &&
        card.dataset.state !== 'revealed') {
      tapBuffer.push(card);
    }
    return;
  }

  // Niente re-click su carte giÃ  visibili / giÃ  abbinate
  if (card.dataset.state === 'matched' || card.dataset.state === 'revealed') return;

  startTimer();
  flip(card, true);

  // Gestione speciali come prima (aggiuntiva, NON interrompe il confronto)
// salva il pivot corrente per poterlo richiudere se tocco una speciale
const pivotBefore = state.pivot;

// ğŸ’€ SKULL
if (card.dataset.symbol === RED){
  if (state.isChaos){
    // in Chaos giÃ  richiudi dentro chaosSkullPenalty()
    chaosSkullPenalty(card);
    return;
  }

  state.redFlips++;
  refreshPowersUI();
  try { SFX.play('skull', { volume:.9, rate:.98 }); } catch(_) {}

  // se avevo una carta normale scoperta come pivot, richiudila
  if (isValidPivotEl(pivotBefore)) scheduleHide(pivotBefore, MISMATCH_HOLD_MS);
  state.pivot = null;

  if (state.redFlips >= 2){
    setTimeout(() => {
      if (state.isZen) showZenSkullLose();
      else lose('Oh no! ğŸ’€', 'Hai rivelato il teschio due volte.');
    }, 220);
    return;
  }

  // richiudi il teschio dopo il feedback, cosÃ¬ puÃ² essere rivelato di nuovo
  scheduleHide(card, MISMATCH_HOLD_MS);
  return;
}

// âš¡ LIGHTNING
if (card.dataset.symbol === YELLOW){
  state.yellowFlips++;
  flashMessage('Shuffle!');
  reshuffleHiddenNonSpecial();

  // se avevo una carta normale scoperta come pivot, richiudila
  if (isValidPivotEl(pivotBefore)) scheduleHide(pivotBefore, MISMATCH_HOLD_MS);
  state.pivot = null;

  if (state.isChaos){
    const prevCnt = state.yellowReveals.get(card) || 0;
    const nowCnt  = prevCnt + 1;
    state.yellowReveals.set(card, nowCnt);

    // al 2Â° reveal il fulmine diventa buco e la carta viene rimpiazzata
    if (nowCnt >= 2 && (state.holesEls?.length || 0) < 2){
      makeHole(card);
      return;
    }
    // altrimenti richiudi il âš¡ per poterlo rivelare di nuovo
    scheduleHide(card, MISMATCH_HOLD_MS);
    return;
  }

  // non-Chaos: richiudi sempre il âš¡ dopo il feedback
  scheduleHide(card, MISMATCH_HOLD_MS);
  return;
}



  // --- Confronto "pivot â†’ nuova carta" (mosse per confronto, non per primo flip isolato) ---
let prev = state.pivot;

// Invalida pivot non piÃ¹ utilizzabile (disconnesso/placeholder/speciale/matched)
if (!isValidPivotEl(prev) || prev?.getAttribute('data-state') === 'matched'){
  prev = null;
  state.pivot = null;
}

// Se non c'Ã¨ un pivot valido, questa carta puÃ² diventarlo (solo carte â€œnormaliâ€ rivelate)
if (!prev){
  if (!card.isConnected || card.classList.contains('placeholder')) return;
  if (isSpecialSymbol(card.dataset.symbol)) return; // niente pivot su âš¡/ğŸ’€
  state.pivot = card;
  return;
}


  // Qui c'Ã¨ un confronto: conta 1 mossa
  state.moves++;
  if (!state.isZen) movesEl.textContent = `Mosse: ${state.moves}`;

  const aSym = prev.dataset.symbol;
  const bSym = card.dataset.symbol;
  const isSpecial = s => (s === RED || s === YELLOW);
  const isMatch = !isSpecial(aSym) && !isSpecial(bSym) && (aSym === bSym);

  if (isMatch){
    // Annulla eventuali richiuse pendenti sul pivot
    cancelHide(prev);
    cancelHide(card);

    // Bonus tempo & combo come prima
    const now = performance.now();
    if (!state.isZen){
      state.deadlineTs += 1000;            // +1s
      state.leftMs = Math.max(0, state.deadlineTs - now);
      updateTime();
      flashMessage('+1s');
      SFX.play('bonus1', { volume:.85, rate: 1.02 });

      if (state.streak >= 1 && (now - state.lastMatchTime) < 5000){
        state.deadlineTs += 5000;          // +5s combo
        state.leftMs = Math.max(0, state.deadlineTs - performance.now());
        updateTime();
        flashMessage('+5s Bonus!');
        SFX.play('bonus5', { volume:1 });
      }
      state.lastMatchTime = now;
    }

    // Marca la coppia
    prev.setAttribute('data-state','matched');
    card.setAttribute('data-state','matched');
    spawnMatchStars(prev);
    spawnMatchStars(card);
    SFX.play('ok', { volume:.9, rate: 0.98 });
// SOLO CHAOS: dopo lâ€™animazione âœ¨ prova una catena di shift
if (state.isChaos && state.matched < state.level.pairs){
  setTimeout(() => zenShiftOnce(), 620);
}


    state.matched++;
    state.streak++;
    refreshPowersUI();

    // Fine quadro?
    if(state.matched >= state.level.pairs){
      win();
      return;
    }

    // Dopo un match non c'Ã¨ pivot
    state.pivot = null;
    return;
  }

  // --- Mismatch: nessun blocco input, ma programmo la richiusa di entrambe ---
  state.streak = 0;
  if (!state.isZen){
    const now = performance.now();
    state.deadlineTs = state.deadlineTs - 1000; // -1s
    state.leftMs = Math.max(0, state.deadlineTs - now);
    updateTime();
    flashMessage('-1s');
    SFX.play('fail', { volume:.9 });
  }

  // Le due carte restano visibili per la solita finestra, poi si richiudono
  scheduleHidePair(prev, card);

  // Il nuovo pivot diventa l'ultima carta girata (cosÃ¬ puoi matchare al terzo flip)
// Se la carta Ã¨ diventata un buco (âš¡ al 2Â° reveal) o Ã¨ stata rimossa, niente pivot
state.pivot = (card
  && card.isConnected
  && !card.classList.contains('placeholder')
  && !isSpecialSymbol(card.dataset.symbol)
) ? card : null;


}

  function flip(card, reveal){ card.setAttribute('data-state', reveal ? 'revealed' : 'hidden'); }
function cancelHide(card){
  const t = state.hideTimers?.get(card);
  if (t){ clearTimeout(t); state.hideTimers.delete(card); }
}

function scheduleHide(card, ms){
  cancelHide(card);
  const t = setTimeout(() => {
    if (card.getAttribute('data-state') !== 'matched' &&
        card.getAttribute('data-state') === 'revealed'){
      flip(card, false);
    }
    state.hideTimers?.delete(card);
  }, ms);
  state.hideTimers?.set(card, t);
}

function scheduleHidePair(a, b){
  scheduleHide(a, MISMATCH_HOLD_MS);
  scheduleHide(b, MISMATCH_HOLD_MS);
}


  function reshuffleHiddenNonSpecial(){
    const cards = Array.from(grid.querySelectorAll('.card'));
    const targets = cards.filter(c => c.getAttribute('data-state') === 'hidden' && c.dataset.symbol !== 'ğŸ’€' && c.dataset.symbol !== 'âš¡');
    if(targets.length <= 1) return;
    const symbols = targets.map(c => c.dataset.symbol);
    for(let i=symbols.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [symbols[i],symbols[j]]=[symbols[j],symbols[i]]; }
    targets.forEach((c,i) => {
      c.dataset.symbol = symbols[i];
      c.querySelector('.symbol').textContent = symbols[i];
    });
    flashMessage('ğŸ”€ Rimescolo!');
    SFX.play('reshuffle', { volume:.9 });
  }
// --- utils ---
function randInt(a,b){ return (Math.random()*(b-a+1)|0) + a; }
function swapNodes(a,b){
  const aNext = a.nextSibling, bNext = b.nextSibling, parent = a.parentNode;
  if (!parent || !b.parentNode) return;
  if (aNext === b) parent.insertBefore(b, a);
  else if (bNext === a) parent.insertBefore(a, b);
  else {
    parent.insertBefore(a, bNext);
    parent.insertBefore(b, aNext);
  }
}
function isCoveredCard(el){
  return el && el.classList.contains('card') &&
         !el.classList.contains('placeholder') &&
         el.getAttribute('data-state') === 'hidden';
}
function getNeighbors(idx, side){
  const res = [];
  const r = Math.floor(idx/side), c = idx%side;
  // su
  if (r>0) res.push(idx - side);
  // giÃ¹
  if (r<side-1) res.push(idx + side);
  // sin
  if (c>0) res.push(idx - 1);
  // des
  if (c<side-1) res.push(idx + 1);
  return res;
}

// Crea un buco nella cella di 'card' (âš¡ rivelato 2 volte) â€” SOLO ZEN
function makeHole(card){
if (!state?.isChaos) return;
  if (!card || !card.classList.contains('card') || card.classList.contains('placeholder')) return;
  if ((state.holesEls?.length || 0) >= 2) return;

  const idx = +card.dataset.index;
  // mini pop/dissolve
  card.classList.add('pop-out');

  // cancella hide timer e pivot se puntava a questa carta
  try { cancelHide(card); } catch(_) {}
  if (state.pivot === card) state.pivot = null;

  // crea placeholder.hole con lo stesso data-index
  const hole = document.createElement('div');
  hole.className = 'card placeholder hole';
  hole.dataset.index = String(idx);
  hole.setAttribute('aria-hidden','true');

  // sostituisci nel DOM
  grid.replaceChild(hole, card);

  // registra
  state.holesEls = state.holesEls || [];
  state.holesEls.push(hole);
}

// Trova carte coperte adiacenti al buco (no diagonali, no placeholder/matched/rivelate)
function candidatesAroundHole(holeEl){
  const side = state.level.side;
  const idx = +holeEl.dataset.index;
  const neigh = getNeighbors(idx, side);
  const out = [];
  for (const n of neigh){
    const el = grid.querySelector(`.card[data-index="${n}"]`);
    if (isCoveredCard(el)) out.push(el);
  }
  return out;
}

// Sposta 1 carta coperta adiacente dentro al buco scelto (animazione FLIP)
// Sposta 1 carta coperta adiacente dentro al buco scelto (animazione FLIP) â€” Promise
function slideCardIntoHole(cardEl, holeEl){
  return new Promise((resolve) => {
    const dur = randInt(HOLE_SHIFT_MS_MIN, HOLE_SHIFT_MS_MAX);
    const from = cardEl.getBoundingClientRect();
    const to   = holeEl.getBoundingClientRect();
    const idxCard = +cardEl.dataset.index;
    const idxHole = +holeEl.dataset.index;

    // swap in DOM
    swapNodes(cardEl, holeEl);

    // aggiorna gli indici (la carta prende l'indice del buco, e viceversa)
    cardEl.dataset.index = String(idxHole);
    holeEl.dataset.index = String(idxCard);

    // FLIP: trasla la carta dalla vecchia posizione alla nuova
    const dx = from.left - to.left;
    const dy = from.top  - to.top;

    cardEl.style.transform = `translate(${dx}px, ${dy}px)`;
    cardEl.style.transition = 'transform 0ms';
    // reflow
    cardEl.getBoundingClientRect();

    requestAnimationFrame(() => {
      cardEl.style.transition = `transform ${dur}ms cubic-bezier(.2,.7,.1,1)`;
      cardEl.style.transform = 'translate(0,0)';
      const cleanup = () => {
        cardEl.style.transition = '';
        cardEl.style.transform = '';
        cardEl.removeEventListener('transitionend', cleanup);
        resolve();
      };
      cardEl.addEventListener('transitionend', cleanup);
    });
  });
}


// Dopo ogni coppia (solo Zen): attiva al massimo uno shift
// Dopo ogni coppia (solo Zen): una *catena* di 1..4 scivolamenti dal buco scelto
async function zenShiftOnce(){
if (!state?.isChaos) return;
  const holes = (state.holesEls || []).filter(Boolean);
  if (!holes.length) return;

  // raccogli i buchi che hanno candidate
  const withCands = holes
    .map(h => [h, candidatesAroundHole(h)])
    .filter(([_, arr]) => arr.length > 0);

  if (withCands.length === 0){
    // feedback "bloccato"
    holes.forEach(h => {
      h.classList.add('hole-shake');
      setTimeout(() => h.classList.remove('hole-shake'), 200);
    });
    return;
  }

  // se ce n'Ã¨ piÃ¹ di uno, scegli a caso il buco
  const [holeEl] = withCands[(Math.random()*withCands.length)|0];

  // telegraph breve (una volta sola)
  holeEl.classList.add('hole-blink');
  setTimeout(() => holeEl.classList.remove('hole-blink'), 120);

  // lunghezza massima catena: N in {1,2,3,4}
  const maxSteps = (Math.random()*4 | 0) + 1;

  let steps = 0;
  let lastCardIdx = null; // anti-rimbalzo: evita la carta appena mossa

  while (steps < maxSteps){
    // aggiorna candidate attorno al buco corrente, evitando subito il backtracking
    let candidates = candidatesAroundHole(holeEl)
      .filter(el => +el.dataset.index !== lastCardIdx);

    if (candidates.length === 0){
      // stop anticipato, feedback "bloccato"
      holeEl.classList.add('hole-shake');
      setTimeout(() => holeEl.classList.remove('hole-shake'), 200);
      break;
    }

    // scegli una carta coperta adiacente a caso
    const cardEl = candidates[(Math.random()*candidates.length)|0];

    // SFX per lo scivolamento
    try { SFX.play?.('flip', { volume: .65 }); } catch(_) {}

    // salva l'indice dell'attuale posizione del buco: servirÃ  per evitare backtracking
    const prevHoleIdx = +holeEl.dataset.index;

    // esegui lo scivolamento (attende la fine dell'animazione)
    await slideCardIntoHole(cardEl, holeEl);

    // anti-backtracking: non tornare subito indietro
    lastCardIdx = prevHoleIdx;

    steps++;
  }
}


  function startSimonIntermezzo(){
    ensureSfx();
    document.body.classList.add('mode-simon');
    refreshPowersUI();

    document.body.classList.add('no-flip');
    getActiveCards().forEach(c => c.setAttribute('data-state', 'hidden'));

    requestAnimationFrame(() => {
      document.body.classList.remove('no-flip');

      const activeIdx = getActiveCards().map(c => +c.dataset.index);
      const order = shuffle(activeIdx.slice());
      const maxLen   = order.length;
      const startLen = Math.min(SIMON_CFG.startLen, maxLen);

      sim = { active: true, busy: false, order, round: startLen - 1, pos: 0, maxLen };

      if (pauseBtn) pauseBtn.disabled = true;
      flashMessage('ğŸ‘» Simon: ripeti la sequenza');
      simNextRound();
    });
  }

  function simNextRound(){
    if (!sim || !sim.active) return;
    if (sim.round >= sim.maxLen){
      endSimon(sim.round);
      return;
    }
    sim.round++;
    simShowSequence();
  }

  async function simShowSequence(){
    sim.pos = 0;
    sim.busy = true;

    await new Promise(r => setTimeout(r, 350));

    for (let i = 0; i < sim.round; i++){
      await simFlash(sim.order[i]);
      await new Promise(r => setTimeout(r, SIMON_CFG.gapMs));
    }

    sim.busy = false;
  }

  function simFlash(idx){
    return new Promise(res => {
      const card = getCardByIndex(idx);
      if (!card){ res(); return; }

      const ghost = document.createElement('div');
      ghost.className = 'simon-ghost';
      ghost.textContent = GHOST;
      ghost.style.animationDuration = SIMON_CFG.previewMs + 'ms';

      card.appendChild(ghost);

      SFX.play?.('tap', { volume:.6, rate: 1.05 });
      setTimeout(() => { ghost.remove(); res(); }, SIMON_CFG.previewMs);
    });
  }

  function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }

  async function simonRevealTemp(card, symbol, holdMs){
    const ghost = document.createElement('div');
    ghost.className = 'simon-ghost';
    ghost.style.animationDuration = holdMs + 'ms';
    ghost.textContent = symbol;

    card.appendChild(ghost);
    if (symbol === 'ğŸ’€') {
      SFX.play?.('skull', { volume:.95 });
    } else {
      SFX.play?.('flip', { volume:.75 });
    }

    await sleep(holdMs);
    ghost.remove();
  }
  async function simonRevealSkull(card, holdMs){ return simonRevealTemp(card, 'ğŸ’€', holdMs); }

  async function simonOnTap(card){
    if (!sim || !sim.active) return;
    if (sim.busy) return;

    const idx = +card.dataset.index;
    const expected = sim.order[sim.pos];

    if (idx !== expected){
      sim.busy = true;
      await simonRevealSkull(card, SIMON_CFG.wrongHoldMs);
      sim.busy = false;
      endSimon(Math.max(0, sim.round - 1));
      return;
    }

    sim.busy = true;
    sim.pos++;
    SFX.play?.('ok', { volume:.8 });
    await simonRevealTemp(card, GHOST, SIMON_CFG.inputRevealMs);
    sim.busy = false;

    if (sim.pos === sim.round){
      flashMessage('âœ“');
      setTimeout(() => simNextRound(), 350);
    }
  }

  function endSimon(completedLen){
    document.body.classList.remove('mode-simon');
    refreshPowersUI();

    const bonusSec = Math.max(0, Math.min(completedLen, sim?.maxLen || 0));
    sim.active = false;
    sim = null;

    if (pauseBtn) pauseBtn.disabled = false;

    const bonusMs = bonusSec * 1000;
    const next = currentLevelIdx + 1;

    if (next < LEVELS.length && !progress[next].unlocked) {
      progress[next].carryBonusMs = (progress[next].carryBonusMs || 0) + bonusMs;
    }

    const finalMsg = bonusSec > 0
      ? `Hai guadagnato <b>+${bonusSec}s</b> per il prossimo livello!`
      : 'Nessun bonus ottenuto.';

    showOverlay('Intermezzo Simon concluso', `${finalMsg}`);
    ovBtn.textContent = 'Vai al livello successivo';
    ovBtn.onclick = () => { hideOverlay(); init(next); };
  }

  function spawnMatchStars(card){
    const wrap = document.createElement('div');
    wrap.className = 'match-stars';
    card.appendChild(wrap);

    const N = 6;
    for(let i=0;i<N;i++){
      const s = document.createElement('span');
      s.className = 'star';
      s.textContent = 'âœ¨';
      const r = 26 + Math.random()*18;
      const ang = (Math.PI*2/N)*i + Math.random()*0.7;
      const dx = Math.cos(ang)*r;
      const dy = Math.sin(ang)*r;
      s.style.setProperty('--dx', `${dx}px`);
      s.style.setProperty('--dy', `${dy}px`);
      wrap.appendChild(s);
    }
    setTimeout(() => wrap.remove(), 650);
  }
// ===== Condivisione testuale Zen =====
function buildZenShareText(){
  const elapsedMs = state?.finalElapsedMs ?? calcElapsedMs();
  const moves = state?.moves || 0;
  const level = LEVELS[currentLevelIdx];
  const stars = computeZenStars(moves, elapsedMs, level);

  // articolo/etichetta della modalitÃ  nel testo condiviso
  const modeLabel = state?.isChaos ? 'la Chaos' : 'la Zen';
  // in alternativa, piÃ¹ neutro: const modeLabel = `la modalitÃ  ${state?.isChaos ? 'Chaos' : 'Zen'}`;

  return `Ho completato ${modeLabel} in Skullory con:
Mosse: ${moves}
Tempo: ${fmt(elapsedMs)}
Valutazione: ${fmtStars(stars)}/5

Prova a battermi!
${GAME_URL}`;
}



async function shareZen(){
  const text = buildZenShareText();
  try{
    if (navigator.share){
      await navigator.share({
        title: 'Skullory â€” Zen',
        text
        // âŒ niente 'url' qui: molti target (WhatsApp) ignorano 'text' se 'url' Ã¨ presente
      });
      return;
    }
  }catch(e){
    // utente ha annullato: ignora
  }

  // Fallback: copia negli appunti
  try{
    if (navigator.clipboard && window.isSecureContext){
      await navigator.clipboard.writeText(text);
      flashMessage('âœ… Copiato: incolla dove vuoi!');
      return;
    }
  }catch(_) {}

  // Ultimo fallback: mailto
  const mailto = `mailto:?subject=${encodeURIComponent('Il mio risultato Zen su Skullory')}&body=${encodeURIComponent(text)}`;
  window.location.href = mailto;
}

function showZenEnd(){
  // Congela il tempo al momento della vittoria
  state.finalElapsedMs = calcElapsedMs();
  const elapsedMs = state.finalElapsedMs;
  const moves = state.moves || 0;

  const level = LEVELS[currentLevelIdx];
  const stars = computeZenStars(moves, elapsedMs, level);

  ovTitle.textContent = 'Griglia completata!';

  // Header daily (se applicabile)
  let header = '';
  if (state.isDaily){
    const d = state.dailyMeta?.date || todayStr();
    header = `ğŸ—“ï¸ Sfida del Giorno <small>(${d})</small><br/>`;
  }

  // Ordine mostrato: mosse â†’ tempo â†’ stelle
  ovSub.innerHTML =
    `${header}` +
    `ğŸ¯ Mosse: <b>${moves}</b><br/>` +
    `â±ï¸ Tempo: <b>${fmt(elapsedMs)}</b><br/>` +
    `â­ Valutazione: <b>${fmtStars(stars)}/5</b>`;

  // Record della daily (locale)
  if (state.isDaily){
    const date = state.dailyMeta?.date || todayStr();
    const prev = readDailyRecord(date);
    const nowRec = { moves, timeMs: elapsedMs, stars, ts: Date.now() };
    const better = isRunBetter(nowRec, prev);

    if (better){
      writeDailyRecord(date, nowRec);
      ovSub.innerHTML += `<br/><br/>ğŸ† <b>Nuovo record giornaliero!</b>`;
      try { SFX.play?.('win', { volume: 0.9 }); } catch(_){}
    } else if (prev){
      let msg = 'Record invariato';
      if (moves > prev.moves){
        const need = moves - prev.moves;
        msg = `Record invariato (ti servono âˆ’${need} mosse)`;
      } else if (moves === prev.moves && elapsedMs > prev.timeMs){
        const need = fmtShortSecDiff(elapsedMs - prev.timeMs);
        msg = `Record invariato (ti servono âˆ’${need})`;
      } else if (moves === prev.moves && elapsedMs === prev.timeMs && stars < prev.stars){
        msg = `Record invariato (ti serve +â­)`;
      }
      ovSub.innerHTML += `<br/><br/>${msg}`;
    }
  }

  // Bottoni
  ovBtn.textContent = 'Gioca ancora';
  ovBtn.onclick = () => {
    hideOverlay();
    if (state.isDaily) {
      startDailyChaos(); // rigioca la stessa daily (stessa griglia del giorno)
    } else {
      startZen(state.isChaos ? 'chaos' : 'zen');
    }
  };

  showSkip(true);
  ovBtnSkip.textContent = 'Torna al menu';
  ovBtnSkip.onclick = () => { hideOverlay(); showIntro(); };

  // Pulsante Condividi
  const actions = document.querySelector('.ov-actions');
  if (actions) {
    document.getElementById('shareTextBtn')?.remove();
    const shareBtn = document.createElement('button');
    shareBtn.id = 'shareTextBtn';
    shareBtn.className = 'primary outline-btn';
    shareBtn.textContent = 'Condividi';
    shareBtn.onclick = () => shareZen();
    actions.appendChild(shareBtn);
  }

  overlay.classList.add('show');
  updateSaveButton();
}

  function win(){
    if (state?.isZen){ showZenEnd(); return; }
    state.running = false;
    SFX.play('win', { volume:1.0 });

    const secondsLeft = Math.floor(state.leftMs/1000);
    const free = freeMovesFor(state.level);
    const mult = efficiencyMultiplier(state.moves, free);
    const frameScore = roundNearest(secondsLeft * mult);
    totalScore = frameBaseScore + frameScore;
    updateScoreChip();

    const L = LEVELS[currentLevelIdx];
    const p = progress[currentLevelIdx];

    const detailRow = `Tempo: ${secondsLeft}s Â· Mosse: ${state.moves}<br>
Punti quadro = <b>${frameScore}</b><br>
Punteggio parziale: <b>${totalScore}</b>`;

    if(!p.unlocked){
      p.streak += 1;
      if(p.streak < 3){
        p.baseTimeMs = L.unlockMs[p.streak];
        showOverlay('Quadro completato âœ”ï¸', `Sblocco: ${p.streak}/3<br>${detailRow}<br><small>Prossimo tentativo: tempo base ${Math.floor(p.baseTimeMs/1000)}s</small>`);
        ovBtn.textContent = 'Continua a giocare';
        ovBtn.onclick = () => { hideOverlay(); init(currentLevelIdx); };
      } else {
        p.unlocked = true;
        p.postUnlockWins = 0;
        p.carryBonusMs = 0;

        const next = currentLevelIdx + 1;

        showOverlay(
          'Sblocco conquistato! ğŸ†',
          `Hai completato 3 quadri di fila.<br>
           ${detailRow}<br><br>
           <b>Cosa vuoi fare adesso?</b>`
        );

        ovBtn.textContent = 'Continua qui (fai punti)';
        ovBtn.onclick = () => {
          hideOverlay();
          init(currentLevelIdx);
        };

        if (next < LEVELS.length){
          showSkip(true);
          ovBtnSkip.textContent = 'Livello successivo';
          ovBtnSkip.onclick = () => { openSimonChoice(next); };
        } else {
          showSkip(false);
        }
      }
    } else {
      p.postUnlockWins += 1;
      p.baseTimeMs = Math.max(0, p.baseTimeMs - L.postDeltaSec*1000);
      showOverlay('Quadro completato âœ”ï¸', `Post-sblocco: ${p.postUnlockWins} completati<br>${detailRow}<br><small>Prossimo tentativo: tempo base ${Math.floor(p.baseTimeMs/1000)}s</small>`);
      ovBtn.textContent = 'Continua a giocare';
      ovBtn.onclick = () => { hideOverlay(); init(currentLevelIdx); };
    }

    if (activeSaveName) {
      upsertSave(activeSaveName, buildPayload());
      flashMessage('ğŸ’¾ Autosalvato: ' + activeSaveName);
    }
    updateSaveButton();
  }

  function lose(title, sub){
    const L = LEVELS[currentLevelIdx];
    const p = progress[currentLevelIdx];
    state.running = false;
    SFX.play('lose', { volume:1.0 });

    if (p.unlocked){
      const next = currentLevelIdx + 1;
      openSimonChoice(next);
      return;
    } else {
      p.streak = 0;
      p.baseTimeMs = L.unlockMs[0];

      totalScore = 0;
      frameBaseScore = 0;
      updateScoreChip();

      showOverlay(
        title || 'Hai perso',
        (sub || 'Ritenta!') +
        `<br><small>Sblocco: ${p.streak}/3 â€“ tempo base ripristinato a ${Math.floor(p.baseTimeMs/1000)}s</small>`
      );
      ovBtn.textContent = 'Riprova questo livello';
      ovBtn.onclick = () => { hideOverlay(); init(currentLevelIdx); };
    }
    updateSaveButton();
  }

function showOverlay(title, sub){
  ovTitle.textContent = title;
  ovSub.innerHTML = sub;

  // default: la X chiude semplicemente lâ€™overlay
  const x = document.querySelector('#overlay .tutorial-close, #ov-close');
  if (x) x.onclick = () => { hideOverlay(); };

  overlay.classList.add('show');
  showSkip(false);
  updateSaveButton();
  refreshPowersUI();
}
function hideOverlay(){
  overlay.classList.remove('show');
  overlay.setAttribute('aria-hidden','true');
  showSkip(false);
  updateSaveButton?.();
  refreshPowersUI?.();
}

function showZenSkullLose(){
  // ferma la manche corrente
  state.running = false;
  tapBuffer = [];
  state.lock = false;

  try { SFX.play('lose', { volume: 1.0 }); } catch(_) {}

  // Mostra il popup (qui la X viene mappata di default a hideOverlay)
  showOverlay('Oh no! ğŸ’€', 'Hai rivelato il teschio due volte.');

  // Rendi il bottone principale: rigioca subito la Zen
  ovBtn.textContent = 'Rigioca la Zen';
  ovBtn.onclick = () => { hideOverlay(); modeZen = true; startZen(); };

  // Nessun secondo bottone
  showSkip(false);

  // ğŸ‘‡ Sovrascrivi il comportamento della X SOLO per questo popup:
  // torna al menu (Arcade/Zen)
  const x = document.querySelector('#ov-close, #overlay .tutorial-close');
  if (x) x.onclick = () => { hideOverlay(); showIntro(); };
}

  function openSimonChoice(next){
    showOverlay(
      'Intermezzo bonus tempo ğŸ‘»',
      '<b>Bravo!</b> Prima di accedere al livello successivo puoi provare a guadagnare <b>secondi bonus</b> con un mini-gioco cliccando i fantasmini nella giusta sequenza.<br><br>' +
      '<small>Ogni passo corretto = <b>+1s</b> al prossimo livello. Se riveli il teschio il mini-gioco termina.</small>'
    );

    ovBtn.textContent = 'Prova il Bonus';
    ovBtn.onclick = () => {
      hideOverlay();
      startSimonIntermezzo();
    };

    showSkip(true);
    if (ovBtnSkip) {
      ovBtnSkip.textContent = 'Prosegui senza Bonus';
      ovBtnSkip.onclick = () => {
        hideOverlay();
        if (next < LEVELS.length) {
          init(next);
        } else {
          init(currentLevelIdx);
        }
      };
    }
  }

  function explainPower(which){
    let title = '', desc = '', avail = '';

    if (which === 'reveal'){
      title = 'ğŸ‘ï¸ Sbirciatina!';
      desc  = 'Svela tutte le carte per 1s ma costa il 20% del tempo rimanente.';
      avail = 'Disponibile dopo aver fatto almeno 1 coppia.';
    } else if (which === 'plus10'){
      title = 'ğŸ¦‡ Guadagna 10s!';
      desc  = '+10 secondi, ma una coppia giÃ  trovata torna coperta e viene rilocalizzata.';
      avail = 'Disponibile dopo aver fatto almeno 1 coppia.';
    } else if (which === 'shift'){
      title = 'ğŸŒ€ Guadagna 15s!';
      desc  = '+15 secondi, ma rimescola tutto, anche ğŸ’€ e âš¡.';
      avail = 'Disponibile dopo aver svelato almeno un ğŸ’€.';
    }

    const html = `${desc}<br><small>${avail}</small><br><small>Utilizzabile solo durante la manche.</small>`;
    showOverlay(title, html);
    ovBtn.textContent = 'Ok';
    ovBtn.onclick = () => { hideOverlay(); };
    showSkip(false);
  }

  function openRestartConfirm(){
    restartConfirm.classList.add('show');
    restartConfirm.setAttribute('aria-hidden','false');
    refreshPowersUI();
  }
  function closeRestartConfirm(){
    restartConfirm.classList.remove('show');
    restartConfirm.setAttribute('aria-hidden','true');
    refreshPowersUI();
  }

  function flashMessage(text){
    const msg = document.createElement('div');
    msg.className = 'flash-msg';
    msg.textContent = text;
    document.body.appendChild(msg);
    setTimeout(() => msg.remove(), 1500);
  }

  // ===== Multi-slot Saves =====
  function readSaves(){
    try{ const raw = localStorage.getItem(SAVES_KEY); return raw ? JSON.parse(raw) : []; }catch(e){ return []; }
  }
  function writeSaves(list){ try{ localStorage.setItem(SAVES_KEY, JSON.stringify(list)); }catch(e){} }
  function upsertSave(name, payload){
    const list = readSaves();
    const idx = list.findIndex(s => s && s.name === name);
    const entry = { name, when: Date.now(), data: payload };
    if(idx>=0) list[idx] = entry; else list.push(entry);
    writeSaves(list);
  }
  function deleteSave(name){ writeSaves(readSaves().filter(s => s && s.name !== name)); }

  function buildPayload(){
    return {
      version: 3,
      when: Date.now(),
      themeIndex,
      totalScore,
      currentLevelIdx,
      progress
    };
  }
  function loadPayload(data){
    if(!data) return false;
    themeIndex = data.themeIndex ?? themeIndex;
    totalScore = data.totalScore ?? 0;
    currentLevelIdx = data.currentLevelIdx ?? 0;
    if (Array.isArray(data.progress)) progress = data.progress;

    init(currentLevelIdx);
    frameBaseScore = totalScore;
    const b = document.body;
    b.className = (b.className || '').split(' ').filter(c => !c.startsWith('theme-')).join(' ');
    b.classList.add('theme-' + themeIndex);

    state.paused = false;
    state.running = false;
    pauseBtn.textContent = 'â¸ï¸';
    updateHud();
    updateSaveButton();
    return true;
  }

  function openSaveManager(){
 if (state?.isZen) {                         // â¬…ï¸ AGGIUNGI
    flashMessage('In Zen non si salva ğŸ˜Š');
    return;
  }
    if(!canSaveNow()){
      flashMessage('ğŸ’¾ Salva solo a fine quadro o prima di iniziare');
      return;
    }
    renderSaveList();
    const sc = document.getElementById('saveControls');
    if (sc) sc.style.display = '';

    saveModal.classList.add('show');
    saveModal.setAttribute('aria-hidden','false');
    saveNameInput.value = '';
    saveNameInput.focus();
  }
  function closeSaveManager(){
    saveModal.classList.remove('show');
    saveModal.setAttribute('aria-hidden','true');
  }
  function renderSaveList(){
    const list = readSaves().sort((a,b)=> (b.when||0)-(a.when||0));
    if(!list.length){ saveList.innerHTML = '<div style="color:var(--muted)">Nessun salvataggio.</div>'; return; }
    saveList.innerHTML = '';
    list.forEach(entry => {
      const row = document.createElement('div');
      row.className = 'save-row';
      row.style.display = 'grid';
      row.style.gridTemplateColumns = '1fr auto auto';
      row.style.gap = '8px';
      row.style.alignItems = 'center';
      row.style.padding = '6px 0';

      const name = document.createElement('div');
      const d = new Date(entry.when||Date.now());
      const title = document.createElement('b');  title.textContent = entry.name;
      const small = document.createElement('small'); small.textContent = d.toLocaleString();
      name.append(title, document.createElement('br'), small);

      const loadBtn = document.createElement('button');
      loadBtn.className = 'icon-btn';
      loadBtn.innerHTML = 'ğŸ“¤';
      loadBtn.title = 'Carica questo salvataggio';
      loadBtn.setAttribute('aria-label','Carica questo salvataggio');

      const delBtn = document.createElement('button');
      delBtn.className = 'icon-btn';
      delBtn.innerHTML = 'ğŸ—‘ï¸';
      delBtn.title = 'Elimina questo salvataggio';
      delBtn.setAttribute('aria-label','Elimina questo salvataggio');

      loadBtn.onclick = () => {
        loadPayload(entry.data);
        setActiveSaveName(entry.name);
        closeSaveManager();
        flashMessage('ğŸ“‚ Caricato: ' + entry.name);
      };
      delBtn.onclick = () => {
        document.querySelectorAll('.inline-confirm').forEach(el => el.remove());
        const rows = saveList.querySelectorAll('.save-row');
        rows.forEach(r => { if (r !== row) r.style.display = 'none'; });

        const toolbar = doSaveBtn ? doSaveBtn.parentElement : null;
        const restoreToolbar = () => { if (toolbar) toolbar.style.display = ''; };
        if (toolbar) toolbar.style.display = 'none';

        const wrap = document.createElement('div');
        wrap.className = 'inline-confirm';
        wrap.style.display = 'flex';
        wrap.style.gap = '8px';
        wrap.style.alignItems = 'center';
        wrap.style.gridColumn = '1 / -1';
        wrap.style.marginTop = '6px';
        wrap.style.padding = '8px 10px';
        wrap.style.border = '1px solid var(--panel-border)';
        wrap.style.borderRadius = '10px';
        wrap.style.background = 'linear-gradient(180deg,var(--panel-1),var(--panel-2))';
        wrap.innerHTML = `
          <span>Eliminare <b>${entry.name}</b>?</span>
          <div style="margin-left:auto; display:flex; gap:8px">
            <button class="primary" id="c-yes">SÃ¬, elimina</button>
            <button class="primary" id="c-no" style="background:var(--bad); color:#fff">Annulla</button>
          </div>
        `;

        row.after(wrap);

        wrap.querySelector('#c-yes').onclick = () => {
          deleteSave(entry.name);
          renderSaveList();
          restoreToolbar();
        };
        wrap.querySelector('#c-no').onclick = () => {
          wrap.remove();
          rows.forEach(r => { r.style.display = ''; });
          restoreToolbar();
        };
      };

      row.append(name, loadBtn, delBtn);
      saveList.appendChild(row);
    });
  }

  if (introBtn){ /* handler impostato da setTutorialMode() */ }

  restartBtn.addEventListener('click', () => { openRestartConfirm(); });
  if (restartYes) {
    restartYes.addEventListener('click', () => {
      closeRestartConfirm();
      hideOverlay();
      currentLevelIdx = 0;
      showIntro();
    });
  }
  if (restartNo) {
    restartNo.addEventListener('click', () => { closeRestartConfirm(); });
  }

  pauseBtn.addEventListener('click', togglePause);
  if(saveBtn){ saveBtn.addEventListener('click', openSaveManager); }
  if (powerRevealBtn) powerRevealBtn.addEventListener('click', usePowerReveal);
  if (powerPlus10Btn) powerPlus10Btn.addEventListener('click', usePowerPlus10);
  if (powerShiftBtn)  powerShiftBtn.addEventListener('click', usePowerShift);

  if (doSaveBtn) {
    let overwritePrompt = null;

    doSaveBtn.addEventListener('click', () => {
      const nm = (saveNameInput.value || '').trim();
      if (!nm) { flashMessage('Inserisci un nome'); return; }
      if (!canSaveNow()) { flashMessage('Puoi salvare solo a fine quadro o prima di iniziare'); return; }

      const exists = readSaves().some(s => s && s.name === nm);

      if (exists && !overwritePrompt) {
        overwritePrompt = document.createElement('div');
        overwritePrompt.setAttribute('role', 'dialog');
        overwritePrompt.setAttribute('aria-label', 'Conferma sovrascrittura salvataggio');
        overwritePrompt.style.marginTop = '8px';
        overwritePrompt.style.padding = '10px';
        overwritePrompt.style.background = 'var(--panel-1)';
        overwritePrompt.style.border = '1px solid var(--panel-border)';
        overwritePrompt.style.borderRadius = '12px';
        overwritePrompt.innerHTML = `
          <div style="margin-bottom:8px; color:var(--muted)">
            Sovrascrivere <b>${nm}</b>?
          </div>
          <div style="display:flex; gap:8px; justify-content:flex-end">
            <button class="primary" id="ow-yes" tabindex="0">SÃ¬</button>
            <button class="primary" id="ow-no" style="background:var(--bad); color:#fff">No</button>
          </div>
        `;

        saveNameInput.parentElement.parentElement.appendChild(overwritePrompt);

        const yesBtn = overwritePrompt.querySelector('#ow-yes');
        const noBtn  = overwritePrompt.querySelector('#ow-no');

        requestAnimationFrame(() => yesBtn && yesBtn.focus());

        yesBtn.onclick = () => {
          upsertSave(nm, buildPayload());
          setActiveSaveName(nm);
          flashMessage('ğŸ’¾ Sovrascritto: ' + nm);
          renderSaveList();
          saveNameInput.value = '';
          overwritePrompt.remove();
          overwritePrompt = null;
        };

        noBtn.onclick = () => {
          overwritePrompt.remove();
          overwritePrompt = null;
        };

        setTimeout(() => {
          if (overwritePrompt) {
            overwritePrompt.remove();
            overwritePrompt = null;
          }
        }, 5000);

        return;
      }

      upsertSave(nm, buildPayload());
      setActiveSaveName(nm);
      flashMessage('ğŸ’¾ Salvato: ' + nm);
      renderSaveList();
      saveNameInput.value = '';
    });
  }

  if (saveClose){ saveClose.addEventListener('click', closeSaveManager); }

  // scorciatoia Ctrl/âŒ˜+S
  window.addEventListener('keydown', (e)=>{
    const sKey = (e.key||'').toLowerCase()==='s';
    if(sKey && (e.ctrlKey || e.metaKey)){
      e.preventDefault();
      if (!state?.isZen) openSaveManager();
    }
  });

  // ===== Pausa / Resume =====
function togglePause(){
  if (!state) return;

  // âœ… Gestione dedicata per la Zen: niente timer, solo blocco/sblocco input
  if (state.isZen){
    state.paused = !state.paused;
    pauseBtn.textContent = state.paused ? 'â–¶' : 'â¸ï¸';
    if (state.paused) {
      // svuota tocchi in coda e blocca il gioco
      tapBuffer = [];
    }
    refreshPowersUI();
    return;
  }

  // ğŸ•¹ï¸ Arcade (logica esistente)
  if(!state.running && state.pauseLeftMs > 0){
    state.paused = false;
    state.running = true;
    state.deadlineTs = performance.now() + state.pauseLeftMs;
    state.pauseLeftMs = 0;
    pauseBtn.textContent = 'â¸ï¸';
    tick();
    refreshPowersUI();
    return;
  }
  if(state.running){
    state.paused = true;
    const now = performance.now();
    state.pauseLeftMs = Math.max(0, state.deadlineTs - now);
    state.running = false;
    pauseBtn.textContent = 'â–¶';
    tapBuffer = [];
    refreshPowersUI();
    return;
  }
}


  // --- S P L A S H ---
  document.addEventListener('DOMContentLoaded', () => {
    const splash = document.getElementById('splash');
    let splashTimer = null;

    function showSplash(){
      if (!splash) return;
      splash.classList.remove('hide');
      splash.classList.add('show');
    }
    function hideSplash(){
      if (!splash) return;
      splash.classList.add('hide');
      splash.classList.remove('show');
    }
    function skipSplash(){
      if (splashTimer) { clearTimeout(splashTimer); splashTimer = null; }
      ensureSfx();
      hideSplash();
      showIntro();
    }

    if (splash){
      splash.addEventListener('click', skipSplash);
      window.addEventListener('keydown', (e) => {
        if (!splash || splash.classList.contains('hide')) return;
        if (e.key === 'Enter' || e.key === ' ' || e.key === 'Escape') skipSplash();
      });
    }

    init(0);
    showSplash();
    splashTimer = setTimeout(() => {
      hideSplash();
      showIntro();
    }, 3000);
  });

  // Migrazione legacy â†’ slot "Ultimo"
  try{
    if(localStorage.getItem(STORAGE_KEY)){
      const raw = localStorage.getItem(STORAGE_KEY);
      const data = raw ? JSON.parse(raw) : null;
      if(data) upsertSave('Ultimo', { version:3, themeIndex, totalScore:0, currentLevelIdx:0, progress });
      localStorage.removeItem(STORAGE_KEY);
      flashMessage('Importato salvataggio legacy in "Ultimo"');
    }
  }catch(e){}
})();
</script>

<!-- Splash pre-tutorial (3s) -->
<div id="splash" class="splash show" role="button" aria-label="Splash iniziale (tocca per saltare)">
  <svg viewBox="0 0 1200 1200" preserveAspectRatio="xMidYMid meet" class="splash-art" aria-hidden="true">
    <defs>
      <radialGradient id="bg" cx="50%" cy="40%" r="70%">
        <stop offset="0%" stop-color="#2b335c"/>
        <stop offset="100%" stop-color="#141724"/>
      </radialGradient>
    </defs>
    <rect width="1200" height="1200" fill="url(#bg)"/>
  </svg>
  <img src="splash-template.svg" class="splash-art" alt="Skullory" style="position:absolute;">
</div>

</body>
</html>
